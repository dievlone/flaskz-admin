/*! Focus UI v2.4.2 | http://www.focus-ui.com | 2023-08-17 | Licensed to Cisco */
(function(window, undefined) {
    "use strict";
    var z = {
        version: "2.4.0"
    };
    var Object = window.Object, Array = window.Array, String = window.String, document = window.document, Math = window.Math, parseInt = window.parseInt, parseFloat = window.parseFloat, devicePixelRatio = window.devicePixelRatio || 1, $ObjectToString = Object.prototype.toString, $ArrayPush = Array.prototype.push, $ArraySlice = Array.prototype.slice, $ObjectKeys = Object.keys, $createDomElement = document.createElement.bind(document), $MathPI = Math.PI, $MathPow = Math.pow, $MathSqrt = Math.sqrt, $MathAtan2 = Math.atan2, $MathAbs = Math.abs, $MathMax = Math.max, $MathMin = Math.min, $MathCos = Math.cos, $MathSin = Math.sin, $MathAcos = Math.acos, $MathTan = Math.tan, $MathFloor = Math.floor, $MathCeil = Math.ceil, $MathRound = Math.round, $MathRandom = Math.random;
    if (typeof Object.assign !== "function") {
        Object.defineProperty(Object, "assign", {
            value: function assign(target, varArgs) {
                "use strict";
                if (target == null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                }
                var to = Object(target);
                var len = arguments.length;
                for (var i = 1; i < len; i++) {
                    var nextSource = arguments[i];
                    if (nextSource != null) {
                        for (var nextKey in nextSource) {
                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
                return to;
            },
            writable: true,
            configurable: true
        });
    }
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function(search, rawPos) {
            var pos = rawPos > 0 ? rawPos | 0 : 0;
            return this.substring(pos, pos + search.length) === search;
        };
    }
    if (!String.prototype.endsWith) {
        String.prototype.endsWith = function(search, this_len) {
            if (this_len === undefined || this_len > this.length) {
                this_len = this.length;
            }
            return this.substring(this_len - search.length, this_len) === search;
        };
    }
    if (!Number.isInteger) {
        Number.isInteger = function(value) {
            return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
        };
    }
    var $Defaults = {};
    if (window.FOCUS_UI_DEFAULTS) {
        Object.assign($Defaults, window.FOCUS_UI_DEFAULTS);
    }
    var $setDefault = function(key, value) {
        if ($isObject(key)) {
            $eachObject(key, function(k, v) {
                $setObjectDeepValue($Defaults, k, v);
            });
        } else {
            $setObjectDeepValue($Defaults, key, value);
        }
    };
    var $getDefault = function(key) {
        return $getObjectDeepValue($Defaults, key);
    };
    var $setSysDefault = function(key, value) {
        if ($isObject(key)) {
            $eachObject(key, function(k, v) {
                if (!$Defaults.hasOwnProperty(k)) {
                    $Defaults[k] = v;
                }
            });
        } else {
            if (!$Defaults.hasOwnProperty(key)) {
                $Defaults[key] = value;
            }
        }
    };
    var $StrUtil = {
        capitalize: function(str) {
            return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
        },
        replaceVars: function(str, vars, varRegExp) {
            if ($isObject(vars)) {
                varRegExp = varRegExp || /{{(.+?)}}/;
                varRegExp = new RegExp(varRegExp, "g");
                return str.replace(varRegExp, function(word, model) {
                    var v = $getObjectDeepValue(vars, model);
                    if ($isObject(v)) {
                        return JSON.stringify(v);
                    }
                    return v;
                });
            }
            return str;
        }
    };
    var $strCapitalize = $StrUtil.capitalize;
    var $FuncUtil = {
        getArgsArray: function(args, begin, end) {
            var arg_len = arguments.length;
            if (arg_len < 2) {
                begin = 0;
            }
            if (arg_len < 3) {
                end = args.length;
            }
            return $ArraySlice.call(args, begin, end);
        }
    };
    var $getArgsArray = $FuncUtil.getArgsArray;
    var $TypeConst = {
        MODEL: "fu_model",
        DATA: "fu_data",
        PROVIDER: "fu_provider",
        VIEW: "fu_view",
        GVIEW: "fu_gview",
        NODE: "fu_node",
        LINK: "fu_link",
        GROUP: "fu_group",
        SUBVIEW: "fu_subview",
        LINKSUBVIEW: "fu_linksubview"
    };
    var $TypeCheck = {
        isArray: function(obj) {
            return Array.isArray(obj);
        },
        isString: function(obj) {
            return $TypeCheck.isPrimitiveType(obj, "String");
        },
        isBoolean: function(obj) {
            return $TypeCheck.isPrimitiveType(obj, "Boolean");
        },
        isObject: function(obj) {
            return $TypeCheck.isPrimitiveType(obj, "Object");
        },
        isFunction: function(obj) {
            return $TypeCheck.isPrimitiveType(obj, "Function");
        },
        isNumber: function(obj) {
            return $TypeCheck.isPrimitiveType(obj, "Number");
        },
        isPrimitiveType: function(obj, type) {
            if (type) {
                type = "[object " + type + "]";
                return $ObjectToString.apply(obj) === type;
            }
            return false;
        }
    };
    var $isArray = $TypeCheck.isArray, $isString = $TypeCheck.isString, $isBoolean = $TypeCheck.isBoolean, $isObject = $TypeCheck.isObject, $isFunction = $TypeCheck.isFunction, $isNumber = $TypeCheck.isNumber;
    var $ArrayUtil = {
        merge: function(firstArr) {
            var len = arguments.length;
            for (var i = 1; i < len; i++) {
                $ArrayPush.apply(firstArr, arguments[i]);
            }
            return firstArr;
        },
        each: function(arr, fun, thisArg) {
            var len = arr.length;
            if (len === 0) {
                return;
            }
            for (var i = 0; i < len; i++) {
                if (fun.apply(thisArg, [ arr[i], i ]) === false) {
                    return;
                }
            }
        },
        filter: function(arr, fun, thisArg) {
            return arr.filter(fun, thisArg);
        },
        find: function(arr, fun, thisArg) {
            var len = arr.length;
            if (len === 0) {
                return;
            }
            for (var i = 0; i < len; i++) {
                if (fun.apply(thisArg, [ arr[i], i ]) === true) {
                    return arr[i];
                }
            }
            return undefined;
        },
        removeItem: function(arr, fun, thisArg) {
            var len = arr.length;
            if (len === 0) {
                return;
            }
            for (var i = 0; i < len; i++) {
                var item = arr[i];
                if (fun.apply(thisArg, [ item, i ]) === true) {
                    arr.splice(i, 1);
                    return item;
                }
            }
            return undefined;
        },
        toMap: function(arr, keyFun, thisArg) {
            var map = {};
            if ($isFunction(keyFun)) {
                arr.forEach(function(item) {
                    map[keyFun.apply(thisArg, [ item ])] = item;
                });
            } else {
                arr.forEach(function(item) {
                    map[item[keyFun]] = item;
                });
            }
            return map;
        },
        _removeByItem: function(arr, item, all) {
            var len = arr.length;
            var i = 0;
            if (all === true) {
                for (i = len - 1; i > -1; i--) {
                    if (arr[i] === item) {
                        arr.splice(i, 1);
                    }
                }
            } else {
                for (i = 0; i < len; i++) {
                    if (arr[i] === item) {
                        arr.splice(i, 1);
                        return arr;
                    }
                }
            }
            return arr;
        }
    };
    var $mergeArray = $ArrayUtil.merge, $eachArray = $ArrayUtil.each, $filterArray = $ArrayUtil.filter, $findArray = $ArrayUtil.find, $removeArrayItem = $ArrayUtil.removeItem, $toArrayMap = $ArrayUtil.toMap, $arrayRemoveItem = $ArrayUtil._removeByItem;
    var $ObjectUtil = {
        merge: function() {
            return Object.assign.apply(null, arguments);
        },
        deepMerge: function(targetObj) {
            var len = arguments.length;
            var kvMap = {};
            for (var i = 1; i < len; i++) {
                var obj = arguments[i];
                $ObjectKeys(obj).forEach(function(p) {
                    $ObjectUtil.createKVMap(kvMap, p, obj[p]);
                });
            }
            $ObjectKeys(kvMap).forEach(function(p) {
                $ObjectUtil.setDeepValue(targetObj, p, kvMap[p]);
            });
            return targetObj;
        },
        getDeepKVMap: function(obj) {
            var kvMap = {};
            $ObjectKeys(obj).forEach(function(p) {
                $ObjectUtil.createKVMap(kvMap, p, obj[p]);
            });
            return kvMap;
        },
        createKVMap: function(kvMap, prefix, value) {
            if ($isObject(value)) {
                var key = prefix + ".";
                $ObjectKeys(value).forEach(function(p) {
                    $ObjectUtil.createKVMap(kvMap, key + p, value[p]);
                });
            } else {
                kvMap[prefix] = value;
            }
        },
        each: function(object, callBack, context) {
            var keys = $ObjectKeys(object);
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                var key = keys[i];
                if (callBack.apply(context, [ key, object[key] ]) === false) {
                    return;
                }
            }
        },
        filter: function(object, callBack, thisArg) {
            var keys = $ObjectKeys(object);
            var len = keys.length;
            var result = {};
            for (var i = 0; i < len; i++) {
                var key = keys[i];
                var value = object[key];
                if (callBack.apply(thisArg, [ key, value ]) === true) {
                    result[key] = value;
                }
            }
            return result;
        },
        hasDeepValue: function(object, deepPath, pathSeparator) {
            pathSeparator = pathSeparator || ".";
            var keys = deepPath.split(pathSeparator);
            var len = keys.length;
            if (len === 1) {
                return object.hasOwnProperty(deepPath);
            }
            var v;
            var key = keys[0];
            if (!object.hasOwnProperty(key)) {
                return false;
            } else {
                v = object[key];
                var lenLess = len - 1;
                if ($isObject(v)) {
                    var index = 1;
                    while (index < len) {
                        key = keys[index];
                        if (v.hasOwnProperty(key)) {
                            v = v[key];
                            if (index !== lenLess && !$isObject(v)) {
                                return false;
                            }
                        } else {
                            return false;
                        }
                        index++;
                    }
                } else {
                    return false;
                }
            }
            return true;
        },
        getDeepValue: function(object, deepPath, pathSeparator) {
            pathSeparator = pathSeparator || ".";
            var keys = deepPath.split(pathSeparator);
            var len = keys.length;
            if (len === 1) {
                return object[deepPath];
            }
            var v;
            var key = keys[0];
            if (!object.hasOwnProperty(key)) {
                v = undefined;
            } else {
                v = object[key];
                var lenLess = len - 1;
                if ($isObject(v)) {
                    var index = 1;
                    while (index < len) {
                        key = keys[index];
                        if (v.hasOwnProperty(key)) {
                            v = v[key];
                            if (index !== lenLess && !$isObject(v)) {
                                v = undefined;
                                break;
                            }
                        } else {
                            v = undefined;
                            break;
                        }
                        index++;
                    }
                } else {
                    v = undefined;
                }
            }
            return v;
        },
        setDeepValue: function(object, deepPath, value, pathSeparator) {
            pathSeparator = pathSeparator || ".";
            var keys = deepPath.split(pathSeparator);
            var len = keys.length;
            if (len === 1) {
                object[deepPath] = value;
                return;
            }
            var key = keys[0];
            var v = object[key];
            if (!$isObject(v)) {
                v = {};
                object[key] = v;
            }
            var index = 1;
            var lenLess = len - 1;
            while (index < lenLess) {
                key = keys[index];
                var nv = v[key];
                if (!$isObject(nv)) {
                    nv = {};
                    v[key] = nv;
                }
                v = nv;
                index++;
            }
            v[keys[lenLess]] = value;
        },
        getValues: function(object) {
            var keys = $ObjectKeys(object);
            var len = keys.length;
            var values = [];
            for (var i = 0; i < len; i++) {
                values.push(object[keys[i]]);
            }
            return values;
        }
    };
    if (Object.values) {
        $ObjectUtil.getValues = function(object) {
            return Object.values(object);
        };
    }
    var $mergeObject = $ObjectUtil.merge, $deepMergeObject = $ObjectUtil.deepMerge, $eachObject = $ObjectUtil.each, $filterObject = $ObjectUtil.filter, $hasObjectDeepValue = $ObjectUtil.hasDeepValue, $getObjectDeepValue = $ObjectUtil.getDeepValue, $setObjectDeepValue = $ObjectUtil.setDeepValue, $getObjectValues = $ObjectUtil.getValues;
    var $I18nUtil = {
        i18n_map: Object.create(null),
        i18n_count: 0,
        getLabel: function(key, local) {
            var iMap = $I18nUtil.i18n_map[local || $I18nUtil.getLocal()];
            if (iMap) {
                var label = $getObjectDeepValue(iMap, key);
                if (label != null) {
                    return label;
                }
            }
            return "";
        },
        setLocal: function(local) {
            $I18nUtil.local = local;
        },
        getLocal: function() {
            return $I18nUtil.local;
        },
        add: function(name, obj, replace) {
            var current = $I18nUtil.i18n_map[name];
            if (current) {
                if (replace === true) {
                    if ($isObject(obj)) {
                        $I18nUtil.i18n_map[name] = obj;
                    } else {
                        delete $I18nUtil.i18n_map[name];
                        $I18nUtil.i18n_count--;
                    }
                } else {
                    $deepMergeObject(current, obj);
                }
            } else {
                if ($isObject(obj)) {
                    $I18nUtil.i18n_map[name] = obj;
                    if ($I18nUtil.i18n_count === 0 && $I18nUtil.local == null) {
                        $I18nUtil.setLocal(name);
                    }
                    $I18nUtil.i18n_count++;
                }
            }
        }
    };
    var $ClassUtil = {
        extend: function(Child, Parent, props) {
            var F = function() {};
            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.prototype.constructor = Child;
            Child.superClass = Parent.prototype;
            Child.__zsuperClass_ = Parent;
            if (props) {
                $eachObject(props, function(p, v) {
                    if (p.indexOf("___z") === 0) {
                        if (p === "___zdefaults_") {
                            if (v) {
                                $eachObject(v, function(key, value) {
                                    $ClassUtil.setClassDefault(Child, key, value);
                                });
                            }
                        } else {
                            var getFuncPrefix = "";
                            if (p === "___zsg") {
                                getFuncPrefix = "get";
                            } else if (p === "___zsi") {
                                getFuncPrefix = "is";
                            }
                            var c = v.length;
                            for (var j = 0; j < c; j++) {
                                var vv = v[j];
                                if (vv) {
                                    var name = vv.trim();
                                    if (name) {
                                        var setName = $ClassUtil.getSetFuncName(name);
                                        var getName = $ClassUtil.getGetFuncName(name, getFuncPrefix);
                                        Child.prototype[setName] = $ClassUtil.createSetFunc(name);
                                        Child.prototype[getName] = $ClassUtil.createGetFunc(name);
                                    }
                                }
                            }
                        }
                    } else {
                        if (p === "__className_") {
                            $ClassUtil.__classNameMap[v] = Child;
                            Child.__className_ = v;
                        } else {
                            Child.prototype[p] = v;
                        }
                    }
                });
            }
        },
        getSetFuncName: function(name) {
            var names = name.split("_");
            var funcName = "set";
            names.forEach(function(item) {
                funcName += $strCapitalize(item);
            });
            return funcName;
        },
        getGetFuncName: function(name, getFuncPrefix) {
            var names = name.split("_");
            var funcName = getFuncPrefix;
            names.forEach(function(item) {
                funcName += $strCapitalize(item);
            });
            return funcName;
        },
        createSetFunc: function(name) {
            return function(nv) {
                this.setProperty(name, nv);
            };
        },
        createGetFunc: function(name) {
            return function() {
                return this.getProperty(name);
            };
        },
        getClassDefault: function(clazz, key) {
            var dfs = clazz.___zdefaults_;
            if (dfs == null || !dfs.hasOwnProperty(key)) {
                if (clazz.__zsuperClass_) {
                    return $ClassUtil.getClassDefault(clazz.__zsuperClass_, key);
                } else {
                    return null;
                }
            }
            return dfs[key];
        },
        setClassDefault: function(clazz, key, value) {
            var dfs = clazz.___zdefaults_;
            if (dfs == null) {
                dfs = {};
                clazz.___zdefaults_ = dfs;
            }
            dfs[key] = value;
        },
        _setClassDefault: function(clazz, key, value) {
            var aLen = arguments.length;
            if (aLen === 2) {
                $eachObject(key, function(p, v) {
                    $ClassUtil.setClassDefault(clazz, p, v);
                });
            } else if (aLen > 2) {
                $ClassUtil.setClassDefault(clazz, key, value);
            }
        },
        _extendPrototype: function(clazz, prop, value) {
            var aLen = arguments.length;
            if (aLen === 2) {
                $eachObject(prop, function(p, v) {
                    clazz.prototype[p] = v;
                });
            } else if (aLen > 2) {
                clazz.prototype[prop] = value;
            }
        },
        __classNameMap: {},
        createInstance: function(clazz, args) {
            if (!clazz) {
                return null;
            }
            if ($isString(clazz)) {
                clazz = $ClassUtil.getClassByName(clazz);
            }
            if (clazz) {
                if (arguments.length === 2) {
                    return $ClassUtil.__createInstance(clazz, args);
                } else {
                    return new clazz();
                }
            }
            return null;
        },
        __createInstance: function(clazz, params) {
            var size = params.length;
            switch (size) {
                case 0:
                    return new clazz();

                case 1:
                    return new clazz(params[0]);

                case 2:
                    return new clazz(params[0], params[1]);

                case 3:
                    return new clazz(params[0], params[1], params[2]);

                case 4:
                    return new clazz(params[0], params[1], params[2], params[3]);

                case 5:
                    return new clazz(params[0], params[1], params[2], params[3], params[4]);

                case 6:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5]);

                case 7:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);

                case 8:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7]);

                case 9:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8]);

                case 10:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9]);

                case 11:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10]);

                case 12:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10], params[11]);

                case 13:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10], params[11], params[12]);

                case 14:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10], params[11], params[12], params[13]);

                case 15:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10], params[11], params[12], params[13], params[14]);

                case 16:
                    return new clazz(params[0], params[1], params[2], params[3], params[4], params[5], params[6], params[7], params[8], params[9], params[10], params[11], params[12], params[13], params[14], params[14]);

                default:
                    throw new Error("So many parameters(>16) are not supported...");
            }
        },
        getClassByName: function(className) {
            if ($ClassUtil.__classNameMap.hasOwnProperty(className)) {
                return $ClassUtil.__classNameMap[className];
            } else {
                var names = className.split(".");
                var len = names.length;
                var clazz = null;
                if (len > 0) {
                    var func = window[names[0]];
                    var index = 1;
                    while (func && index < len) {
                        func = func[names[index]];
                        index++;
                    }
                    clazz = func;
                }
                return clazz;
            }
        },
        newClass: function(parentClass, constructor, protoProps, classDefaultProps) {
            var clazz = function() {
                clazz.superClass.constructor.apply(this, arguments);
                constructor.apply(this, arguments);
            };
            $ClassUtil.extend(clazz, parentClass || Object, protoProps);
            if (classDefaultProps) {
                $eachObject(classDefaultProps, function(key, value) {
                    $ClassUtil.setClassDefault(clazz, key, value);
                });
            }
            return clazz;
        }
    };
    var $extendClass = $ClassUtil.extend;
    var $ArrayMap = function() {
        this._array = [];
        this._map = {};
    };
    $extendClass($ArrayMap, Object, {
        add: function(key, item, arrayIndex) {
            if (this.has(key) === true) {
                var old = this._map[key];
                if (old === item) {
                    return;
                }
                $arrayRemoveItem(this._array, old);
            }
            this._map[key] = item;
            if (arguments.length >= 3) {
                this._array.splice(arrayIndex, 0, item);
            } else {
                this._array.push(item);
            }
        },
        remove: function(key) {
            var item;
            if (this.has(key) === true) {
                item = this._map[key];
                delete this._map[key];
                $arrayRemoveItem(this._array, item);
            }
            return item;
        },
        clear: function() {
            this._array.length = 0;
            this._map = {};
        },
        has: function(key) {
            return this._map.hasOwnProperty(key);
        },
        get: function(key) {
            return this._map[key];
        },
        keys: function() {
            return $ObjectKeys(this._map);
        },
        size: function() {
            return this._array.length;
        },
        toArray: function(copy) {
            if (copy === false) {
                return this._array;
            }
            return $mergeArray([], this._array);
        },
        eachObject: function(func, context) {
            return $eachObject(this._map, func, context);
        },
        eachArray: function(func, context) {
            return $eachArray(this._array, func, context);
        },
        findArray: function(func, context) {
            return $findArray(this._array, func, context);
        },
        filterArray: function(func, context) {
            return $filterArray(this._array, func, context);
        }
    });
    var $WindowSetTimeout = window.setTimeout;
    var $WindowClearTimeout = window.clearTimeout;
    var $TimerUtil = {
        __callLaterListMap: new $ArrayMap(),
        __callIntervalListMap: new $ArrayMap(),
        __callRAFIntervalListMap: new $ArrayMap(),
        callBatch: function(callBack, option) {
            option = option || {};
            var batHost = option.object || option.context || window;
            var batch_key = option.key || "_call_batch_key";
            if (batHost[batch_key] !== true) {
                batHost[batch_key] = true;
                var f = function() {
                    callBack.apply(option.context);
                    if (option.reset !== false) {
                        delete batHost[batch_key];
                    }
                };
                $TimerUtil.callRAFLater(f);
                return true;
            }
            return false;
        },
        callLater: function(callBack, delay, thisArg) {
            var id = $Util.guid();
            var laterCallBack = function() {
                var fid = laterCallBack.id;
                if (fid != null) {
                    callBack.apply(thisArg, []);
                    $TimerUtil.__deleteCallLater(fid);
                }
            };
            laterCallBack.id = id;
            var timeout_id = $TimerUtil.__setTimeout(laterCallBack, delay);
            $TimerUtil.__callLaterListMap.add(id, {
                id: id,
                timeout_id: timeout_id,
                later_callBack: laterCallBack,
                callBack: callBack,
                delay: delay,
                context: thisArg
            });
            return id;
        },
        cancelCallLater: function(callBack, delay, thisArg) {
            if (!$isFunction(callBack)) {
                $TimerUtil.__deleteCallLater(callBack);
            } else {
                $TimerUtil.__callLaterListMap.eachArray(function(item) {
                    if (item.callBack === callBack && item.delay === delay && item.context === thisArg) {
                        $TimerUtil.__deleteCallLater(item.id);
                        return false;
                    } else {
                        return true;
                    }
                });
            }
        },
        callInterval: function(callBack, delay, context, immediately, onlyDomVisible) {
            if (immediately === true) {
                if (callBack.apply(context) === false) {
                    return;
                }
            }
            var id = $Util.guid();
            var laterCallBack = function() {
                var fid = laterCallBack.id;
                if (fid != null) {
                    if (onlyDomVisible === true) {
                        if (document && document.visibilityState !== "visible") {
                            $TimerUtil.__setTimeout(laterCallBack, delay);
                            return;
                        }
                    }
                    if (callBack.apply(context, arguments) !== false) {
                        $TimerUtil.__setTimeout(laterCallBack, delay);
                    } else {
                        $TimerUtil.__deleteInterval(fid);
                    }
                }
            };
            laterCallBack.id = id;
            $TimerUtil.__callIntervalListMap.add(id, {
                id: id,
                later_callBack: laterCallBack,
                callBack: callBack,
                delay: delay,
                context: context
            });
            $TimerUtil.__setTimeout(laterCallBack, delay);
            return id;
        },
        cancelCallInterval: function(callBack, delay, context) {
            if (!$isFunction(callBack)) {
                $TimerUtil.__deleteInterval(callBack);
            } else {
                $TimerUtil.__callIntervalListMap.eachArray(function(item) {
                    if (item.callBack === callBack && item.delay === delay && item.context === context) {
                        $TimerUtil.__deleteInterval(item.id);
                        return false;
                    } else {
                        return true;
                    }
                });
            }
        },
        callRAFLater: function(callBack, context) {
            return $TimerUtil.requestAnimationFrame(callBack, context);
        },
        callRAFInterval: function(callBack, context, immediately) {
            if (immediately === true) {
                var result = callBack.apply(context);
                if (result === false) {
                    return;
                }
            }
            var id = $Util.guid();
            var laterCallBack = function() {
                var fid = laterCallBack.id;
                if (fid != null) {
                    if (callBack.apply(context, arguments) !== false) {
                        $TimerUtil.requestAnimationFrame(laterCallBack);
                    } else {
                        $TimerUtil.__deleteRAFInterval(fid);
                    }
                }
            };
            laterCallBack.id = id;
            $TimerUtil.__callRAFIntervalListMap.add(id, {
                id: id,
                later_callBack: laterCallBack,
                callBack: callBack,
                context: context
            }, laterCallBack);
            $TimerUtil.requestAnimationFrame(laterCallBack);
            return id;
        },
        cancelCallRAFInterval: function(callBack, context) {
            if (!$isFunction(callBack)) {
                $TimerUtil.__deleteRAFInterval(callBack);
            } else {
                $TimerUtil.__callRAFIntervalListMap.eachArray(function(item) {
                    if (item.callBack === callBack && item.context === context) {
                        $TimerUtil.__deleteRAFInterval(item.id);
                        return false;
                    } else {
                        return true;
                    }
                });
            }
        },
        __setTimeout: function(fun, delay, context) {
            var f = fun;
            if (context != null) {
                f = fun.bind(context);
            }
            return $WindowSetTimeout(f, delay);
        },
        __deleteCallLater: function(id) {
            var item = $TimerUtil.__callLaterListMap.remove(id);
            if (item) {
                var later_callBack = item.later_callBack;
                delete later_callBack.id;
                var timeout_id = item.timeout_id;
                if (timeout_id) {
                    $WindowClearTimeout(timeout_id);
                }
            }
        },
        __deleteInterval: function(id) {
            var item = $TimerUtil.__callIntervalListMap.remove(id);
            if (item) {
                var laterCallBack = item.later_callBack;
                delete laterCallBack.id;
            }
        },
        __deleteRAFInterval: function(id) {
            var item = $TimerUtil.__callRAFIntervalListMap.remove(id);
            if (item) {
                var laterCallBack = item.later_callBack;
                delete laterCallBack.id;
            }
        }
    };
    $TimerUtil.__raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
    if ($TimerUtil.__raf) {
        $TimerUtil.requestAnimationFrame = function(fun, context) {
            if (fun) {
                var f = fun;
                if (context != null) {
                    f = fun.bind(context);
                }
                return $TimerUtil.__raf.call(window, f);
            }
            return undefined;
        };
    } else {
        $TimerUtil.requestAnimationFrame = function(fun, context) {
            return $TimerUtil.__setTimeout(fun, 17, context);
        };
    }
    var $callBatch = $TimerUtil.callBatch, $callLater = $TimerUtil.callLater, $callInterval = $TimerUtil.callInterval, $callRAFLater = $TimerUtil.callRAFLater, $callRAFInterval = $TimerUtil.callRAFInterval;
    $setSysDefault({
        DATE_LOCAL_TIMEZONE_OFFSET: new Date().getTimezoneOffset(),
        DATE_TIME_FORMAT: "%Y-%m-%d %H:%M:%S",
        DATE_TIME_WEEKS: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        DATE_TIME_MONTHS: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ]
    });
    var $DateUtil = {
        _getLocalTimezoneOffset: function() {
            return $getDefault("DATE_LOCAL_TIMEZONE_OFFSET") | 0;
        },
        toLocalDate: function(time, timezoneOffset) {
            var date;
            if ($isNumber(time)) {
                date = new Date($DateUtil.getTimestamp(time));
            } else {
                date = new Date(time);
            }
            if (isNaN(date.getTime())) {
                return null;
            }
            if (timezoneOffset == null) {
                timezoneOffset = $DateUtil._getLocalTimezoneOffset();
            }
            date.setMinutes(date.getUTCMinutes() - timezoneOffset);
            return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        },
        format: function(date, options) {
            options = options || {};
            var date_format = options.date_format;
            var out_format = options.out_format;
            var timezone_offset = options.timezone_offset;
            if (date == null) {
                return "";
            }
            if (!(date instanceof Date)) {
                if (date_format) {
                    date = $DateUtil.parseByFormat(date, date_format);
                } else {
                    date = $DateUtil.toLocalDate(date, timezone_offset);
                }
            }
            if (!(date instanceof Date) || isNaN(date.getTime())) {
                return "";
            }
            if (out_format == null) {
                out_format = $getDefault("DATE_TIME_FORMAT");
            }
            var aDays = $getDefault("DATE_TIME_WEEKS"), aMonths = $getDefault("DATE_TIME_MONTHS");
            var nDay = date.getDay(), nDate = date.getDate(), nMonth = date.getMonth(), nYear = date.getFullYear(), nHour = date.getHours(), aDayCount = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], isLeapYear = function() {
                if ((nYear & 3) !== 0) return false;
                return nYear % 100 !== 0 || nYear % 400 === 0;
            }, getThursday = function() {
                var target = new Date(date);
                target.setDate(nDate - (nDay + 6) % 7 + 3);
                return target;
            }, zeroPad = function(nNum, nPad) {
                return ("" + ($MathPow(10, nPad) + nNum)).slice(1);
            };
            return out_format.replace(/%[a-z]/gi, function(sMatch) {
                return {
                    "%a": aDays[nDay].slice(0, 3),
                    "%A": aDays[nDay],
                    "%b": aMonths[nMonth].slice(0, 3),
                    "%B": aMonths[nMonth],
                    "%c": date.toUTCString(),
                    "%C": $MathFloor(nYear / 100),
                    "%d": zeroPad(nDate, 2),
                    "%e": nDate,
                    "%F": date.toISOString().slice(0, 10),
                    "%G": getThursday().getFullYear(),
                    "%g": ("" + getThursday().getFullYear()).slice(2),
                    "%H": zeroPad(nHour, 2),
                    "%I": zeroPad((nHour + 11) % 12 + 1, 2),
                    "%j": zeroPad(aDayCount[nMonth] + nDate + (nMonth > 1 && isLeapYear() ? 1 : 0), 3),
                    "%k": "" + nHour,
                    "%l": (nHour + 11) % 12 + 1,
                    "%m": zeroPad(nMonth + 1, 2),
                    "%M": zeroPad(date.getMinutes(), 2),
                    "%p": nHour < 12 ? "AM" : "PM",
                    "%P": nHour < 12 ? "am" : "pm",
                    "%s": $MathRound(date.getTime() / 1e3),
                    "%S": zeroPad(date.getSeconds(), 2),
                    "%u": nDay || 7,
                    "%V": function() {
                        var target = getThursday(), n1stThu = target.valueOf();
                        target.setMonth(0, 1);
                        var nJan1 = target.getDay();
                        if (nJan1 !== 4) target.setMonth(0, 1 + (4 - nJan1 + 7) % 7);
                        return zeroPad(1 + $MathCeil((n1stThu - target) / 6048e5), 2);
                    }(),
                    "%w": "" + nDay,
                    "%x": date.toLocaleDateString(),
                    "%X": date.toLocaleTimeString(),
                    "%y": ("" + nYear).slice(2),
                    "%Y": nYear,
                    "%z": date.toTimeString().replace(/.+GMT([+-]\d+).+/, "$1"),
                    "%Z": date.toTimeString().replace(/.+\((.+?)\)$/, "$1")
                }[sMatch] || sMatch;
            });
        },
        getTimestamp: function(timestamp) {
            timestamp = parseInt(timestamp);
            var len = (timestamp + "").length;
            if (len === 13) {
                return timestamp;
            }
            if (len === 10) {
                return parseInt(timestamp * 1e3);
            }
            return null;
        },
        _parseFormat: {
            "%": [ "%", function() {} ],
            a: [ "[a-z]+", function(matched) {} ],
            A: [ "[a-z]+", function(matched) {} ],
            b: [ "[a-z]+", function(matched) {
                this.setUTCMonth($DateUtil._parseMonthMap[matched]);
            } ],
            B: [ "[a-z]+", function(matched) {
                this.setUTCMonth($DateUtil._parseMonthMap[matched.slice(0, 3)]);
            } ],
            Y: [ "[0-9]{4}", function(matched) {
                this.setUTCFullYear(+matched);
            } ],
            m: [ "[0-9]{0,2}", function(matched) {
                this.setUTCMonth(+matched - 1);
            } ],
            d: [ "[0-9]{0,2}", function(matched) {
                this.utcDay = +matched;
            } ],
            H: [ "[0-9]{0,2}", function(matched) {
                this.setUTCHours(+matched);
            } ],
            M: [ "[0-9]{0,2}", function(matched) {
                this.setUTCMinutes(+matched);
            } ],
            S: [ "[0-9]{0,2}", function(matched) {
                this.setUTCSeconds(+matched);
            } ],
            s: [ "[0-9]+", function(matched) {
                this.setUTCMilliseconds(+matched);
            } ],
            z: [ "[+-][0-9]{4}", function(matched) {
                this.timezone = +matched.slice(0, 3) * (60 * 60) + +matched.slice(3, 5) * 60;
            } ],
            Z: [ "UTC|Z|[+-][0-9][0-9]:?[0-9][0-9]", function(matched) {
                if (matched === "Z") {
                    return;
                }
                if (matched === "UTC") {
                    return;
                }
                matched = matched.replace(/:/, "");
                this.timezone = +matched.slice(0, 3) * (60 * 60) + +matched.slice(3, 5) * 60;
            } ],
            I: [ "[0-9]{0,2}", function(matched) {
                this.setUTCHours(+matched);
            } ],
            p: [ "AM|PM", function(matched) {
                this.AMPM = matched;
            } ]
        },
        _parseMonthMap: {
            Jan: 0,
            Feb: 1,
            Mar: 2,
            Apr: 3,
            May: 4,
            Jun: 5,
            Jul: 6,
            Aug: 7,
            Sep: 8,
            Oct: 9,
            Nov: 10,
            Dec: 11
        },
        parseByFormat: function(dateStr, dateFormat) {
            if (!dateFormat) {
                return null;
            }
            var ff = [];
            var null_fd = false;
            var re = new RegExp(dateFormat.replace(/%(?:([a-zA-Z%])|('[^']+')|("[^"]+"))/g, function(_, a, b, c) {
                var fd = a || b || c;
                var d = $DateUtil._parseFormat[fd];
                if (!d) {
                    null_fd = true;
                } else {
                    ff.push(d[1]);
                    return "(" + d[0] + ")";
                }
            }), "i");
            if (null_fd === true) {
                return null;
            }
            var matched = dateStr.match(re);
            if (!matched) {
                return null;
            }
            var date = new Date(0);
            for (var i = 0, len = ff.length; i < len; i++) {
                var fun = ff[i];
                if (!fun) continue;
                fun.call(date, matched[i + 1]);
            }
            if (date.utcDay) {
                date.setUTCDate(date.utcDay);
            }
            if (date.timezone) {
                date = new Date(date.getTime() - date.timezone * 1e3);
            }
            if (date.AMPM) {
                if (date.getUTCHours() === 12) {
                    date.setUTCHours(date.getUTCHours() - 12);
                }
                if (date.AMPM === "PM") {
                    date.setUTCHours(date.getUTCHours() + 12);
                }
            }
            return date;
        }
    };
    $setSysDefault("COLOR_NAME_HEX_MAP", {
        AliceBlue: "f0f8ff",
        AntiqueWhite: "faebd7",
        Aqua: "00ffff",
        Aquamarine: "7fffd4",
        Azure: "f0ffff",
        Beige: "f5f5dc",
        Bisque: "ffe4c4",
        Black: "000000",
        BlanchedAlmond: "ffebcd",
        Blue: "0000ff",
        BlueViolet: "8a2be2",
        Brown: "a52a2a",
        BurlyWood: "deb887",
        CadetBlue: "5f9ea0",
        Chartreuse: "7fff00",
        Chocolate: "d2691e",
        Coral: "ff7f50",
        CornflowerBlue: "6495ed",
        Cornsilk: "fff8dc",
        Crimson: "dc143c",
        Cyan: "00ffff",
        DarkBlue: "00008b",
        DarkCyan: "008b8b",
        DarkGoldenRod: "b8860b",
        DarkGray: "a9a9a9",
        DarkGrey: "a9a9a9",
        DarkGreen: "006400",
        DarkKhaki: "bdb76b",
        DarkMagenta: "8b008b",
        DarkOliveGreen: "556b2f",
        DarkOrange: "ff8c00",
        DarkOrchid: "9932cc",
        DarkRed: "8b0000",
        DarkSalmon: "e9967a",
        DarkSeaGreen: "8fbc8f",
        DarkSlateBlue: "483d8b",
        DarkSlateGray: "2f4f4f",
        DarkSlateGrey: "2f4f4f",
        DarkTurquoise: "00ced1",
        DarkViolet: "9400d3",
        DeepPink: "ff1493",
        DeepSkyBlue: "00bfff",
        DimGray: "696969",
        DimGrey: "696969",
        DodgerBlue: "1e90ff",
        FireBrick: "b22222",
        FloralWhite: "fffaf0",
        ForestGreen: "228b22",
        Fuchsia: "ff00ff",
        Gainsboro: "dcdcdc",
        GhostWhite: "f8f8ff",
        Gold: "ffd700",
        GoldenRod: "daa520",
        Gray: "808080",
        Grey: "808080",
        Green: "008000",
        GreenYellow: "adff2f",
        HoneyDew: "f0fff0",
        HotPink: "ff69b4",
        IndianRed: "cd5c5c",
        Indigo: "4b0082",
        Ivory: "fffff0",
        Khaki: "f0e68c",
        Lavender: "e6e6fa",
        LavenderBlush: "fff0f5",
        LawnGreen: "7cfc00",
        LemonChiffon: "fffacd",
        LightBlue: "add8e6",
        LightCoral: "f08080",
        LightCyan: "e0ffff",
        LightGoldenRodYellow: "fafad2",
        LightGray: "d3d3d3",
        LightGrey: "d3d3d3",
        LightGreen: "90ee90",
        LightPink: "ffb6c1",
        LightSalmon: "ffa07a",
        LightSeaGreen: "20b2aa",
        LightSkyBlue: "87cefa",
        LightSlateGray: "778899",
        LightSlateGrey: "778899",
        LightSteelBlue: "b0c4de",
        LightYellow: "ffffe0",
        Lime: "00ff00",
        LimeGreen: "32cd32",
        Linen: "faf0e6",
        Magenta: "ff00ff",
        Maroon: "800000",
        MediumAquaMarine: "66cdaa",
        MediumBlue: "0000cd",
        MediumOrchid: "ba55d3",
        MediumPurple: "9370db",
        MediumSeaGreen: "3cb371",
        MediumSlateBlue: "7b68ee",
        MediumSpringGreen: "00fa9a",
        MediumTurquoise: "48d1cc",
        MediumVioletRed: "c71585",
        MidnightBlue: "191970",
        MintCream: "f5fffa",
        MistyRose: "ffe4e1",
        Moccasin: "ffe4b5",
        NavajoWhite: "ffdead",
        Navy: "000080",
        OldLace: "fdf5e6",
        Olive: "808000",
        OliveDrab: "6b8e23",
        Orange: "ffa500",
        OrangeRed: "ff4500",
        Orchid: "da70d6",
        PaleGoldenRod: "eee8aa",
        PaleGreen: "98fb98",
        PaleTurquoise: "afeeee",
        PaleVioletRed: "db7093",
        PapayaWhip: "ffefd5",
        PeachPuff: "ffdab9",
        Peru: "cd853f",
        Pink: "ffc0cb",
        Plum: "dda0dd",
        PowderBlue: "b0e0e6",
        Purple: "800080",
        RebeccaPurple: "663399",
        Red: "ff0000",
        RosyBrown: "bc8f8f",
        RoyalBlue: "4169e1",
        SaddleBrown: "8b4513",
        Salmon: "fa8072",
        SandyBrown: "f4a460",
        SeaGreen: "2e8b57",
        SeaShell: "fff5ee",
        Sienna: "a0522d",
        Silver: "c0c0c0",
        SkyBlue: "87ceeb",
        SlateBlue: "6a5acd",
        SlateGray: "708090",
        SlateGrey: "708090",
        Snow: "fffafa",
        SpringGreen: "00ff7f",
        SteelBlue: "4682b4",
        Tan: "d2b48c",
        Teal: "008080",
        Thistle: "d8bfd8",
        Tomato: "ff6347",
        Turquoise: "40e0d0",
        Violet: "ee82ee",
        Wheat: "f5deb3",
        White: "ffffff",
        WhiteSmoke: "f5f5f5",
        Yellow: "ffff00",
        YellowGreen: "9acd32"
    });
    $setSysDefault("COLOR_DEFAULTS", [ "#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc", "#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1" ]);
    var $ColorUtil = {
        defaults: function(index) {
            var defaults = $getDefault("COLOR_DEFAULTS");
            if (arguments.length > 0) {
                return defaults[index % defaults.length];
            }
            return defaults.slice();
        },
        random: function(toType, returnObj) {
            toType = (toType || "hex").toLowerCase();
            var colorMap = $getDefault("COLOR_NAME_HEX_MAP");
            var colorNames = $ObjectKeys(colorMap);
            if (toType === "name") {
                return colorNames[colorNames.length * $MathRandom() | 0];
            }
            var colorHexs = $getObjectValues(colorMap);
            var result = "#" + colorHexs[colorHexs.length * $MathRandom() | 0];
            if (toType === "hex") {
                return result;
            }
            var colorObj = $ColorUtil._getRGBByHex(result);
            if (toType === "rgba" || toType === "hsla") {
                colorObj.alpha = ($MathRandom() * 11 | 0) / 10;
            }
            return $ColorUtil.convert(colorObj, toType, returnObj);
        },
        toRGB: function(color, returnObj) {
            return $ColorUtil.convert(color, "rgb", returnObj);
        },
        toRGBA: function(color, returnObj) {
            return $ColorUtil.convert(color, "rgba", returnObj);
        },
        toHSL: function(color, returnObj) {
            return $ColorUtil.convert(color, "hsl", returnObj);
        },
        toHSLA: function(color, returnObj) {
            return $ColorUtil.convert(color, "hsla", returnObj);
        },
        toHex: function(color) {
            return $ColorUtil.convert(color, "hex");
        },
        toName: function(color) {
            return $ColorUtil.convert(color, "name");
        },
        convert: function(colorOrRGBColorObj, toType, returnObj) {
            toType = toType.toLowerCase();
            var rgbObj;
            if (colorOrRGBColorObj != null) {
                if ($isObject(colorOrRGBColorObj)) {
                    rgbObj = $ColorUtil._roundRGBObj(colorOrRGBColorObj);
                } else {
                    var colorType = $ColorUtil._getColorType(colorOrRGBColorObj);
                    rgbObj = $ColorUtil._getColorRGBObject(colorOrRGBColorObj, colorType);
                }
            }
            if (returnObj === true) {
                switch (toType) {
                    case "rgb":
                        return rgbObj;

                    case "rgba":
                        return rgbObj;

                    case "hsl":
                        return $ColorUtil._rgbObjToHSLAObj(rgbObj);

                    case "hsla":
                        return $ColorUtil._rgbObjToHSLAObj(rgbObj);
                }
            }
            if (rgbObj) {
                switch (toType) {
                    case "rgb":
                        return $ColorUtil._rgbObjToRGBStr(rgbObj);

                    case "rgba":
                        return $ColorUtil._rgbObjToRGBAStr(rgbObj);

                    case "hsl":
                        return $ColorUtil._rgbObjToHSLStr(rgbObj);

                    case "hsla":
                        return $ColorUtil._rgbObjToHSLAStr(rgbObj);

                    case "hex":
                        return $ColorUtil._rgbObjToHexStr(rgbObj);

                    case "name":
                        return $ColorUtil._rgbObjToNameStr(rgbObj);
                }
            }
            return "";
        },
        mix: function(color1, color2, weight, toType, returnObj) {
            if (weight == null) {
                weight = .5;
            }
            toType = (toType || "hex").toLowerCase();
            var rgba1 = $ColorUtil.toRGBA(color1, true);
            var rgba2 = $ColorUtil.toRGBA(color2, true);
            return $ColorUtil.convert({
                red: $MathUtil.range(rgba1.red + (rgba2.red - rgba1.red) * weight, 0, 255),
                green: $MathUtil.range(rgba1.green + (rgba2.green - rgba1.green) * weight, 0, 255),
                blue: $MathUtil.range(rgba1.blue + (rgba2.blue - rgba1.blue) * weight, 0, 255),
                alpha: $MathUtil.range(rgba1.alpha + (rgba2.alpha - rgba1.alpha) * weight, 0, 1)
            }, toType, returnObj);
        },
        lighten: function(color, amount, toType, returnObj) {
            if (amount == null) {
                amount = .1;
            }
            return $ColorUtil._adjustLightness(color, amount, toType, returnObj);
        },
        darken: function(color, amount, toType, returnObj) {
            if (amount == null) {
                amount = -.1;
            } else {
                amount *= -1;
            }
            return $ColorUtil._adjustLightness(color, amount, toType, returnObj);
        },
        _adjustLightness: function(color, amount, toType, returnObj) {
            return $ColorUtil._adjustHSL("lightness", color, amount, toType, returnObj);
        },
        saturate: function(color, amount, toType, returnObj) {
            if (amount == null) {
                amount = .1;
            }
            return $ColorUtil._adjustSaturation(color, amount, toType, returnObj);
        },
        desaturate: function(color, amount, toType, returnObj) {
            if (amount == null) {
                amount = -.1;
            } else {
                amount *= -1;
            }
            return $ColorUtil._adjustSaturation(color, amount, toType, returnObj);
        },
        _adjustSaturation: function(color, amount, toType, returnObj) {
            return $ColorUtil._adjustHSL("saturation", color, amount, toType, returnObj);
        },
        _adjustHSL: function(type, color, amount, toType, returnObj) {
            if (toType == null) {
                toType = $ColorUtil._getColorType(color);
                if (toType === "name") {
                    toType = "hsl";
                }
            }
            toType = toType.toLowerCase();
            var hslObj = $ColorUtil.toHSL(color, true);
            var rgbObj;
            if (hslObj) {
                if ($MathAbs(amount) < 1) {
                    amount *= 100;
                }
                var saturation = hslObj[type];
                hslObj[type] = $MathUtil.range(saturation + amount, 0, 100);
                rgbObj = $ColorUtil._hslToRGB(hslObj.hue, hslObj.saturation, hslObj.lightness);
                rgbObj.alpha = hslObj.alpha;
            }
            return $ColorUtil.convert(rgbObj, toType, returnObj);
        },
        _getColorType: function(color) {
            color = color.trim().toLowerCase();
            if (color.startsWith("#")) {
                return "hex";
            } else if (color.startsWith("rgba")) {
                return "rgba";
            } else if (color.startsWith("rgb")) {
                return "rgb";
            } else if (color.startsWith("hsla")) {
                return "hsla";
            } else if (color.startsWith("hsl")) {
                return "hsl";
            } else {
                if ($ColorUtil._getHexByName(color)) {
                    return "name";
                }
            }
            return "";
        },
        _roundRGBObj: function(rgbObj) {
            if (rgbObj) {
                return {
                    red: $MathRound(rgbObj.red),
                    green: $MathRound(rgbObj.green),
                    blue: $MathRound(rgbObj.blue),
                    alpha: rgbObj.alpha
                };
            }
            return rgbObj;
        },
        _rgbToHex: function(colorObj) {
            return ((1 << 24) + (colorObj.red << 16) + (colorObj.green << 8) + colorObj.blue).toString(16).slice(1);
        },
        _getNameByHex: function(hex) {
            hex = hex.toLowerCase();
            var name;
            $eachObject($getDefault("COLOR_NAME_HEX_MAP"), function(key, value) {
                if (value.toLowerCase() === hex) {
                    name = key;
                    return false;
                }
            });
            return name;
        },
        _getHexByName: function(name) {
            name = name.toLowerCase();
            var hex;
            $eachObject($getDefault("COLOR_NAME_HEX_MAP"), function(key, value) {
                if (key.toLowerCase() === name) {
                    hex = value;
                    return false;
                }
            });
            return hex;
        },
        _hslToRGB: function(hue, saturation, lightness) {
            saturation /= 100;
            lightness /= 100;
            var t1, t2, red, green, blue;
            hue = hue / 60;
            if (lightness <= .5) {
                t2 = lightness * (saturation + 1);
            } else {
                t2 = lightness + saturation - lightness * saturation;
            }
            t1 = lightness * 2 - t2;
            red = $ColorUtil._hueToRGB(t1, t2, hue + 2) * 255;
            green = $ColorUtil._hueToRGB(t1, t2, hue) * 255;
            blue = $ColorUtil._hueToRGB(t1, t2, hue - 2) * 255;
            return {
                red: red,
                green: green,
                blue: blue
            };
        },
        _hueToRGB: function(t1, t2, hue) {
            if (hue < 0) hue += 6;
            if (hue >= 6) hue -= 6;
            if (hue < 1) return (t2 - t1) * hue + t1; else if (hue < 3) return t2; else if (hue < 4) return (t2 - t1) * (4 - hue) + t1; else return t1;
        },
        _rgbToHSL: function(colorObj) {
            var rgb = [ colorObj.red / 255, colorObj.green / 255, colorObj.blue / 255 ];
            var min = rgb[0], max = rgb[0];
            var maxColor = 0;
            var l, s, h;
            for (var i = 0; i < 2; i++) {
                if (rgb[i + 1] <= min) {
                    min = rgb[i + 1];
                }
                if (rgb[i + 1] >= max) {
                    max = rgb[i + 1];
                    maxColor = i + 1;
                }
            }
            if (maxColor === 0) {
                h = (rgb[1] - rgb[2]) / (max - min);
            }
            if (maxColor === 1) {
                h = 2 + (rgb[2] - rgb[0]) / (max - min);
            }
            if (maxColor === 2) {
                h = 4 + (rgb[0] - rgb[1]) / (max - min);
            }
            if (isNaN(h)) {
                h = 0;
            }
            h = h * 60;
            if (h < 0) {
                h = h + 360;
            }
            l = (min + max) / 2;
            if (min === max) {
                s = 0;
            } else {
                if (l < .5) {
                    s = (max - min) / (max + min);
                } else {
                    s = (max - min) / (2 - max - min);
                }
            }
            return {
                hue: $MathRound(h),
                saturation: $MathRound(s * 100),
                lightness: $MathRound(l * 100)
            };
        },
        _rgbObjToHSLAObj: function(rgbOjb) {
            if (rgbOjb) {
                var alpha = rgbOjb.alpha;
                var obj = $ColorUtil._rgbToHSL(rgbOjb);
                obj.alpha = alpha;
                return obj;
            }
            return null;
        },
        _rgbObjToRGBStr: function(rgbObj) {
            if (rgbObj) {
                return "rgb(" + rgbObj.red + ", " + rgbObj.green + ", " + rgbObj.blue + ")";
            }
            return "";
        },
        _rgbObjToRGBAStr: function(rgbObj) {
            if (rgbObj) {
                return "rgba(" + rgbObj.red + ", " + rgbObj.green + ", " + rgbObj.blue + ", " + rgbObj.alpha + ")";
            }
            return "";
        },
        _rgbObjToHSLStr: function(rgbObj) {
            if (rgbObj) {
                var alpha = rgbObj.alpha;
                rgbObj = $ColorUtil._rgbToHSL(rgbObj);
                rgbObj.alpha = alpha;
                return "hsl(" + rgbObj.hue + ", " + rgbObj.saturation + "%, " + rgbObj.lightness + "%)";
            }
            return "";
        },
        _rgbObjToHSLAStr: function(rgbObj) {
            if (rgbObj) {
                var alpha = rgbObj.alpha;
                rgbObj = $ColorUtil._rgbToHSL(rgbObj);
                rgbObj.alpha = alpha;
                return "hsla(" + rgbObj.hue + ", " + rgbObj.saturation + "%, " + rgbObj.lightness + "%, " + rgbObj.alpha + ")";
            }
            return "";
        },
        _rgbObjToHexStr: function(rgbObj) {
            if (rgbObj) {
                return "#" + $ColorUtil._rgbToHex(rgbObj);
            }
            return "";
        },
        _rgbObjToNameStr: function(rgbObj) {
            if (rgbObj) {
                var hex = $ColorUtil._rgbToHex(rgbObj);
                return $ColorUtil._getNameByHex(hex) || "";
            }
            return "";
        },
        _getColorRGBObject: function(color, colorType) {
            if (!colorType) {
                return null;
            }
            color = color.trim().toLowerCase();
            var obj;
            switch (colorType) {
                case "hex":
                    obj = $ColorUtil._getRGBByHex(color);
                    break;

                case "rgba":
                    obj = $ColorUtil._getRGBObjByRGBA(color);
                    break;

                case "rgb":
                    obj = $ColorUtil._getRGBObjByRGB(color);
                    break;

                case "hsla":
                    obj = $ColorUtil._getRGBObjByHSLA(color);
                    break;

                case "hsl":
                    obj = $ColorUtil._getRGBObjByHSL(color);
                    break;

                case "name":
                    obj = $ColorUtil._getRGBObjByName(color);
                    break;
            }
            obj = $ColorUtil._roundRGBObj(obj);
            return obj;
        },
        _getColorArgs: function(color) {
            var result = [];
            var args = color.match(/\((.*?)\)/g);
            if (args) {
                args = args[0];
                if (args.length > 2) {
                    args = args.substring(1, args.length - 1);
                    args.split(",").forEach(function(item) {
                        item = item.trim();
                        if (item.indexOf("%") > -1) {
                            item = item.replace("%", "");
                        }
                        result.push(parseFloat(item));
                    });
                }
            }
            return result;
        },
        _getRGBObjByHSL: function(color) {
            var args = $ColorUtil._getColorArgs(color);
            if (args.length > 2) {
                var rgb = $ColorUtil._hslToRGB(args[0], args[1], args[2]);
                return {
                    red: rgb.red,
                    green: rgb.green,
                    blue: rgb.blue,
                    alpha: 1
                };
            }
            return null;
        },
        _getRGBObjByHSLA: function(color) {
            var args = $ColorUtil._getColorArgs(color);
            if (args.length > 3) {
                var rgb = $ColorUtil._hslToRGB(args[0], args[1], args[2]);
                return {
                    red: rgb.red,
                    green: rgb.green,
                    blue: rgb.blue,
                    alpha: parseFloat(args[3])
                };
            }
            return null;
        },
        _getRGBObjByRGB: function(color) {
            var args = $ColorUtil._getColorArgs(color);
            if (args.length > 2) {
                return {
                    red: args[0],
                    green: args[1],
                    blue: args[2],
                    alpha: 1
                };
            }
            return null;
        },
        _getRGBObjByRGBA: function(color) {
            var args = $ColorUtil._getColorArgs(color);
            if (args.length > 3) {
                return {
                    red: args[0],
                    green: args[1],
                    blue: args[2],
                    alpha: args[3]
                };
            }
            return null;
        },
        _getRGBObjByName: function(color) {
            var hex = $ColorUtil._getHexByName(color);
            if (hex) {
                return $ColorUtil._getRGBByHex(hex);
            }
            return null;
        },
        _getRGBByHex: function(color) {
            color = color.replace("#", "");
            var alpha = 1;
            if (color.length === 3 || color.length === 4) {
                color = color.replace(/(.)/g, "$1$1");
            }
            if (color.length === 8) {
                alpha = parseFloat((parseInt(color.substr(6, 2), 16) / 255).toFixed(2));
                color = color.substr(0, 6);
            }
            if (color.length === 6) {
                return {
                    red: parseInt(color.substr(0, 2), 16),
                    green: parseInt(color.substr(2, 2), 16),
                    blue: parseInt(color.substr(4, 2), 16),
                    alpha: alpha
                };
            }
            return null;
        }
    };
    var $PathUtil = {
        isMoveTo: function(type) {
            return type === "move_to" || type === "mt" || type === "moveTo";
        },
        isLineTo: function(type) {
            return type === "line_to" || type === "lt" || type === "lineTo";
        },
        isQuadraticCurveTo: function(type) {
            return type === "quadratic_curve_to" || type === "qct" || type === "qt" || type === "quadraticCurveTo";
        },
        isBezierCurveTo: function(type) {
            return type === "bezier_curve_to" || type === "bct" || type === "ct" || type === "bezierCurveTo";
        },
        isBezier: function(type) {
            return $PathUtil.isQuadraticCurveTo(type) || $PathUtil.isBezierCurveTo(type);
        },
        isClose: function(type) {
            return type === "close";
        }
    };
    var $Util = {
        __uid: 0,
        guid: function() {
            return "_z-i-" + $Util.__uid++;
        },
        logError: function(error) {
            console.error(error);
        },
        throwError: function(error) {
            throw new Error(error);
        },
        exec: function(expr, vars, varRegExp) {
            varRegExp = varRegExp || /([\[{])(.+?)([\]}])/;
            varRegExp = new RegExp(varRegExp, "g");
            var _code = expr.replace(varRegExp, function(word) {
                var d_model = word.substr(1, word.length - 2);
                var v = $getObjectDeepValue(vars, d_model);
                if ($isString(v) && (!v.startsWith("'") && !v.startsWith('"'))) {
                    v = "'" + v + "'";
                }
                if (v != null) {
                    return v;
                }
                return v || "''";
            });
            return new Function("return " + _code).apply({}, []);
        }
    };
    var $180 = 180;
    var $360 = 360;
    var $Bezier = function(coords) {
        var args = coords && coords.forEach ? coords : [].slice.call(arguments);
        var coordlen = false;
        if (typeof args[0] === "object") {
            coordlen = args.length;
            var newargs = [];
            args.forEach(function(point) {
                [ "x", "y", "z" ].forEach(function(d) {
                    if (typeof point[d] !== "undefined") {
                        newargs.push(point[d]);
                    }
                });
            });
            args = newargs;
        }
        var higher = false;
        var len = args.length;
        if (coordlen) {
            if (coordlen > 4) {
                if (arguments.length !== 1) {
                    throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
                }
                higher = true;
            }
        } else {
            if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
                if (arguments.length !== 1) {
                    throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
                }
            }
        }
        var _3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
        this._3d = _3d;
        var points = [];
        for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
            var point = {
                x: args[idx],
                y: args[idx + 1]
            };
            if (_3d) {
                point.z = args[idx + 2];
            }
            points.push(point);
        }
        this.order = points.length - 1;
        this.points = points;
        var dims = [ "x", "y" ];
        if (_3d) dims.push("z");
        this.dims = dims;
        this.dimlen = dims.length;
        (function(curve) {
            var order = curve.order;
            var points = curve.points;
            var a = $BezierUtil.align(points, {
                p1: points[0],
                p2: points[order]
            });
            for (var i = 0; i < a.length; i++) {
                if ($BezierUtil.abs(a[i].y) > 1e-4) {
                    curve._linear = false;
                    return;
                }
            }
            curve._linear = true;
        })(this);
        this._t1 = 0;
        this._t2 = 1;
        this.update();
    };
    $Bezier.prototype = {
        update: function() {
            this.dpoints = [];
            for (var p = this.points, d = p.length, c = d - 1; d > 1; d--, c--) {
                var list = [];
                for (var j = 0, dpt; j < c; j++) {
                    dpt = {
                        x: c * (p[j + 1].x - p[j].x),
                        y: c * (p[j + 1].y - p[j].y)
                    };
                    if (this._3d) {
                        dpt.z = c * (p[j + 1].z - p[j].z);
                    }
                    list.push(dpt);
                }
                this.dpoints.push(list);
                p = list;
            }
            this.computedirection();
        },
        computedirection: function() {
            var points = this.points;
            var angle = $BezierUtil.angle(points[0], points[this.order], points[1]);
            this.clockwise = angle > 0;
        },
        length: function() {
            return $BezierUtil.length(this.derivative.bind(this));
        },
        _lut: [],
        getLUT: function(steps) {
            steps = steps || 100;
            if (this._lut.length === steps) {
                return this._lut;
            }
            this._lut = [];
            for (var t = 0; t <= steps; t++) {
                this._lut.push(this.compute(t / steps));
            }
            return this._lut;
        },
        project: function(point) {
            var LUT = this.getLUT(), l = LUT.length - 1, closest = $BezierUtil.closest(LUT, point), mdist = closest.mdist, mpos = closest.mpos;
            if (mpos === 0 || mpos === l) {
                var t = mpos / l, pt = this.compute(t);
                pt.t = t;
                pt.d = mdist;
                return pt;
            }
            var ft, t, p, d, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = .1 / l;
            mdist += 1;
            for (t = t1, ft = t; t < t2 + step; t += step) {
                p = this.compute(t);
                d = $BezierUtil.dist(point, p);
                if (d < mdist) {
                    mdist = d;
                    ft = t;
                }
            }
            p = this.compute(ft);
            p.t = ft;
            p.d = mdist;
            return p;
        },
        get: function(t) {
            return this.compute(t);
        },
        compute: function(t) {
            if (t === 0) {
                return this.points[0];
            }
            if (t === 1) {
                return this.points[this.order];
            }
            var p = this.points;
            var mt = 1 - t;
            if (this.order === 1) {
                ret = {
                    x: mt * p[0].x + t * p[1].x,
                    y: mt * p[0].y + t * p[1].y
                };
                if (this._3d) {
                    ret.z = mt * p[0].z + t * p[1].z;
                }
                return ret;
            }
            if (this.order < 4) {
                var mt2 = mt * mt, t2 = t * t, a, b, c, d = 0;
                if (this.order === 2) {
                    p = [ p[0], p[1], p[2], $BezierUtil.ZERO ];
                    a = mt2;
                    b = mt * t * 2;
                    c = t2;
                } else if (this.order === 3) {
                    a = mt2 * mt;
                    b = mt2 * t * 3;
                    c = mt * t2 * 3;
                    d = t * t2;
                }
                var ret = {
                    x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,
                    y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y
                };
                if (this._3d) {
                    ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;
                }
                return ret;
            }
            var dCpts = JSON.parse(JSON.stringify(this.points));
            while (dCpts.length > 1) {
                for (var i = 0; i < dCpts.length - 1; i++) {
                    dCpts[i] = {
                        x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,
                        y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t
                    };
                    if (typeof dCpts[i].z !== "undefined") {
                        dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;
                    }
                }
                dCpts.splice(dCpts.length - 1, 1);
            }
            return dCpts[0];
        },
        raise: function() {
            var p = this.points, np = [ p[0] ], i, k = p.length, pi, pim;
            for (i = 1; i < k; i++) {
                pi = p[i];
                pim = p[i - 1];
                np[i] = {
                    x: (k - i) / k * pi.x + i / k * pim.x,
                    y: (k - i) / k * pi.y + i / k * pim.y
                };
            }
            np[k] = p[k - 1];
            return new $Bezier(np);
        },
        derivative: function(t) {
            var mt = 1 - t, a, b, c = 0, p = this.dpoints[0];
            if (this.order === 2) {
                p = [ p[0], p[1], $BezierUtil.ZERO ];
                a = mt;
                b = t;
            }
            if (this.order === 3) {
                a = mt * mt;
                b = mt * t * 2;
                c = t * t;
            }
            var ret = {
                x: a * p[0].x + b * p[1].x + c * p[2].x,
                y: a * p[0].y + b * p[1].y + c * p[2].y
            };
            if (this._3d) {
                ret.z = a * p[0].z + b * p[1].z + c * p[2].z;
            }
            return ret;
        },
        normal: function(t) {
            return this._3d ? this.__normal3(t) : this.__normal2(t);
        },
        __normal2: function(t) {
            var d = this.derivative(t);
            var q = $BezierUtil.sqrt(d.x * d.x + d.y * d.y);
            return {
                x: -d.y / q,
                y: d.x / q
            };
        },
        __normal3: function(t) {
            var r1 = this.derivative(t), r2 = this.derivative(t + .01), q1 = $BezierUtil.sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = $BezierUtil.sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
            r1.x /= q1;
            r1.y /= q1;
            r1.z /= q1;
            r2.x /= q2;
            r2.y /= q2;
            r2.z /= q2;
            var c = {
                x: r2.y * r1.z - r2.z * r1.y,
                y: r2.z * r1.x - r2.x * r1.z,
                z: r2.x * r1.y - r2.y * r1.x
            };
            var m = $BezierUtil.sqrt(c.x * c.x + c.y * c.y + c.z * c.z);
            c.x /= m;
            c.y /= m;
            c.z /= m;
            var R = [ c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z ];
            return {
                x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
                y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
                z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
            };
        },
        hull: function(t) {
            var p = this.points, _p = [], pt, q = [], idx = 0, i = 0, l = 0;
            q[idx++] = p[0];
            q[idx++] = p[1];
            q[idx++] = p[2];
            if (this.order === 3) {
                q[idx++] = p[3];
            }
            while (p.length > 1) {
                _p = [];
                for (i = 0, l = p.length - 1; i < l; i++) {
                    pt = $BezierUtil.lerp(t, p[i], p[i + 1]);
                    q[idx++] = pt;
                    _p.push(pt);
                }
                p = _p;
            }
            return q;
        },
        split: function(t1, t2) {
            if (t1 === 0 && !!t2) {
                return this.split(t2).left;
            }
            if (t2 === 1) {
                return this.split(t1).right;
            }
            var q = this.hull(t1);
            var result = {
                left: this.order === 2 ? new $Bezier([ q[0], q[3], q[5] ]) : new $Bezier([ q[0], q[4], q[7], q[9] ]),
                right: this.order === 2 ? new $Bezier([ q[5], q[4], q[2] ]) : new $Bezier([ q[9], q[8], q[6], q[3] ]),
                span: q
            };
            result.left._t1 = $BezierUtil.map(0, 0, 1, this._t1, this._t2);
            result.left._t2 = $BezierUtil.map(t1, 0, 1, this._t1, this._t2);
            result.right._t1 = $BezierUtil.map(t1, 0, 1, this._t1, this._t2);
            result.right._t2 = $BezierUtil.map(1, 0, 1, this._t1, this._t2);
            if (!t2) {
                return result;
            }
            t2 = $BezierUtil.map(t2, t1, 1, 0, 1);
            var subsplit = result.right.split(t2);
            return subsplit.left;
        },
        extrema: function() {
            var dims = this.dims, result = {}, roots = [], p, mfn;
            dims.forEach(function(dim) {
                mfn = function(v) {
                    return v[dim];
                };
                p = this.dpoints[0].map(mfn);
                result[dim] = $BezierUtil.droots(p);
                if (this.order === 3) {
                    p = this.dpoints[1].map(mfn);
                    result[dim] = result[dim].concat($BezierUtil.droots(p));
                }
                result[dim] = result[dim].filter(function(t) {
                    return t >= 0 && t <= 1;
                });
                roots = roots.concat(result[dim].sort());
            }.bind(this));
            roots = roots.sort().filter(function(v, idx) {
                return roots.indexOf(v) === idx;
            });
            result.values = roots;
            return result;
        },
        bbox: function() {
            var extrema = this.extrema(), result = {};
            this.dims.forEach(function(d) {
                result[d] = $BezierUtil.getminmax(this, d, extrema[d]);
            }.bind(this));
            return result;
        },
        overlaps: function(curve) {
            var lbbox = this.bbox(), tbbox = curve.bbox();
            return $BezierUtil.bboxoverlap(lbbox, tbbox);
        },
        offset: function(t, d) {
            if (typeof d !== "undefined") {
                var c = this.get(t);
                var n = this.normal(t);
                var ret = {
                    c: c,
                    n: n,
                    x: c.x + n.x * d,
                    y: c.y + n.y * d
                };
                if (this._3d) {
                    ret.z = c.z + n.z * d;
                }
                return ret;
            }
            if (this._linear) {
                var nv = this.normal(0);
                var coords = this.points.map(function(p) {
                    var ret = {
                        x: p.x + t * nv.x,
                        y: p.y + t * nv.y
                    };
                    if (p.z && n.z) {
                        ret.z = p.z + t * nv.z;
                    }
                    return ret;
                });
                return [ new $Bezier(coords) ];
            }
            var reduced = this.reduce();
            return reduced.map(function(s) {
                return s.scale(t);
            });
        },
        simple: function() {
            if (this.order === 3) {
                var a1 = $BezierUtil.angle(this.points[0], this.points[3], this.points[1]);
                var a2 = $BezierUtil.angle(this.points[0], this.points[3], this.points[2]);
                if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
            }
            var n1 = this.normal(0);
            var n2 = this.normal(1);
            var s = n1.x * n2.x + n1.y * n2.y;
            if (this._3d) {
                s += n1.z * n2.z;
            }
            var angle = $BezierUtil.abs($BezierUtil.acos(s));
            return angle < $BezierUtil.pi / 3;
        },
        reduce: function() {
            var i, t1 = 0, t2 = 0, step = .01, segment, pass1 = [], pass2 = [];
            var extrema = this.extrema().values;
            if (extrema.indexOf(0) === -1) {
                extrema = [ 0 ].concat(extrema);
            }
            if (extrema.indexOf(1) === -1) {
                extrema.push(1);
            }
            for (t1 = extrema[0], i = 1; i < extrema.length; i++) {
                t2 = extrema[i];
                segment = this.split(t1, t2);
                segment._t1 = t1;
                segment._t2 = t2;
                pass1.push(segment);
                t1 = t2;
            }
            pass1.forEach(function(p1) {
                t1 = 0;
                t2 = 0;
                while (t2 <= 1) {
                    for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
                        segment = p1.split(t1, t2);
                        if (!segment.simple()) {
                            t2 -= step;
                            if ($BezierUtil.abs(t1 - t2) < step) {
                                return [];
                            }
                            segment = p1.split(t1, t2);
                            segment._t1 = $BezierUtil.map(t1, 0, 1, p1._t1, p1._t2);
                            segment._t2 = $BezierUtil.map(t2, 0, 1, p1._t1, p1._t2);
                            pass2.push(segment);
                            t1 = t2;
                            break;
                        }
                    }
                }
                if (t1 < 1) {
                    segment = p1.split(t1, 1);
                    segment._t1 = $BezierUtil.map(t1, 0, 1, p1._t1, p1._t2);
                    segment._t2 = p1._t2;
                    pass2.push(segment);
                }
            });
            return pass2;
        },
        scale: function(d) {
            var order = this.order;
            var distanceFn = false;
            if (typeof d === "function") {
                distanceFn = d;
            }
            if (distanceFn && order === 2) {
                return this.raise().scale(distanceFn);
            }
            var clockwise = this.clockwise;
            var r1 = distanceFn ? distanceFn(0) : d;
            var r2 = distanceFn ? distanceFn(1) : d;
            var v = [ this.offset(0, 10), this.offset(1, 10) ];
            var o = $BezierUtil.lli4(v[0], v[0].c, v[1], v[1].c);
            if (!o) {
                throw new Error("cannot scale this curve. Try reducing it first.");
            }
            var points = this.points, np = [];
            [ 0, 1 ].forEach(function(t) {
                var p = np[t * order] = $BezierUtil.copy(points[t * order]);
                p.x += (t ? r2 : r1) * v[t].n.x;
                p.y += (t ? r2 : r1) * v[t].n.y;
            }.bind(this));
            if (!distanceFn) {
                [ 0, 1 ].forEach(function(t) {
                    if (this.order === 2 && !!t) return;
                    var p = np[t * order];
                    var d = this.derivative(t);
                    var p2 = {
                        x: p.x + d.x,
                        y: p.y + d.y
                    };
                    np[t + 1] = $BezierUtil.lli4(p, p2, o, points[t + 1]);
                }.bind(this));
                return new $Bezier(np);
            }
            [ 0, 1 ].forEach(function(t) {
                if (this.order === 2 && !!t) return;
                var p = points[t + 1];
                var ov = {
                    x: p.x - o.x,
                    y: p.y - o.y
                };
                var rc = distanceFn ? distanceFn((t + 1) / order) : d;
                if (distanceFn && !clockwise) rc = -rc;
                var m = $BezierUtil.sqrt(ov.x * ov.x + ov.y * ov.y);
                ov.x /= m;
                ov.y /= m;
                np[t + 1] = {
                    x: p.x + rc * ov.x,
                    y: p.y + rc * ov.y
                };
            }.bind(this));
            return new $Bezier(np);
        },
        intersects: function(curve, curveIntersectionThreshold) {
            if (!curve) return this.selfintersects(curveIntersectionThreshold);
            if (curve.p1 && curve.p2) {
                return this.lineIntersects(curve);
            }
            if (curve instanceof $Bezier) {
                curve = curve.reduce();
            }
            return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
        },
        lineIntersects: function(line) {
            var mx = $BezierUtil.min(line.p1.x, line.p2.x), my = $BezierUtil.min(line.p1.y, line.p2.y), MX = $BezierUtil.max(line.p1.x, line.p2.x), MY = $BezierUtil.max(line.p1.y, line.p2.y), self = this;
            return $BezierUtil.roots(this.points, line).filter(function(t) {
                var p = self.get(t);
                return $BezierUtil.between(p.x, mx, MX) && $BezierUtil.between(p.y, my, MY);
            });
        },
        selfintersects: function(curveIntersectionThreshold) {
            var reduced = this.reduce();
            var i, len = reduced.length - 2, results = [], result, left, right;
            for (i = 0; i < len; i++) {
                left = reduced.slice(i, i + 1);
                right = reduced.slice(i + 2);
                result = this.curveintersects(left, right, curveIntersectionThreshold);
                results = results.concat(result);
            }
            return results;
        },
        curveintersects: function(c1, c2, curveIntersectionThreshold) {
            var pairs = [];
            c1.forEach(function(l) {
                c2.forEach(function(r) {
                    if (l.overlaps(r)) {
                        pairs.push({
                            left: l,
                            right: r
                        });
                    }
                });
            });
            var intersections = [];
            pairs.forEach(function(pair) {
                var result = $BezierUtil.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
                if (result.length > 0) {
                    intersections = intersections.concat(result);
                }
            });
            return intersections;
        }
    };
    var $BezierUtil = {
        abs: Math.abs,
        cos: Math.cos,
        sin: Math.sin,
        acos: Math.acos,
        atan2: Math.atan2,
        sqrt: Math.sqrt,
        pow: Math.pow,
        crt: function(v) {
            return v < 0 ? -$BezierUtil.pow(-v, 1 / 3) : $BezierUtil.pow(v, 1 / 3);
        },
        pi: Math.PI,
        tau: 2 * Math.PI,
        quart: Math.PI / 2,
        epsilon: 1e-6,
        nMax: 9007199254740991,
        nMin: -9007199254740991,
        min: Math.min,
        max: Math.max,
        ZERO: {
            x: 0,
            y: 0,
            z: 0
        },
        Tvalues: [ -.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213 ],
        Cvalues: [ .12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872 ],
        arcfn: function(t, derivativeFn) {
            var d = derivativeFn(t);
            var l = d.x * d.x + d.y * d.y;
            if (typeof d.z !== "undefined") {
                l += d.z * d.z;
            }
            return $BezierUtil.sqrt(l);
        },
        between: function(v, m, M) {
            return m <= v && v <= M || $BezierUtil.approximately(v, m) || $BezierUtil.approximately(v, M);
        },
        approximately: function(a, b, precision) {
            return $BezierUtil.abs(a - b) <= (precision || $BezierUtil.epsilon);
        },
        length: function(derivativeFn) {
            var z = .5, sum = 0, len = $BezierUtil.Tvalues.length, i, t;
            for (i = 0; i < len; i++) {
                t = z * $BezierUtil.Tvalues[i] + z;
                sum += $BezierUtil.Cvalues[i] * $BezierUtil.arcfn(t, derivativeFn);
            }
            return z * sum;
        },
        map: function(v, ds, de, ts, te) {
            var d1 = de - ds, d2 = te - ts, v2 = v - ds, r = v2 / d1;
            return ts + d2 * r;
        },
        lerp: function(r, v1, v2) {
            var ret = {
                x: v1.x + r * (v2.x - v1.x),
                y: v1.y + r * (v2.y - v1.y)
            };
            if (!!v1.z && !!v2.z) {
                ret.z = v1.z + r * (v2.z - v1.z);
            }
            return ret;
        },
        copy: function(obj) {
            return JSON.parse(JSON.stringify(obj));
        },
        angle: function(o, v1, v2) {
            var dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, m1 = $BezierUtil.sqrt(dx1 * dx1 + dy1 * dy1), m2 = $BezierUtil.sqrt(dx2 * dx2 + dy2 * dy2), dot;
            dx1 /= m1;
            dy1 /= m1;
            dx2 /= m2;
            dy2 /= m2;
            dot = dx1 * dx2 + dy1 * dy2;
            return $BezierUtil.atan2(cross, dot);
        },
        dist: function(p1, p2) {
            var dx = p1.x - p2.x, dy = p1.y - p2.y;
            return $BezierUtil.sqrt(dx * dx + dy * dy);
        },
        closest: function(LUT, point) {
            var mdist = $BezierUtil.pow(2, 63), mpos, d;
            LUT.forEach(function(p, idx) {
                d = $BezierUtil.dist(point, p);
                if (d < mdist) {
                    mdist = d;
                    mpos = idx;
                }
            });
            return {
                mdist: mdist,
                mpos: mpos
            };
        },
        lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
            var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (d === 0) {
                return false;
            }
            return {
                x: nx / d,
                y: ny / d
            };
        },
        lli4: function(p1, p2, p3, p4) {
            var x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
            return $BezierUtil.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
        },
        lli: function(v1, v2) {
            return $BezierUtil.lli4(v1, v1.c, v2, v2.c);
        },
        getminmax: function(curve, d, list) {
            if (!list) return {
                min: 0,
                max: 0
            };
            var min = $BezierUtil.nMax, max = $BezierUtil.nMin, t, c;
            if (list.indexOf(0) === -1) {
                list = [ 0 ].concat(list);
            }
            if (list.indexOf(1) === -1) {
                list.push(1);
            }
            for (var i = 0, len = list.length; i < len; i++) {
                t = list[i];
                c = curve.get(t);
                if (c[d] < min) {
                    min = c[d];
                }
                if (c[d] > max) {
                    max = c[d];
                }
            }
            return {
                min: min,
                mid: (min + max) / 2,
                max: max,
                size: max - min
            };
        },
        align: function(points, line) {
            var tx = line.p1.x, ty = line.p1.y, a = -$BezierUtil.atan2(line.p2.y - ty, line.p2.x - tx), d = function(v) {
                return {
                    x: (v.x - tx) * $BezierUtil.cos(a) - (v.y - ty) * $BezierUtil.sin(a),
                    y: (v.x - tx) * $BezierUtil.sin(a) + (v.y - ty) * $BezierUtil.cos(a)
                };
            };
            return points.map(d);
        },
        roots: function(points, line) {
            line = line || {
                p1: {
                    x: 0,
                    y: 0
                },
                p2: {
                    x: 1,
                    y: 0
                }
            };
            var order = points.length - 1;
            var p = $BezierUtil.align(points, line);
            var reduce = function(t) {
                return 0 <= t && t <= 1;
            };
            if (order === 2) {
                var a = p[0].y, b = p[1].y, c = p[2].y, d = a - 2 * b + c;
                if (d !== 0) {
                    var m1 = -$BezierUtil.sqrt(b * b - a * c), m2 = -a + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
                    return [ v1, v2 ].filter(reduce);
                } else if (b !== c && d === 0) {
                    return [ (2 * b - c) / 2 * (b - c) ].filter(reduce);
                }
                return [];
            }
            var pa = p[0].y, pb = p[1].y, pc = p[2].y, pd = p[3].y, d = -pa + 3 * pb - 3 * pc + pd, a = (3 * pa - 6 * pb + 3 * pc) / d, b = (-3 * pa + 3 * pb) / d, c = pa / d, p = (3 * b - a * a) / 3, p3 = p / 3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
            if (discriminant < 0) {
                var mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r = $BezierUtil.sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = $BezierUtil.acos(cosphi), crtr = $BezierUtil.crt(r), t1 = 2 * crtr;
                x1 = t1 * $BezierUtil.cos(phi / 3) - a / 3;
                x2 = t1 * $BezierUtil.cos((phi + $BezierUtil.tau) / 3) - a / 3;
                x3 = t1 * $BezierUtil.cos((phi + 2 * $BezierUtil.tau) / 3) - a / 3;
                return [ x1, x2, x3 ].filter(reduce);
            } else if (discriminant === 0) {
                u1 = q2 < 0 ? $BezierUtil.crt(-q2) : -$BezierUtil.crt(q2);
                x1 = 2 * u1 - a / 3;
                x2 = -u1 - a / 3;
                return [ x1, x2 ].filter(reduce);
            } else {
                var sd = $BezierUtil.sqrt(discriminant);
                u1 = $BezierUtil.crt(-q2 + sd);
                v1 = $BezierUtil.crt(q2 + sd);
                return [ u1 - v1 - a / 3 ].filter(reduce);
            }
        },
        droots: function(p) {
            if (p.length === 3) {
                var a = p[0], b = p[1], c = p[2], d = a - 2 * b + c;
                if (d !== 0) {
                    var m1 = -$BezierUtil.sqrt(b * b - a * c), m2 = -a + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;
                    return [ v1, v2 ];
                } else if (b !== c && d === 0) {
                    return [ (2 * b - c) / (2 * (b - c)) ];
                }
                return [];
            }
            if (p.length === 2) {
                var a = p[0], b = p[1];
                if (a !== b) {
                    return [ a / (a - b) ];
                }
                return [];
            }
        },
        bboxoverlap: function(b1, b2) {
            var dims = [ "x", "y" ], len = dims.length, i, dim, l, t, d;
            for (i = 0; i < len; i++) {
                dim = dims[i];
                l = b1[dim].mid;
                t = b2[dim].mid;
                d = (b1[dim].size + b2[dim].size) / 2;
                if ($BezierUtil.abs(l - t) >= d) return false;
            }
            return true;
        },
        pairiteration: function(c1, c2, curveIntersectionThreshold) {
            var c1b = c1.bbox(), c2b = c2.bbox(), r = 1e5, threshold = curveIntersectionThreshold || .5;
            if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {
                return [ (r * (c1._t1 + c1._t2) / 2 | 0) / r + "/" + (r * (c2._t1 + c2._t2) / 2 | 0) / r ];
            }
            var cc1 = c1.split(.5), cc2 = c2.split(.5), pairs = [ {
                left: cc1.left,
                right: cc2.left
            }, {
                left: cc1.left,
                right: cc2.right
            }, {
                left: cc1.right,
                right: cc2.right
            }, {
                left: cc1.right,
                right: cc2.left
            } ];
            pairs = pairs.filter(function(pair) {
                return $BezierUtil.bboxoverlap(pair.left.bbox(), pair.right.bbox());
            });
            var results = [];
            if (pairs.length === 0) return results;
            pairs.forEach(function(pair) {
                results = results.concat($BezierUtil.pairiteration(pair.left, pair.right, threshold));
            });
            results = results.filter(function(v, i) {
                return results.indexOf(v) === i;
            });
            return results;
        },
        __createBezier: function(points) {
            var p0 = points[0], p1 = points[1], p2 = points[2];
            var aLen = points.length;
            if (aLen === 3) {
                return new $Bezier(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);
            } else if (aLen === 4) {
                var p3 = points[3];
                return new $Bezier(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            }
        },
        getLength: function(points) {
            var curve = $BezierUtil.__createBezier.apply($BezierUtil, [ points ]);
            return curve.length();
        },
        getBounds: function(points) {
            var curve = $BezierUtil.__createBezier.apply($BezierUtil, [ points ]);
            var bbox = curve.bbox();
            return {
                x: bbox.x.min,
                y: bbox.y.min,
                width: bbox.x.size,
                height: bbox.y.size
            };
        },
        getClosestPointOnBezier: function(bezierPoints, point) {
            var curve = $BezierUtil.__createBezier.apply($BezierUtil, [ bezierPoints ]);
            return curve.project(point);
        },
        getLUT: function(points, steps) {
            var curve = $BezierUtil.__createBezier.apply($BezierUtil, [ points ]);
            return curve.getLUT(steps);
        }
    };
    var $MathUtil = {
        range: function(value, min, max) {
            return $MathMax($MathMin(min, max), $MathMin($MathMax(min, max), value));
        },
        toDegrees: function(angrad) {
            return angrad * $180 / $MathPI;
        },
        toRadians: function(angdeg) {
            return angdeg / $180 * $MathPI;
        },
        to360Degrees: function(angDeg) {
            return (angDeg % $360 + $360) % $360;
        },
        calcDistance: function(p1, p2) {
            var distX = p2.x - p1.x;
            var distY = p2.y - p1.y;
            return $MathSqrt(distX * distX + distY * distY);
        },
        calcAngle: function(p1, p2) {
            return $MathUtil.to360Degrees($MathUtil.toDegrees($MathAtan2(p2.y - p1.y, p2.x - p1.x)));
        },
        isAngleInRange: function(start, end, angle) {
            start = $MathUtil.to360Degrees(start);
            end = $MathUtil.to360Degrees(end);
            angle = $MathUtil.to360Degrees(angle);
            if (end < start) {
                end += $360;
            }
            if (angle <= end && angle >= start) {
                return true;
            }
            if (end > $360) {
                angle += $360;
                if (angle >= start && angle <= end) {
                    return true;
                }
            }
            return false;
        },
        getArgsPoint: function(point) {
            var argLen = arguments.length;
            if (argLen === 1) {
                if ($isArray(point)) {
                    return {
                        x: point[1],
                        y: point[2]
                    };
                }
                return point;
            }
            if (argLen > 1) {
                return {
                    x: arguments[0],
                    y: arguments[1]
                };
            }
            return null;
        },
        getArgsSize: function(size) {
            var argLen = arguments.length;
            if (argLen === 1) {
                if ($isArray(size)) {
                    return {
                        width: size[1],
                        height: size[2]
                    };
                }
                return size;
            }
            if (argLen > 1) {
                return {
                    width: arguments[0],
                    height: arguments[1]
                };
            }
            return null;
        }
    };
    var $mathToRadians = $MathUtil.toRadians, $mathCalcDistance = $MathUtil.calcDistance, $mathCalcAngle = $MathUtil.calcAngle, $mathTo360Degrees = $MathUtil.to360Degrees;
    var $MathConvexHullUtil = {
        cross: function(p1, p2, p3) {
            return (p1.x - p3.x) * (p2.y - p3.y) - (p1.y - p3.y) * (p2.x - p3.x);
        },
        convexHull: function(points) {
            points = points.slice();
            points.sort(function(p1, p2) {
                return p1.x === p2.x ? p1.y - p2.y : p1.x - p2.x;
            });
            var len = points.length, i;
            var lower = [];
            for (i = 0; i < len; i++) {
                while (lower.length >= 2 && $MathConvexHullUtil.cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
                    lower.pop();
                }
                lower.push(points[i]);
            }
            var upper = [];
            for (i = len - 1; i >= 0; i--) {
                while (upper.length >= 2 && $MathConvexHullUtil.cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
                    upper.pop();
                }
                upper.push(points[i]);
            }
            upper.pop();
            lower.pop();
            return lower.concat(upper);
        }
    };
    var $MathLineUtil = {
        calc2LinesIntersection: function(line1StartPoint, line1EndPoint, line2StartPoint, line2EndPoint, isLineSegment) {
            var x1 = line1StartPoint.x, y1 = line1StartPoint.y, x2 = line1EndPoint.x, y2 = line1EndPoint.y;
            var x3 = line2StartPoint.x, y3 = line2StartPoint.y, x4 = line2EndPoint.x, y4 = line2EndPoint.y;
            var c = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (c === 0) {
                return undefined;
            }
            var point = {
                x: ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / c,
                y: ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / c
            };
            if (isLineSegment === false) {
                return point;
            }
            if ($MathLineUtil.isPointOnLineSegment(point, line1StartPoint, line1EndPoint) && $MathLineUtil.isPointOnLineSegment(point, line2StartPoint, line2EndPoint)) {
                return point;
            }
            return undefined;
        },
        calcRectLineIntersection: function(rect, lineStartPoint, lineEndPoint, isLineSegment) {
            var rectX = rect.x, rectY = rect.y, width = rect.width, height = rect.height;
            var startX = lineStartPoint.x, startY = lineStartPoint.y, endX = lineEndPoint.x, endY = lineEndPoint.y;
            var ltPoint = {
                x: rectX,
                y: rectY
            };
            var rtPoint = {
                x: rectX + width,
                y: rectY
            };
            var lbPoint = {
                x: rectX,
                y: rectY + height
            };
            var rbPoint = {
                x: rectX + width,
                y: rectY + height
            };
            var topLinePoints = [ ltPoint, rtPoint ];
            var rightLinePoints = [ rtPoint, rbPoint ];
            var bottomLinePoints = [ rbPoint, lbPoint ];
            var leftLinePoints = [ lbPoint, ltPoint ];
            var lines;
            if (startX < endX) {
                if (startY < endY) {
                    lines = [ leftLinePoints, topLinePoints, rightLinePoints, bottomLinePoints ];
                } else {
                    lines = [ bottomLinePoints, leftLinePoints, topLinePoints, rightLinePoints ];
                }
            } else {
                if (startY < endY) {
                    lines = [ topLinePoints, rightLinePoints, bottomLinePoints, leftLinePoints ];
                } else {
                    lines = [ rightLinePoints, bottomLinePoints, leftLinePoints, topLinePoints ];
                }
            }
            var ps = [];
            for (var i = 0; i < 4; i++) {
                var line = lines[i];
                var _startPoint = line[0], _endPoint = line[1];
                var ip = $MathLineUtil.calc2LinesIntersection(_startPoint, _endPoint, lineStartPoint, lineEndPoint, isLineSegment);
                if (ip) {
                    if ($MathLineUtil.isPointOnLineSegment(ip, _startPoint, _endPoint)) {
                        ps.push(ip);
                        if (i === 0 || i === 2) {
                            i++;
                        }
                    }
                }
            }
            return ps;
        },
        calcPointToLineClosestPoint: function(point, lineStartPoint, lineEndPoint) {
            var startX = lineStartPoint.x, startY = lineStartPoint.y, endX = lineEndPoint.x, endY = lineEndPoint.y;
            if (startX === endX && startY === endY) {
                return {
                    x: startX,
                    y: startY
                };
            }
            var l2 = $MathPow(startX - endX, 2) + $MathPow(startY - endY, 2);
            var t = ((point.x - startX) * (endX - startX) + (point.y - startY) * (endY - startY)) / l2;
            if (t < 0) {
                return {
                    x: startX,
                    y: startY
                };
            } else if (t > 1) {
                return {
                    x: endX,
                    y: endY
                };
            }
            return {
                x: startX + t * (endX - startX),
                y: startY + t * (endY - startY)
            };
        },
        isPointsOnLineSameSide: function(lineStartPoint, lineEndPoint, points) {
            if (points.length < 2) {
                return true;
            }
            var lineValues = [];
            if (lineStartPoint.x === lineEndPoint.x) {
                points.forEach(function(point) {
                    lineValues.push(point.x - lineStartPoint.x);
                });
            } else if (lineStartPoint.y === lineEndPoint.y) {
                points.forEach(function(point) {
                    lineValues.push(point.y - lineStartPoint.y);
                });
            } else {
                points.forEach(function(point) {
                    lineValues.push((point.y - lineStartPoint.y) * (lineEndPoint.x - lineStartPoint.x) - (point.x - lineStartPoint.x) * (lineEndPoint.y - lineStartPoint.y));
                });
            }
            var types = [];
            lineValues.forEach(function(value) {
                if (value < 0) {
                    value = -1;
                } else if (value > 0) {
                    value = 1;
                }
                if (types.indexOf(value) < 0) {
                    types.push(value);
                }
            });
            return types.indexOf(1) > -1 && types.indexOf(1) > -1;
        },
        isPointOnLineSegment: function(point, point1, point2) {
            var gap = 1e-4;
            var dis1f = $mathCalcDistance(point, point1);
            var dis1t = $mathCalcDistance(point, point2);
            var dis1 = $mathCalcDistance(point1, point2);
            return $MathAbs(dis1f + dis1t - dis1) < gap;
        },
        calcOffsetPointOnLine: function(startPoint, endPoint, offset, isPercent) {
            var length = $mathCalcDistance(endPoint, startPoint);
            if (isPercent === true && (offset >= 0 && offset <= 1)) {
                offset = $MathUtil.range(offset * length, 0, length);
            }
            if (offset <= 0) {
                return startPoint;
            }
            if (offset >= length) {
                return endPoint;
            }
            return {
                x: (length - offset) / length * (startPoint.x - endPoint.x) + endPoint.x,
                y: offset / length * (endPoint.y - startPoint.y) + startPoint.y
            };
        }
    };
    var $MathPointUtil = {
        getTransformedPoint: function(point, transform) {
            var e = transform.e || transform.translate_x || 0;
            var f = transform.f || transform.translate_y || 0;
            var a = transform.a || transform.scale_x || transform.zoom || 1;
            var d = transform.d || transform.scale_y || transform.zoom || 1;
            var b = transform.b || transform.skew_x || 0;
            var c = transform.c || transform.skew_y || 0;
            var transformedX = a * point.x + c * point.y + e;
            var transformedY = b * point.x + d * point.y + f;
            return {
                x: transformedX,
                y: transformedY
            };
        },
        calc3PointsCircleCenter: function(p1, p2, p3) {
            var rr = (p2.y - p1.y) / (p2.x - p1.x);
            var tt = (p3.y - p2.y) / (p3.x - p2.x);
            var x = (rr * tt * (p3.y - p1.y) + rr * (p2.x + p3.x) - tt * (p1.x + p2.x)) / (2 * (rr - tt));
            var y = (p1.y + p2.y) / 2 - 1 / rr * (x - (p1.x + p2.x) / 2);
            return {
                x: x,
                y: y
            };
        },
        calc3PointsAngle: function(p1, p2, p3) {
            var AB = $MathSqrt($MathPow(p2.x - p1.x, 2) + $MathPow(p2.y - p1.y, 2));
            var BC = $MathSqrt($MathPow(p2.x - p3.x, 2) + $MathPow(p2.y - p3.y, 2));
            var AC = $MathSqrt($MathPow(p3.x - p1.x, 2) + $MathPow(p3.y - p1.y, 2));
            return $MathUtil.toDegrees($MathAcos((BC * BC + AB * AB - AC * AC) / (2 * BC * AB)));
        },
        calcPointOnCircle: function(center, radius, angDeg) {
            var angle = $mathToRadians($mathTo360Degrees(angDeg));
            return {
                x: center.x + $MathCos(angle) * radius,
                y: center.y + $MathSin(angle) * radius
            };
        },
        calcPointOnEllipse: function(rect, angDeg) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var cx = x + width / 2;
            var cy = y + height / 2;
            angDeg = $mathTo360Degrees(angDeg);
            var angRad = $mathToRadians(angDeg);
            var tg = $MathTan(angRad);
            var a = width / 2, b = height / 2;
            var a2 = a * a;
            var b2 = b * b;
            var xx = $MathSqrt(a2 * b2 / (b2 + a2 * tg * tg));
            var yy = xx * tg;
            var x1 = xx + cx;
            var y1 = yy + cy;
            var x2 = -xx + cx;
            var y2 = -yy + cy;
            var angle1 = $mathCalcAngle({
                x: cx,
                y: cy
            }, {
                x: x1,
                y: y1
            });
            if (angDeg >= 0 && angDeg < $180) {
                if (angle1 >= 0 && angle1 < $180) {
                    return {
                        x: x1,
                        y: y1
                    };
                } else {
                    return {
                        x: x2,
                        y: y2
                    };
                }
            } else {
                if (angle1 >= $180 && angle1 < $360) {
                    return {
                        x: x1,
                        y: y1
                    };
                } else {
                    return {
                        x: x2,
                        y: y2
                    };
                }
            }
        },
        calcRotatedPoint: function(center, point, angDeg) {
            var cx = center.x, cy = center.y, px = point.x, py = point.y;
            var a = $mathToRadians($mathTo360Degrees(angDeg));
            var nx = cx + (px - cx) * $MathCos(a) - (py - cy) * $MathSin(a);
            var ny = cy + (py - cy) * $MathCos(a) + (px - cx) * $MathSin(a);
            return {
                x: nx,
                y: ny
            };
        },
        calcParallelogramPoints: function(childrenPoints, angle) {
            var len = childrenPoints.length;
            if (len > 0) {
                var point = childrenPoints[0];
                var left = point.x, right = point.x, top = point.y, bottom = point.y;
                var leftPoint = point, rightPoint = point;
                for (var j = 1; j < len; j++) {
                    point = childrenPoints[j];
                    top = $MathMin(top, point.y);
                    bottom = $MathMax(bottom, point.y);
                    if (point.x < left) {
                        left = point.x;
                        leftPoint = point;
                    }
                    if (point.x > right) {
                        right = point.x;
                        rightPoint = point;
                    }
                }
                var tanAngle = $MathTan($mathToRadians(angle % 90));
                var lbx = leftPoint.x - (bottom - leftPoint.y) / tanAngle;
                var rbx = rightPoint.x - (bottom - rightPoint.y) / tanAngle;
                var l = 0;
                var leftFun = function() {
                    for (;l < len; l++) {
                        point = childrenPoints[l];
                        var cy = bottom - tanAngle * (point.x - lbx);
                        if (point.y < cy) {
                            lbx = point.x - (bottom - point.y) / tanAngle - 1;
                            return false;
                        }
                    }
                    return true;
                };
                var r = 0;
                var rightFun = function() {
                    for (;r < len; r++) {
                        point = childrenPoints[r];
                        if (point.x > rbx) {
                            var cy = bottom - tanAngle * (point.x - rbx);
                            if (point.y > cy) {
                                rbx = point.x - (bottom - point.y) / tanAngle + 1;
                                return false;
                            }
                        }
                    }
                    return true;
                };
                while (!leftFun()) {}
                while (!rightFun()) {}
                var x_gap = (bottom - top) / tanAngle;
                var ltx = lbx + x_gap;
                var rtx = rbx + x_gap;
                return [ {
                    x: lbx,
                    y: bottom
                }, {
                    x: ltx,
                    y: top
                }, {
                    x: rtx,
                    y: top
                }, {
                    x: rbx,
                    y: bottom
                } ];
            }
            return childrenPoints;
        },
        calcPointsBounds: function(points) {
            points = points || [];
            var len = points.length;
            if (len === 0) {
                return null;
            }
            var p = points[0];
            var minX = p.x, minY = p.y, maxX = p.x, maxY = p.y;
            for (var i = 1; i < len; i++) {
                p = points[i];
                minX = $MathMin(minX, p.x);
                minY = $MathMin(minY, p.y);
                maxX = $MathMax(maxX, p.x);
                maxY = $MathMax(maxY, p.y);
            }
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        },
        rectContainsPoint: function(rect, point) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height, px = point.x, py = point.y;
            if (width <= 0 || height <= 0) {
                return false;
            }
            return px >= x && px <= x + width && py >= y && py <= y + height;
        },
        circleContainsPoint: function(center, radius, point) {
            var dis = $mathCalcDistance(center, point);
            return dis <= radius;
        },
        ellipseContainsPoint: function(rect, point) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var a = width / 2;
            var b = height / 2;
            var px = point.x - (x + a), py = point.y - (y + b);
            var sum = px * px / (a * a) + py * py / (b * b);
            return sum <= 1;
        },
        pieContainsPoint: function(center, radius, start, end, point) {
            if (!$MathPointUtil.circleContainsPoint(center, radius, point)) {
                return false;
            }
            if ($MathAbs(end - start) >= $360) {
                return true;
            }
            return $MathUtil.isAngleInRange(start, end, $mathCalcAngle(center, point));
        }
    };
    var $MathPathUtil = {
        calcPathBounds: function(pathPoints) {
            pathPoints = pathPoints || [];
            var len = pathPoints.length;
            if (len < 1) {
                return null;
            }
            var p = pathPoints[0];
            var minX = p.x, minY = p.y, maxX = p.x, maxY = p.y;
            if (len > 1) {
                $MathPathUtil.splitPath(pathPoints).forEach(function(item) {
                    var type = item.type;
                    var points = item.points;
                    var bounds;
                    if ($PathUtil.isLineTo(type) || $PathUtil.isMoveTo(type)) {
                        bounds = $MathPointUtil.calcPointsBounds(points);
                    } else if ($PathUtil.isBezier(type)) {
                        bounds = $BezierUtil.getBounds(points);
                    }
                    if (bounds) {
                        minX = $MathMin(minX, bounds.x);
                        minY = $MathMin(minY, bounds.y);
                        maxX = $MathMax(maxX, bounds.x + bounds.width);
                        maxY = $MathMax(maxY, bounds.y + bounds.height);
                    }
                });
            }
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        },
        calcPointToPathClosestPoint: function(point, pathPoints) {
            pathPoints = pathPoints || [];
            if (pathPoints.length < 2) {
                return pathPoints[0];
            }
            var segClosestPoints = [];
            $MathPathUtil.splitPath(pathPoints).forEach(function(item) {
                var type = item.type;
                var points = item.points;
                if ($PathUtil.isLineTo(type) || $PathUtil.isMoveTo(type)) {
                    segClosestPoints.push($MathLineUtil.calcPointToLineClosestPoint(point, points[0], points[1]));
                } else if ($PathUtil.isBezier(type)) {
                    segClosestPoints.push($BezierUtil.getClosestPointOnBezier(points, point));
                }
            });
            var closestPoint = segClosestPoints[0];
            var pointDistance = $mathCalcDistance(point, closestPoint);
            var closestDistance = pointDistance;
            segClosestPoints.forEach(function(cp) {
                pointDistance = $mathCalcDistance(point, cp);
                if (pointDistance < closestDistance) {
                    closestDistance = pointDistance;
                    closestPoint = cp;
                }
            });
            return closestPoint;
        },
        calcPathLength: function(pathPoints) {
            pathPoints = pathPoints || [];
            var length = 0;
            $MathPathUtil.splitPath(pathPoints).forEach(function(seg) {
                var type = seg.type;
                var points = seg.points;
                if ($PathUtil.isLineTo(type)) {
                    length += $mathCalcDistance(points[0], points[1]);
                } else if ($PathUtil.isBezier(type)) {
                    length += $BezierUtil.getLength(points);
                }
            });
            return length;
        },
        calcOffsetPointOnPath: function(pathPoints, offsetLength, isPercent) {
            pathPoints = pathPoints || [];
            var pathPointsSize = pathPoints.length;
            if (pathPointsSize < 2) {
                return null;
            }
            var point, angle;
            if (offsetLength <= 0) {
                point = pathPoints[0];
                angle = $mathCalcAngle(point, pathPoints[1]);
            } else {
                var fullLength = $MathPathUtil.calcPathLength(pathPoints);
                if (isPercent === true && (offsetLength <= 1 && offsetLength >= 0)) {
                    if (offsetLength >= 1) {
                        point = pathPoints[pathPointsSize - 1];
                        angle = $mathCalcAngle(pathPoints[pathPointsSize - 2], point);
                    } else {
                        offsetLength = $MathUtil.range(offsetLength * fullLength, 0, fullLength);
                    }
                }
                if (offsetLength >= fullLength) {
                    point = pathPoints[pathPointsSize - 1];
                    angle = $mathCalcAngle(pathPoints[pathPointsSize - 2], point);
                }
            }
            if (point) {
                return $mergeObject({
                    angle: angle
                }, point);
            }
            $eachArray($MathPathUtil.splitPath(pathPoints), function(seg) {
                var type = seg.type;
                var points = seg.points;
                var pointsSize = points.length;
                var segLen = 0;
                if ($PathUtil.isLineTo(type)) {
                    segLen = $mathCalcDistance(points[0], points[1]);
                } else if ($PathUtil.isBezier(type)) {
                    segLen = $BezierUtil.getLength(points);
                }
                if (segLen < offsetLength) {
                    offsetLength -= segLen;
                } else {
                    if ($PathUtil.isLineTo(type)) {
                        point = $MathPathUtil._getPathOffsetPoint($MathLineUtil.calcOffsetPointOnLine(points[0], points[1], offsetLength), seg);
                    } else if ($PathUtil.isBezier(type)) {
                        var lutPoints = $BezierUtil.getLUT(points, $MathMax(segLen | 0, 20));
                        var lpCount = lutPoints.length;
                        for (var i = 1; i < lpCount; i++) {
                            var lastP = lutPoints[i - 1];
                            var p = lutPoints[i];
                            var pointLen = $mathCalcDistance(lastP, p);
                            if (pointLen < offsetLength) {
                                offsetLength -= pointLen;
                            } else {
                                if (offsetLength < pointLen / 2) {
                                    point = $MathPathUtil._getPathOffsetPoint(lastP, seg, lutPoints, i - 1);
                                } else {
                                    point = $MathPathUtil._getPathOffsetPoint(p, seg, lutPoints, i);
                                }
                                break;
                            }
                        }
                    }
                    if (point == null) {
                        point = points[pointsSize - 1];
                        angle = $mathCalcAngle(points[pointsSize - 2], points);
                    }
                    return false;
                }
            });
            if (point) {
                return $mergeObject({
                    angle: angle
                }, point);
            }
        },
        _getPathOffsetPoint: function(point, seg, lutPoints, index) {
            var type = seg.type;
            var points = seg.points;
            var length = points.length;
            if ($PathUtil.isBezier(type)) {
                if (index === 0) {
                    index = 1;
                }
                point.angle = $mathCalcAngle(lutPoints[index - 1], lutPoints[index]);
            } else {
                point.angle = $mathCalcAngle(points[0], points[length - 1]);
            }
            return point;
        },
        splitPath: function(points) {
            var count = points.length;
            if (count < 2) {
                return [];
            }
            var lines = [];
            var _pathPoint = points[0];
            var lastSeg = _pathPoint.seg;
            var lastPoint = _pathPoint;
            for (var i = 1; i < count; i++) {
                _pathPoint = points[i];
                if (lastSeg != null) {
                    if ($PathUtil.isMoveTo(lastSeg)) {
                        lines.push({
                            type: "move_to",
                            points: [ points[i - 1], _pathPoint ]
                        });
                    } else if ($PathUtil.isQuadraticCurveTo(lastSeg)) {
                        if (i < count - 1) {
                            var qtCP = _pathPoint;
                            _pathPoint = points[++i];
                            lines.push({
                                type: "quadratic_curve_to",
                                points: [ lastPoint, qtCP, _pathPoint ]
                            });
                        } else {
                            lines.push({
                                type: "line_to",
                                points: [ lastPoint, _pathPoint ]
                            });
                        }
                    } else if ($PathUtil.isBezierCurveTo(lastSeg)) {
                        if (i < count - 2) {
                            var ctCP1 = _pathPoint;
                            _pathPoint = points[++i];
                            var ctCP2 = _pathPoint;
                            _pathPoint = points[++i];
                            lines.push({
                                type: "bezier_curve_to",
                                points: [ lastPoint, ctCP1, ctCP2, _pathPoint ]
                            });
                        } else {
                            lines.push({
                                type: "line_to",
                                points: [ lastPoint, _pathPoint ]
                            });
                        }
                    }
                } else {
                    lines.push({
                        type: "line_to",
                        points: [ points[i - 1], _pathPoint ]
                    });
                }
                lastSeg = _pathPoint.seg;
                lastPoint = _pathPoint;
            }
            return lines;
        },
        roundPath: function(pathPoints, corner_radius, closed) {
            if (corner_radius > 1 && pathPoints) {
                var size = pathPoints.length;
                if (size > 2) {
                    if (closed === true) {
                        pathPoints = $mergeArray([ pathPoints[size - 1] ], pathPoints, [ pathPoints[0] ]);
                        size += 2;
                    }
                    var newPoints = [];
                    newPoints.push(pathPoints[0]);
                    for (var i = 1; i < size - 1; i++) {
                        var point = pathPoints[i];
                        var lastPoint = pathPoints[i - 1];
                        var nextPoint = pathPoints[i + 1];
                        var lastDis = $mathCalcDistance(lastPoint, point);
                        var nextDis = $mathCalcDistance(point, nextPoint);
                        if (closed === true) {
                            lastDis /= 2;
                            nextDis /= 2;
                        } else {
                            if (i !== 1) {
                                lastDis /= 2;
                            }
                            if (i !== size - 2) {
                                nextDis /= 2;
                            }
                        }
                        var _radius = $MathMin(lastDis, nextDis, corner_radius);
                        var cp = $MathPointUtil.calcPointOnCircle(point, _radius, $mathCalcAngle(point, lastPoint));
                        cp.seg = "quadratic_curve_to";
                        newPoints.push(cp);
                        newPoints.push(point);
                        newPoints.push($MathPointUtil.calcPointOnCircle(point, _radius, $mathCalcAngle(point, nextPoint)));
                    }
                    newPoints.push(pathPoints[size - 1]);
                    if (closed === true) {
                        newPoints.shift();
                        newPoints.pop();
                    }
                    return newPoints;
                }
            }
            return pathPoints;
        }
    };
    var $MathRectUtil = {
        createGrowRect: function(rect, h, v) {
            if (arguments.length === 2) {
                v = h;
            }
            return {
                x: rect.x - h,
                y: rect.y - v,
                width: rect.width + h * 2,
                height: rect.height + v * 2
            };
        },
        getRectCenter: function(rect) {
            return {
                x: rect.x + rect.width / 2,
                y: rect.y + rect.height / 2
            };
        },
        intersectsRect: function(rect1, rect2) {
            if (rect1.width <= 0 || rect1.height <= 0 || rect2.width <= 0 || rect2.height <= 0) {
                return false;
            }
            return rect2.x + rect2.width > rect1.x && rect2.y + rect2.height > rect1.y && rect2.x < rect1.x + rect1.width && rect2.y < rect1.y + rect1.height;
        },
        containsRect: function(rect, containedRect) {
            var rectWidth = rect.width, rectHeight = rect.height, containedRectWidth = containedRect.width, containedRectHeight = containedRect.height;
            if (rectWidth <= 0 || rectHeight <= 0 || containedRectWidth < 0 || containedRectHeight < 0) {
                return false;
            }
            var rectX = rect.x, rectY = rect.y, containedRectX = containedRect.x, containedRectY = containedRect.y;
            return containedRectX >= rectX && containedRectY >= rectY && containedRectX + containedRectWidth <= rectX + rectWidth && containedRectY + containedRectHeight <= rectY + rectHeight;
        },
        calcRectsUnion: function(rectArr) {
            if (rectArr.length === 0) {
                return null;
            }
            var rect1 = rectArr[0];
            var minX = rect1.x, minY = rect1.y;
            var maxX = minX + rect1.width, maxY = minY + rect1.height;
            rectArr.slice(1).forEach(function(rect) {
                minX = $MathMin(minX, rect.x);
                minY = $MathMin(minY, rect.y);
                maxX = $MathMax(maxX, rect.x + rect.width);
                maxY = $MathMax(maxY, rect.y + rect.height);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        },
        calcRectsIntersection: function(rectArr) {
            if (rectArr.length === 0) {
                return null;
            }
            var rect1 = rectArr[0];
            var iRect = {
                x: rect1.x,
                y: rect1.y,
                width: rect1.width,
                height: rect1.height
            };
            rectArr.slice(1).forEach(function(rect) {
                if (!$MathRectUtil.intersectsRect(iRect, rect)) {
                    return undefined;
                }
                var x1 = iRect.x, y1 = iRect.y;
                var x2 = rect.x, y2 = rect.y;
                var x = $MathMax(x1, x2);
                var y = $MathMax(y1, y2);
                iRect = {
                    x: x,
                    y: y,
                    width: $MathMin(x1 + iRect.width, x2 + rect.width) - x,
                    height: $MathMin(y1 + iRect.height, y2 + rect.height) - y
                };
            });
            return iRect;
        },
        calcRotatedRect: function(rect, angdge, center) {
            if (rect == null) {
                return null;
            }
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            if (angdge % 360 === 0) {
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                };
            }
            center = center || {
                x: rect.x + width / 2,
                y: rect.y + height / 2
            };
            var ltPoint = $MathPointUtil.calcRotatedPoint(center, {
                x: x,
                y: y
            }, angdge);
            var rtPoint = $MathPointUtil.calcRotatedPoint(center, {
                x: x + width,
                y: y
            }, angdge);
            var rbPoint = $MathPointUtil.calcRotatedPoint(center, {
                x: x + width,
                y: y + height
            }, angdge);
            var lbPoint = $MathPointUtil.calcRotatedPoint(center, {
                x: x,
                y: y + height
            }, angdge);
            var minX = $MathMin(ltPoint.x, rtPoint.x, rbPoint.x, lbPoint.x);
            var minY = $MathMin(ltPoint.y, rtPoint.y, rbPoint.y, lbPoint.y);
            var maxX = $MathMax(ltPoint.x, rtPoint.x, rbPoint.x, lbPoint.x);
            var maxY = $MathMax(ltPoint.y, rtPoint.y, rbPoint.y, lbPoint.y);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    };
    var $AnimationCubicBezier = {
        calcCubicBezier: function(p0, p1, p2, p3, t) {
            return $MathPow(1 - t, 3) * p0 + 3 * t * $MathPow(1 - t, 2) * p1 + 3 * $MathPow(t, 2) * (1 - t) * p2 + $MathPow(t, 3) * p3;
        },
        calcCubicBezierT: function(p0, p1, p2, p3, pv) {
            if (pv === p0 || pv === p3) {
                return pv;
            }
            var minOffset = 1e-6;
            var tv;
            var offset;
            var startT = 0, endT = 1, halfT;
            do {
                halfT = startT + (endT - startT) / 2;
                tv = $AnimationCubicBezier.calcCubicBezier(p0, p1, p2, p3, halfT);
                offset = tv - pv;
                if ($MathAbs(offset) < minOffset) {
                    break;
                }
                if (offset > 0) {
                    endT = halfT;
                } else {
                    startT = halfT;
                }
            } while (true);
            return halfT;
        }
    };
    var $AnimationTiming = {
        linear: function(timeFraction) {
            return timeFraction;
        },
        ease: function(timeFraction) {
            return $AnimationTiming._calcCubicBezierTiming({
                x: .25,
                y: .1
            }, {
                x: .25,
                y: 1
            }, timeFraction);
        },
        "ease-in": function(timeFraction) {
            return $AnimationTiming._calcCubicBezierTiming({
                x: .42,
                y: 0
            }, {
                x: 1,
                y: 1
            }, timeFraction);
        },
        "ease-out": function(timeFraction) {
            return $AnimationTiming._calcCubicBezierTiming({
                x: 0,
                y: 0
            }, {
                x: .58,
                y: 1
            }, timeFraction);
        },
        "ease-in-out": function(timeFraction) {
            return $AnimationTiming._calcCubicBezierTiming({
                x: .42,
                y: 0
            }, {
                x: .58,
                y: 1
            }, timeFraction);
        },
        "cubic-bezier": function(timeFraction, cx1, cy1, cx2, cy2) {
            return $AnimationTiming._calcCubicBezierTiming({
                x: cx1,
                y: cy1
            }, {
                x: cx2,
                y: cy2
            }, timeFraction);
        },
        _calcCubicBezierTiming: function(cp1, cp2, timeFraction) {
            var t = $AnimationCubicBezier.calcCubicBezierT(0, cp1.x, cp2.x, 1, timeFraction);
            return $AnimationCubicBezier.calcCubicBezier(0, cp1.y, cp2.y, 1, t);
        },
        getTimingFunc: function(timingFunction) {
            if ($isString(timingFunction)) {
                if ($AnimationTiming.hasOwnProperty(timingFunction)) {
                    timingFunction = $AnimationTiming[timingFunction];
                } else {
                    var match = timingFunction.match(/^\s*[(\w+)-]\s*\((.*)\)/);
                    if (match) {
                        var funName = match[1];
                        if (funName && $AnimationTiming.hasOwnProperty(funName)) {
                            var fun = $AnimationTiming[funName];
                            var args = match[1].split(",");
                            timingFunction = function(timeFraction) {
                                return fun.apply(null, [ timeFraction ].concat(args));
                            };
                        }
                    }
                }
            }
            if (!$isFunction(timingFunction)) {
                timingFunction = $AnimationTiming["linear"];
            }
            return timingFunction;
        }
    };
    var $AnimationUtil = {
        cancelAnimate: function(animateID) {
            $TimerUtil.cancelCallRAFInterval(animateID);
        },
        animate: function(frameFun, options) {
            if ($isObject(arguments[0])) {
                options = arguments[0];
                frameFun = options.frame;
            }
            if (!$isFunction(frameFun)) {
                return;
            }
            options = options || {};
            var duration = options.duration | 0;
            if (duration <= 0) {
                return;
            }
            var timingFunc = $AnimationTiming.getTimingFunc(options.timing_function || options.timing || options.easing);
            var finishFunc = options.finish;
            var delay = options.delay | 0;
            var direction = options.direction;
            var iteration_count = options.iteration_count || options.iterations;
            if (iteration_count === true || iteration_count === Infinity) {
                iteration_count = Infinity;
            } else {
                iteration_count = $MathMax(1, iteration_count | 0);
            }
            var start = performance.now();
            var alternate = 1;
            var count = 1;
            return $callRAFInterval(function() {
                var pNow = performance.now();
                var td = pNow - start;
                if (delay > 0) {
                    if (td <= delay) {
                        return;
                    }
                    delay = 0;
                    start = pNow;
                    td = 0;
                }
                var timeFraction = td / duration;
                var once = false;
                if (timeFraction >= 1) {
                    once = true;
                    timeFraction = 1;
                }
                var progress = timingFunc(alternate === -1 ? 1 - timeFraction : timeFraction);
                var fResult = frameFun(progress, count);
                if (fResult === false) {
                    if (finishFunc) {
                        finishFunc();
                    }
                    return fResult;
                }
                if (once === true) {
                    if (count >= iteration_count) {
                        if (finishFunc) {
                            finishFunc();
                        }
                        return false;
                    }
                    count++;
                    start = pNow;
                    if (direction === "alternate") {
                        alternate *= -1;
                    }
                }
            });
        }
    };
    var $ImageUtil = {
        _loadingMap: {},
        _cachedMap: {},
        _errorMap: {},
        clearCache: function() {
            $ImageUtil._loadingMap = {};
            $ImageUtil._cachedMap = {};
            $ImageUtil._errorMap = {};
        },
        register: function(name, imgSrc) {
            if (imgSrc) {
                if ($isString(imgSrc)) {
                    var loadingArr = $ImageUtil._loadingMap[name];
                    if (loadingArr == null) {
                        loadingArr = [];
                        $ImageUtil._loadingMap[name] = loadingArr;
                    }
                    $ImageUtil.load(name, imgSrc);
                } else {
                    $ImageUtil._cachedMap[name] = imgSrc;
                }
            }
        },
        get: function(name, loadCallBack, context) {
            if (!$isString(name)) {
                return name;
            }
            if ($ImageUtil._cachedMap.hasOwnProperty(name)) {
                return $ImageUtil._cachedMap[name];
            }
            if ($ImageUtil._errorMap[name] > 1) {
                return false;
            }
            var callBackArray = $ImageUtil._loadingMap[name];
            var needLoad = callBackArray == null;
            if (needLoad === true) {
                callBackArray = [];
                $ImageUtil._loadingMap[name] = callBackArray;
            }
            if (loadCallBack) {
                callBackArray.push({
                    callBack: loadCallBack,
                    context: context
                });
            }
            if (needLoad === true) {
                $ImageUtil.load(name, name);
            }
        },
        load: function(name, img_src) {
            var img = new Image();
            img.onload = function() {
                $ImageUtil.cache(name, img);
            };
            img.onerror = function() {
                console.error("Load Image Error:" + img_src);
                $ImageUtil.cache(name, null);
            };
            img.onabort = function() {
                console.error("Load Image Abort:" + img_src);
                $ImageUtil.cache(name, null);
            };
            img.src = img_src;
        },
        cache: function(name, img) {
            if (img) {
                $ImageUtil._cachedMap[name] = img;
            } else {
                $ImageUtil._errorMap[name] = ($ImageUtil._errorMap[name] | 0) + 1;
            }
            var callBackArray = $ImageUtil._loadingMap[name];
            if (callBackArray) {
                callBackArray.forEach(function(item) {
                    item.callBack.apply(item.context, [ img ]);
                });
                delete $ImageUtil._loadingMap[name];
            }
        },
        getColorImage: function(img, color, resultType) {
            var cvs = $ImageUtil._createImgCanvas(img);
            var c2d = cvs.getContext("2d");
            var width = cvs.getAttribute("width");
            var height = cvs.getAttribute("height");
            var imageData = c2d.getImageData(0, 0, width, height);
            $ImageFilter.rgb(imageData, color);
            c2d.putImageData(imageData, 0, 0);
            if (resultType === "canvas") {
                return cvs;
            }
            return cvs.toDataURL(resultType);
        },
        _createImgCanvas: function(img) {
            var iw = img.width;
            var ih = img.height;
            var cvs = $domCreate("canvas");
            cvs.setAttribute("width", iw);
            cvs.setAttribute("height", ih);
            var cx = cvs.getContext("2d");
            cx.drawImage(img, 0, 0);
            return cvs;
        }
    };
    var $ImageFilter = {
        rgb: function(imageData, color) {
            var rgba = $ColorUtil.toRGB(color, true);
            var red = rgba.red;
            var green = rgba.green;
            var blue = rgba.blue;
            var pixArr = imageData.data;
            var pixCount = pixArr.length;
            var w, i;
            for (i = 0; i < pixCount; i += 4) {
                if (pixArr[i + 3] !== 0) {
                    w = (.34 * pixArr[i] + .5 * pixArr[i + 1] + .16 * pixArr[i + 2]) / 255;
                    pixArr[i] = w * red;
                    pixArr[i + 1] = w * green;
                    pixArr[i + 2] = w * blue;
                    pixArr[i + 3] = pixArr[i + 3];
                }
            }
        }
    };
    var $ZObject = function(props) {
        if (!(this instanceof $ZObject)) {
            $Util.throwError("Instance must be constructed via new");
        }
        this.__zid__ = $Util.guid();
        this.__props__ = {};
        this.__getProps__ = {};
        if ($isObject(props)) {
            $eachObject(props, function(key, value) {
                if ($isFunction(value)) {
                    this[key] = value;
                } else {
                    this.__initSetProperty(key, value);
                }
            }, this);
        }
    };
    $extendClass($ZObject, Object, {
        id: function() {
            return this.__zid__;
        },
        _bind: function(propsObj) {
            if ($isObject(propsObj)) {
                var _this = this;
                $eachObject(propsObj, function(key, value) {
                    var _v = value;
                    Object.defineProperty(propsObj, key, {
                        set: function(nv) {
                            _v = nv;
                            if ($isFunction(_v)) {
                                _this[key] = _v;
                            } else {
                                _this.setProperty(key, _v);
                            }
                        },
                        get: function() {
                            return _v;
                        }
                    });
                });
            }
        },
        setCallBack: function(method, callBack, context) {
            this["_default_" + method] = this.constructor.prototype[method];
            this[method] = function() {
                callBack.apply(context || this, arguments);
            };
        },
        resetCallBack: function(method) {
            this[method] = this["_default_" + method];
        },
        getClassName: function() {
            return this.constructor.__className_;
        },
        set: function(key, value) {
            return this.setProperty.apply(this, arguments);
        },
        setProperty: function(key, value) {
            var aLen = arguments.length;
            if (aLen === 1 && $isObject(key)) {
                $eachObject(key, function(key, value) {
                    this._setProperty(key, value);
                }, this);
            } else {
                if (aLen > 1) {
                    this._setProperty(key, value);
                }
            }
            return this;
        },
        isPropertyValid: function(key, value, old) {
            return true;
        },
        beforeSetProperty: function(key, value, old) {},
        afterSetProperty: function(key, value, old) {},
        __initSetProperty: function(key, value) {
            var old = this.__props__[key];
            if (this.isPropertyValid(key, value, old) === false) {
                return this;
            }
            this.beforeSetProperty(key, value, old);
            this.__props__[key] = value;
            delete this.__getProps__[key];
            this.afterSetProperty(key, value, old);
            return this;
        },
        _setProperty: function(key, value) {
            var old = undefined;
            if (this.hasProperty(key)) {
                old = this.__props__[key];
                if (old === value) {
                    return this;
                }
            }
            if (this.isPropertyValid(key, value, old) === false) {
                return this;
            }
            this.beforeSetProperty(key, value, old);
            this.__props__[key] = value;
            delete this.__getProps__[key];
            this.afterSetProperty(key, value, old);
            if (old !== value) {
                this._onPropertyChange(key, value, old);
            }
            return this;
        },
        _onPropertyChange: function(key, value, old) {},
        get: function(key) {
            return this.getProperty(key);
        },
        getProperty: function(key) {
            if (this.__getProps__.hasOwnProperty(key)) {
                return this.__getProps__[key];
            }
            var v = this._getProperty(key);
            this.__getProps__[key] = v;
            return v;
        },
        _getProperty: function(key) {
            if (this.hasProperty(key)) {
                return this.__props__[key];
            }
            return $ClassUtil.getClassDefault(this.constructor, key);
        },
        remove: function(key) {
            return this.removeProperty(key);
        },
        removeProperty: function(key) {
            if (this.hasProperty(key)) {
                var old = this.__props__[key];
                if (old !== undefined) {
                    if (this.isPropertyValid(key, undefined, old) === false) {
                        return this;
                    }
                    this.beforeSetProperty(key, undefined, old);
                    delete this.__props__[key];
                    delete this.__getProps__[key];
                    this.afterSetProperty(key, undefined, old);
                    this._onPropertyChange(key, undefined, old);
                } else {
                    delete this.__props__[key];
                    delete this.__getProps__[key];
                }
            }
            return this;
        },
        has: function(key) {
            return this.hasProperty(key);
        },
        hasProperty: function(key) {
            return this.__props__.hasOwnProperty(key);
        },
        gets: function() {
            return this.getProperties.apply(this, arguments);
        },
        getProperties: function(keysOrCopy) {
            if (arguments.length === 0) {
                return this._getAllProperties();
            }
            if (keysOrCopy === false) {
                return this._getAllProperties(false);
            }
            var obj = {};
            if ($isArray(keysOrCopy)) {
                keysOrCopy.forEach(function(key) {
                    obj[key] = this.getProperty(key);
                }, this);
                return obj;
            }
            return obj;
        },
        _getAllProperties: function(copy) {
            if (copy === false) {
                return this.__props__;
            }
            return $mergeObject({}, this.__props__);
        }
    });
    var $EventDispatcher = function() {
        this._typeListenersMap = Object.create(null);
    };
    $extendClass($EventDispatcher, Object, {
        add: function(type, listener, thisArg) {
            var listenerArr = this._typeListenersMap[type];
            if (listenerArr == null) {
                listenerArr = [];
                this._typeListenersMap[type] = listenerArr;
            }
            var lis = {
                listener: listener,
                context: thisArg
            };
            listenerArr.push(lis);
            return lis;
        },
        remove: function(type, listener, thisArg) {
            var listenerArr = this._typeListenersMap[type];
            if (listenerArr) {
                var size = listenerArr.length;
                for (var i = 0; i < size; i++) {
                    var obj = listenerArr[i];
                    if (obj.listener === listener && obj.context === thisArg) {
                        listenerArr.splice(i, 1);
                        return;
                    }
                }
            }
        },
        dispatch: function(type, event) {
            var listenerArr = this._typeListenersMap[type];
            if (listenerArr) {
                var size = listenerArr.length;
                for (var i = 0; i < size; i++) {
                    var ef = listenerArr[i];
                    var listener = ef.listener;
                    var context = ef.context;
                    listener.apply(context, [ event ]);
                }
            }
        }
    });
    var $ChangeSupport = function() {
        this._dispatcher = new $EventDispatcher();
        $ChangeSupport.superClass.constructor.apply(this, arguments);
    };
    $extendClass($ChangeSupport, $ZObject, {
        _onPropertyChange: function(key, value, old) {
            $ChangeSupport.superClass._onPropertyChange.apply(this, arguments);
            this.dispatchChangeEvent(key, value, old);
        },
        getDispatcher: function() {
            return this._dispatcher;
        },
        addListener: function(type, fun, thisArg) {
            this._dispatcher.add(type, fun, thisArg);
        },
        removeListener: function(type, fun, thisArg) {
            this._dispatcher.remove(type, fun, thisArg);
        },
        dispatchEvent: function(type, event) {
            this._dispatcher.dispatch(type, event);
        },
        addChangeListener: function(listener, thisArg) {
            this.addListener("change", listener, thisArg);
        },
        removeChangeListener: function(listener, thisArg) {
            this.removeListener("change", listener, thisArg);
        },
        dispatchChangeEvent: function(property, newValue, oldValue) {
            this.dispatchEvent("change", {
                source: this,
                property: property,
                new_value: newValue,
                old_value: oldValue,
                newValue: newValue,
                oldValue: oldValue
            });
        },
        _callOn: function(onCallBack, onEventType, onEvent, callBackArgs) {
            var _onCallBack = this[onCallBack];
            if (_onCallBack === this.constructor.prototype[onCallBack]) {
                this.dispatchEvent(onEventType, onEvent);
            } else {
                _onCallBack.apply(this, callBackArgs);
            }
        }
    });
    var $windowLocalStorage = window.localStorage, $windowSessionStorage = window.sessionStorage;
    var $CookieUtil = {
        setCookie: function(cookie, value, expire_minutes) {
            var c_value;
            if (arguments.length > 2) {
                var expireDate = new Date();
                expireDate.setTime(expireDate.getTime() + expire_minutes * 6e4);
                c_value = value + "; expires=" + expireDate.toUTCString();
            } else {
                c_value = value;
            }
            document.cookie = cookie + "=" + c_value;
        },
        getCookie: function(name) {
            var matched = document.cookie.match(new RegExp(name + "=([^;]+)"));
            return !!matched ? matched[1] : undefined;
        },
        removeCookie: function(cookie) {
            $CookieUtil.setCookie(cookie, "", -1);
        }
    };
    var $StorageUtil = {
        _call: function(method, storage, args) {
            args = $ArraySlice.call(args);
            args.unshift(storage);
            return method.apply(null, args);
        },
        setItem: function(storage, key, value, expire_minutes) {
            if (value === undefined) {
                $StorageUtil.removeItem(storage, key);
                return;
            }
            if (arguments.length > 3 && expire_minutes > 0) {
                var exTime = (expire_minutes | 0) * 6e4 + Date.now();
                storage.setItem(key, JSON.stringify({
                    _zexpires_time: Date.now() + exTime,
                    value: value
                }));
            } else {
                storage.setItem(key, JSON.stringify(value));
            }
        },
        getItem: function(storage, key) {
            var value = storage.getItem(key);
            if (value) {
                try {
                    value = JSON.parse(value);
                } catch (error) {}
                if ($isObject(value)) {
                    if (value.hasOwnProperty("_zexpires_time")) {
                        var _expires_time = value._zexpires_time;
                        if (_expires_time < Date.now()) {
                            storage.removeItem(key);
                            return undefined;
                        }
                        return value.value;
                    }
                }
                return value;
            }
            return undefined;
        },
        removeItem: function(storage, key) {
            if ($isFunction(key)) {
                $ObjectKeys(storage).forEach(function(itemKey) {
                    if (key(itemKey) === true) {
                        storage.removeItem(itemKey);
                    }
                });
            } else {
                return storage.removeItem(key);
            }
        },
        clear: function(storage) {
            return storage.clear();
        }
    };
    var $LocalStorageUtil = {
        _changeListeners: [],
        setItem: function(key, value, expire_minutes) {
            return $StorageUtil._call($StorageUtil.setItem, $windowLocalStorage, arguments);
        },
        getItem: function(key) {
            return $StorageUtil._call($StorageUtil.getItem, $windowLocalStorage, arguments);
        },
        removeItem: function(key) {
            return $StorageUtil._call($StorageUtil.removeItem, $windowLocalStorage, arguments);
        },
        clear: function() {
            return $StorageUtil._call($StorageUtil.clear, $windowLocalStorage, arguments);
        },
        addChangeListener: function(listener, thisArg, key) {
            $LocalStorageUtil._changeListeners.push({
                listener: listener,
                context: thisArg,
                key: key
            });
            if ($LocalStorageUtil._changeListeners.length === 1) {
                $domOn(window, "storage", $LocalStorageUtil._handleChange);
            }
        },
        removeChangeListener: function(listener, thisArg, key) {
            $removeArrayItem($LocalStorageUtil._changeListeners, function(item) {
                return item.listener === listener && item.context === thisArg && item.key === key;
            });
            if ($LocalStorageUtil._changeListeners.length === 0) {
                $domOff(window, "storage", $LocalStorageUtil._handleChange);
            }
        },
        _handleChange: function(evt) {
            var evtKey = evt.key;
            $LocalStorageUtil._changeListeners.forEach(function(item) {
                if (item.key !== null && evtKey !== item.key) {
                    return;
                }
                item.listener.apply(item.context, [ evt ]);
            });
        }
    };
    var $SessionStorageUtil = {
        setItem: function(key, value, expire_minutes) {
            return $StorageUtil._call($StorageUtil.setItem, $windowSessionStorage, arguments);
        },
        getItem: function(key) {
            return $StorageUtil._call($StorageUtil.getItem, $windowSessionStorage, arguments);
        },
        removeItem: function(key) {
            return $StorageUtil._call($StorageUtil.removeItem, $windowSessionStorage, arguments);
        },
        clear: function() {
            return $StorageUtil._call($StorageUtil.clear, $windowSessionStorage, arguments);
        }
    };
    var $URLUtil = {
        getLocationSearchParam: function(param) {
            var args = [ location.href ];
            if (arguments.length > 0) {
                args.push(param);
            }
            return $URLUtil.getURLSearchParam.apply(null, args);
        },
        getURLSearchParam: function(url, param) {
            if (url == null) {
                return null;
            }
            if ($isString(url)) {
                url = new URL(url);
            }
            var search = url.search;
            var allParams = {};
            if (search.indexOf("?") > -1) {
                search.replace(new RegExp("([^?=&]+)(=([^&]*))?", "g"), function($0, $1, $2, $3) {
                    if (allParams.hasOwnProperty($1)) {
                        allParams[$1] = [ allParams[$1] ];
                        allParams[$1].push($3);
                    } else {
                        allParams[$1] = $3;
                    }
                });
            }
            if (arguments.length < 2) {
                return allParams;
            }
            return allParams[param];
        },
        appendURLSearchParam: function(url, name, value) {
            var queryStr;
            if ($isObject(name)) {
                queryStr = $URLUtil._genSearchParams(name);
            } else if (arguments.length > 2) {
                queryStr = $URLUtil._encodeKVParams(name, value);
            }
            if (queryStr) {
                url = url + (/\?/.test(url) ? "&" : "?") + queryStr;
            }
            return url;
        },
        setURLSearchParam: function(url, name, value) {
            var params = $URLUtil.getURLSearchParam(url);
            if ($isObject(name)) {
                params = $mergeObject(params, name);
            } else {
                params[name] = value;
            }
            url = url.split("?")[0];
            return $URLUtil.appendURLSearchParam(url, params);
        },
        getLocationHash: function(key) {
            var args = [ location.href ];
            if (arguments.length > 0) {
                args.push(key);
            }
            return $URLUtil.getURLHash.apply(null, args);
        },
        getURLHash: function(url, key) {
            if (url == null) {
                return null;
            }
            if ($isString(url)) {
                url = new URL(url);
            }
            var hash = url.hash;
            if (arguments.length < 2) {
                return hash.substr(1);
            }
            var matches = hash.match(new RegExp(key + "=([^&]*)"));
            return matches ? matches[1] : "";
        },
        _genSearchParams: function(data) {
            if (data) {
                if ($isString(data)) {
                    return data;
                } else if ($isObject(data)) {
                    var queryArr = [];
                    $eachObject($ObjectUtil.getDeepKVMap(data), function(key, value) {
                        if ($isArray(value)) {
                            value.forEach(function(item) {
                                queryArr.push($URLUtil._encodeKVParams(key, item));
                            });
                        } else {
                            queryArr.push($URLUtil._encodeKVParams(key, value));
                        }
                    });
                    return queryArr.join("&");
                }
            }
            return "";
        },
        _encodeKVParams: function(key, value) {
            return encodeURIComponent(key) + "=" + encodeURIComponent(value);
        }
    };
    var $BrowserUtil = {};
    (function() {
        var result = function() {
            var ua = navigator.userAgent;
            var tem;
            var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
            if (/trident/i.test(M[1])) {
                tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
                return [ "IE", tem[1] ];
            } else if (M[1] === "Chrome") {
                tem = ua.match(/\b(OPR|Edg)\/(\d+)/);
                if (tem != null) {
                    tem = tem.slice(1);
                    return tem;
                }
            }
            M = M[2] ? [ M[1], M[2] ] : [ navigator.appName, navigator.appVersion, "-?" ];
            if ((tem = ua.match(/version\/(\d+)/i)) != null) {
                M.splice(1, 1, tem[1]);
            }
            return M;
        }();
        if (result) {
            var browser = result[0];
            if (browser) {
                browser = browser.toLowerCase();
                if (browser === "ie" || browser === "msie") {
                    browser = "IE";
                } else if (browser === "opr") {
                    browser = "Opera";
                } else if (browser === "edg") {
                    browser = "Edge";
                } else {
                    browser = $strCapitalize(browser);
                }
            }
            $BrowserUtil.browser = browser;
            $BrowserUtil.version = result[1] | 0;
        } else {
            $BrowserUtil.browser = "Unknown";
        }
    })();
    if (Element) {
        if (!Element.prototype.matches) {
            Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        if (!Element.prototype.closest) {
            Element.prototype.closest = function(s) {
                var el = this;
                do {
                    if (el.matches(s)) return el;
                    el = el.parentElement || el.parentNode;
                } while (el !== null && el.nodeType === 1);
                return null;
            };
        }
    }
    if (window.parent !== window) {
        $Util.nowTime = Date.now();
        $Util.guid = function() {
            return "_z-t-" + $Util.nowTime + "-i-" + $Util.__uid++;
        };
    }
    var $isIE = $BrowserUtil.browser === "IE";
    var $DomQuery = {
        querySelector: function(selectors, rootElement) {
            if (arguments.length > 1) {
                return rootElement.querySelector(selectors);
            } else {
                return document.querySelector(selectors);
            }
        },
        querySelectorAll: function(selectors, rootElement) {
            var result;
            if (arguments.length > 1) {
                result = rootElement.querySelectorAll(selectors);
            } else {
                result = document.querySelectorAll(selectors);
            }
            var _result = [];
            $eachArray(result, function(item) {
                _result.push(item);
            });
            return _result;
        },
        querySelectorChild: function(selectors, rootElement) {
            rootElement = $DomQuery.queryElement(rootElement);
            if (rootElement) {
                return $findArray($DomQuery.querySelectorAll(selectors, rootElement), function(ele) {
                    return ele.parentNode === rootElement;
                });
            }
            return null;
        },
        querySelectorChildren: function(selectors, rootElement) {
            rootElement = $DomQuery.queryElement(rootElement);
            if (rootElement) {
                return $filterArray($DomQuery.querySelectorAll(selectors, rootElement), function(ele) {
                    return ele.parentNode === rootElement;
                });
            }
            return [];
        },
        queryNode: function(ele) {
            if ($isString(ele)) {
                return $DomQuery.querySelector.apply(null, arguments);
            }
            if ($domIsNode(ele)) {
                return ele;
            }
            return null;
        },
        queryElement: function(ele) {
            if ($isString(ele)) {
                return $DomQuery.querySelector.apply(null, arguments);
            }
            if ($domIsElement(ele)) {
                return ele;
            }
            return null;
        },
        queryEventElement: function(ele) {
            if (ele instanceof EventTarget) {
                return ele;
            }
            if (ele === window || ele === document) {
                return ele;
            }
            return $DomQuery.queryElement.apply(null, arguments);
        }
    };
    var $domQuery = $DomQuery.querySelector, $domQueryAll = $DomQuery.querySelectorAll, $domQueryElement = $DomQuery.queryElement, $domQueryNode = $DomQuery.queryNode, $domQueryEventElement = $DomQuery.queryEventElement;
    var $DomClass = {
        add: function(ele, cls) {
            cls = $DomClass.formatClass($getArgsArray(arguments, 1));
            var classList = ele.classList;
            classList.add.apply(classList, cls);
        },
        remove: function(ele, cls) {
            cls = $DomClass.formatClass($getArgsArray(arguments, 1));
            var classList = ele.classList;
            classList.remove.apply(classList, cls);
        },
        toggle: function(ele, cls, force) {
            var classList = ele.classList;
            var clsArr = $getArgsArray(arguments, 1);
            var lastArg = arguments[arguments.length - 1];
            if ($isBoolean(lastArg)) {
                force = lastArg;
                clsArr.pop();
                clsArr = $DomClass.formatClass(clsArr);
                clsArr.forEach(function(cls) {
                    classList.toggle.apply(classList, [ cls, force ]);
                });
            } else {
                clsArr = $DomClass.formatClass(clsArr);
                clsArr.forEach(function(cls) {
                    classList.toggle.apply(classList, [ cls ]);
                });
            }
        },
        set: function(ele, className) {
            className = $DomClass.formatClass($getArgsArray(arguments, 1));
            ele.className = className.join(" ");
        },
        contains: function(ele, cls) {
            return ele.classList.contains(cls);
        },
        formatClass: function(clsArr) {
            var arr = [];
            clsArr.forEach(function(item) {
                if (item) {
                    if (item.indexOf(" ") >= 0) {
                        var _items = item.split(" ");
                        _items.forEach(function(_item) {
                            if (_item) {
                                arr.push(_item);
                            }
                        });
                    } else {
                        arr.push(item);
                    }
                }
            });
            return arr;
        }
    };
    if ($isIE) {
        $DomClass.add = function(ele) {
            var cnArr = ele.className.split(" ");
            $DomClass.formatClass($getArgsArray(arguments, 1)).forEach(function(cls) {
                if (cnArr.indexOf(cls) < 0) {
                    cnArr.push(cls);
                }
            });
            ele.className = cnArr.join(" ");
        };
        $DomClass.remove = function(ele) {
            var cnArr = ele.className.split(" ");
            var removeArr = $DomClass.formatClass($getArgsArray(arguments, 1));
            var nArr = $filterArray(cnArr, function(item) {
                return removeArr.indexOf(item) < 0;
            });
            ele.className = nArr.join(" ");
        };
        $DomClass.toggle = function(ele, cls, force) {
            var clsArr = $getArgsArray(arguments);
            var lastArg = arguments[arguments.length - 1];
            if ($isBoolean(lastArg)) {
                force = lastArg;
                clsArr.pop();
                if (force === true) {
                    $DomClass.add.apply($DomClass, clsArr);
                } else {
                    $DomClass.remove.apply($DomClass, clsArr);
                }
            } else {
                clsArr = $DomClass.formatClass(clsArr);
                clsArr.forEach(function(cls) {
                    if ($DomClass.contains(ele, cls)) {
                        $DomClass.remove(ele, cls);
                    } else {
                        $DomClass.add(ele, cls);
                    }
                });
            }
        };
        $DomClass.contains = function(ele, cls) {
            return ele.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)")) != null;
        };
    }
    var $domAddClass = $DomClass.add, $domRemoveClass = $DomClass.remove, $domSetClass = $DomClass.set, $domToggleClass = $DomClass.toggle, $domContainsClass = $DomClass.contains, $domFormatClass = $DomClass.formatClass;
    var $DomStyle = {
        setStyle: function(ele, style, value) {
            ele.style[style] = value;
        },
        setStyles: function(ele, styles, value) {
            if ($isObject(styles)) {
                $eachObject(styles, function(p, v) {
                    $DomStyle.setStyle(ele, $domFormatStyle(p), v);
                });
            } else {
                return $DomStyle.setStyle(ele, $domFormatStyle(styles), value);
            }
        },
        getStyle: function(ele, style) {
            return window.getComputedStyle(ele, null).getPropertyValue(style);
        },
        removeStyle: function(ele, style) {
            ele.style[style] = "";
        },
        formatStyle: function(style) {
            return style.replace(/([A-Z])/g, "-$1").toLowerCase();
        },
        parseStyle: function(styleStr, format) {
            var obj = {};
            styleStr.split(";").forEach(function(entry) {
                entry = entry.split(":");
                var key = entry.shift().trim();
                if (key !== "") {
                    if (format === true) {
                        key = $domFormatStyle(key);
                    }
                    obj[key] = entry.join(":").trim();
                }
            });
            return obj;
        }
    };
    var $domSetStyle = $DomStyle.setStyle, $domGetStyle = $DomStyle.getStyle, $domRemoveStyle = $DomStyle.removeStyle, $domFormatStyle = $DomStyle.formatStyle;
    var $DomValue = {
        __valueHooks: {
            multiple_select: {
                setValue: function(select, values) {
                    var options = select.options;
                    if (options.length === 0) {
                        return;
                    }
                    if (values == null) {
                        $eachArray(options, function(option) {
                            option.selected = false;
                        });
                    }
                    if (!$isArray(values)) {
                        values = [ values ];
                    }
                    $eachArray(options, function(option) {
                        var opt_value;
                        if (option.hasAttribute("value")) {
                            opt_value = option.value;
                        } else {
                            opt_value = option.text;
                        }
                        option.selected = values.indexOf(opt_value) >= 0;
                    });
                },
                getValue: function(select) {
                    var values = [];
                    $eachArray(select.options, function(option) {
                        if (option.selected === true) {
                            if (option.hasAttribute("value")) {
                                values.push(option.value);
                            } else {
                                values.push(option.text);
                            }
                        }
                    });
                    return values;
                }
            },
            radio: {
                setValue: function(radio, value) {
                    var name = radio.getAttribute("name");
                    if (name) {
                        $domQueryAll("input[type='radio'][name='" + name + "']").forEach(function(item) {
                            item.checked = item.value === value;
                        });
                    } else {
                        radio.checked = value === true;
                    }
                },
                getValue: function(radio) {
                    var name = radio.getAttribute("name");
                    if (name) {
                        var checked = $domQuery("input[type='radio'][name='" + name + "']:checked");
                        if (checked) {
                            return checked.value;
                        }
                        return null;
                    }
                    return radio.checked;
                }
            },
            file: {
                setValue: function(fileInput, value) {
                    fileInput.value = value;
                },
                getValue: function(fileInput) {
                    return fileInput.files;
                }
            },
            datetime_local: {
                setValue: function(fileInput, value) {
                    if (value == null) {
                        fileInput.value = null;
                    } else {
                        var time = new Date(value);
                        if (isNaN(time.getTime())) {
                            fileInput.value = null;
                            return;
                        }
                        var timezone = fileInput.getAttribute("data-timezone-offset");
                        if (timezone === "local") {
                            time.setMinutes(time.getMinutes() - time.getTimezoneOffset());
                        } else {
                            time.setMinutes(time.getMinutes() - timezone | 0);
                        }
                        fileInput.value = time.toISOString().slice(0, 16);
                    }
                },
                getValue: function(fileInput) {
                    return fileInput.value;
                }
            }
        },
        setValue: function(ele, value) {
            if (ele.setValue) {
                return ele.setValue(value);
            }
            var field = $DomValue.getValueField(ele);
            var sg = $DomValue.__valueHooks[field];
            if (sg) {
                return sg.setValue(ele, value);
            }
            return ele[field] = value;
        },
        getValue: function(ele) {
            if (ele.getValue) {
                return ele.getValue();
            }
            var field = $DomValue.getValueField(ele);
            var sg = $DomValue.__valueHooks[field];
            if (sg) {
                return sg.getValue(ele);
            }
            return ele[field];
        },
        getValueField: function(ele) {
            if ($DomType.isInput(ele)) {
                if ($DomType.isCheckBox(ele)) {
                    return "checked";
                }
                if ($DomType.isDatetimeLocalInput(ele)) {
                    return "datetime_local";
                }
                if ($DomType.isRadio(ele)) {
                    return "radio";
                }
                if ($DomType.isFileInput(ele)) {
                    return "file";
                }
                return "value";
            }
            if ($DomType.isSelect(ele)) {
                if ($DomType.isMultipleSelect(ele)) {
                    return "multiple_select";
                }
                return "value";
            }
            if ($DomType.isTextArea(ele)) {
                return "value";
            }
            if ($DomType.isImage(ele)) {
                return "src";
            }
            return "innerHTML";
        }
    };
    var $domGetValue = $DomValue.getValue, $domSetValue = $DomValue.setValue;
    var $DomType = {
        isTagType: function(ele, tag) {
            return ele.tagName === tag;
        },
        isInput: function(ele) {
            return $DomType.isTagType(ele, "INPUT");
        },
        isCheckBox: function(ele) {
            if ($DomType.isInput(ele)) {
                return $DomType.isAttributeType(ele, "CHECKBOX");
            }
            return false;
        },
        isRadio: function(ele) {
            if ($DomType.isInput(ele)) {
                return $DomType.isAttributeType(ele, "RADIO");
            }
            return false;
        },
        isFileInput: function(ele) {
            if ($DomType.isInput(ele)) {
                return $DomType.isAttributeType(ele, "FILE");
            }
            return false;
        },
        isDatetimeLocalInput: function(ele) {
            if ($DomType.isInput(ele)) {
                return $DomType.isAttributeType(ele, "DATETIME-LOCAL");
            }
            return false;
        },
        isTextArea: function(ele) {
            return $DomType.isTagType(ele, "TEXTAREA");
        },
        isSelect: function(ele) {
            return $DomType.isTagType(ele, "SELECT");
        },
        isMultipleSelect: function(ele) {
            if ($DomType.isSelect(ele)) {
                return ele.hasAttribute("multiple");
            }
            return false;
        },
        isImage: function(ele) {
            return $DomType.isTagType(ele, "IMG");
        },
        isElement: function(ele) {
            if (ele) {
                if (typeof ele === "object") {
                    return ele.nodeType === 1 && typeof ele.nodeName === "string" && ele.style != null && typeof ele.style === "object" && typeof ele.clientWidth === "number";
                }
            }
            return false;
        },
        isNode: function(ele) {
            if (ele) {
                if (typeof ele === "object") {
                    return ele.nodeType !== null && typeof ele.nodeName === "string";
                }
            }
            return false;
        },
        isAttributeType: function(ele, _type) {
            var type = ele.getAttribute("type");
            if (type) {
                return type.toUpperCase() === _type;
            }
            return false;
        }
    };
    var $domIsElement = $DomType.isElement, $domIsNode = $DomType.isNode, $domIsTagType = $DomType.isTagType;
    var $DomGeom = {
        getWindowPageOffset: function() {
            var docElem = document.documentElement;
            var scrollLeft = window.pageXOffset || docElem.scrollLeft || 0;
            var scrollTop = window.pageYOffset || docElem.scrollTop || 0;
            var clientLeft = docElem.clientLeft || 0;
            var clientTop = docElem.clientTop || 0;
            return {
                x: scrollLeft - clientLeft,
                y: scrollTop - clientTop
            };
        },
        getWindowSize: function() {
            var body = document.body;
            var docElem = document.documentElement;
            return {
                width: window.innerWidth || docElem.clientWidth || body.clientWidth,
                height: window.innerHeight || docElem.clientHeight || body.clientHeight
            };
        },
        getWindowPageBounds: function() {
            var offset = $DomGeom.getWindowPageOffset();
            var size = $DomGeom.getWindowSize();
            return {
                x: offset.x,
                y: offset.y,
                width: size.width,
                height: size.height
            };
        },
        getElementWindowOffset: function(ele) {
            var box = ele.getBoundingClientRect();
            return {
                x: box.left,
                y: box.top
            };
        },
        getElementPageOffset: function(ele) {
            var box = ele.getBoundingClientRect();
            var winOffset = $DomGeom.getWindowPageOffset();
            return {
                x: winOffset.x + box.left,
                y: winOffset.y + box.top
            };
        },
        getElementWindowBounds: function(ele) {
            var box = ele.getBoundingClientRect();
            return {
                x: box.left,
                y: box.top,
                width: box.width,
                height: box.height,
                left: box.left,
                top: box.top,
                right: box.right,
                bottom: box.bottom
            };
        },
        getEventWindowOffset: function(evt) {
            return {
                x: evt.clientX,
                y: evt.clientY
            };
        },
        getEventPageOffset: function(evt) {
            var pageX = evt.pageX;
            if (pageX == null) {
                var windowOffset = $DomGeom.getWindowPageOffset();
                return {
                    x: evt.clientX + windowOffset.x,
                    y: evt.clientY + windowOffset.y
                };
            } else {
                return {
                    x: pageX,
                    y: evt.pageY
                };
            }
        }
    };
    var $DomUtil = {
        create: function(tagName, props, childNodes) {
            var ele;
            if (/^<([A-z]+\d?)([^\d].*)?>(.*<\/\1>)?$/.test(tagName.trim())) {
                ele = $DomUtil._createByHtml(tagName);
            } else {
                ele = $createDomElement(tagName);
            }
            if (props != null) {
                if ($isObject(props)) {
                    var _className = props.className || props.class;
                    var _attributes = props.attributes;
                    var _style = props.style;
                    if (_className != null) {
                        ele.className = _className;
                    }
                    if (_style != null) {
                        $DomStyle.setStyles(ele, _style);
                    }
                    if (_attributes != null) {
                        $eachObject(_attributes, function(p, v) {
                            ele.setAttribute(p, v);
                        });
                    }
                } else {
                    ele.className = props;
                }
            }
            if (childNodes) {
                childNodes.forEach(function(child) {
                    ele.appendChild(child);
                });
            }
            return ele;
        },
        _createByHtml: function(html) {
            var tempParent = $createDomElement("div");
            tempParent.innerHTML = html.trim();
            var ele = tempParent.firstElementChild;
            ele.parentNode.removeChild(ele);
            return ele;
        },
        remove: function(ele) {
            var parentNode = ele.parentNode;
            if (parentNode) {
                parentNode.removeChild(ele);
            }
            return ele;
        },
        appendText: function(ele, text) {
            ele.appendChild(document.createTextNode(text));
        },
        empty: function(ele) {
            while (ele.lastChild) {
                ele.removeChild(ele.lastChild);
            }
        },
        scrollIntoView: function(ele, scrollView, gap) {
            gap = gap || 10;
            var eleOffsetTop = ele.offsetTop;
            var viewScrollTop = scrollView.scrollTop;
            var eleHeight = ele.offsetHeight;
            var viewPortHeight = scrollView.clientHeight;
            if (eleOffsetTop < viewScrollTop + gap) {
                scrollView.scrollTop = eleOffsetTop - gap;
            } else if (eleOffsetTop + eleHeight > viewScrollTop + viewPortHeight - gap) {
                scrollView.scrollTop = eleOffsetTop + eleHeight + gap - viewPortHeight;
            }
            var eleOffsetLeft = ele.offsetLeft;
            var viewScrollLeft = scrollView.scrollLeft;
            var eleWidth = ele.offsetWidth;
            var viewPortWidth = scrollView.clientWidth;
            if (eleOffsetLeft - gap < viewScrollLeft) {
                scrollView.scrollLeft = eleOffsetLeft - gap;
            } else if (eleOffsetLeft + eleWidth + gap > viewScrollLeft + viewPortWidth) {
                scrollView.scrollLeft = eleOffsetLeft + eleWidth + gap - viewPortWidth;
            }
        },
        isInDom: function(ele) {
            return document.contains(ele);
        },
        getAttributeSelector: function(attr, value) {
            if (arguments.length > 1) {
                return "[" + attr + "='" + value + "']";
            }
            return "[" + attr + "]";
        }
    };
    if (!document.contains) {
        $DomUtil.isInDom = function(ele) {
            return document.body.contains(ele);
        };
    }
    if (window.HTMLTemplateElement) {
        $DomUtil._createByHtml = function(html) {
            var tempParent = $createDomElement("template");
            tempParent.innerHTML = html.trim();
            var ele = tempParent.content.firstElementChild;
            ele.parentNode.removeChild(ele);
            return ele;
        };
    }
    var $domCreate = $DomUtil.create, $domRemove = $DomUtil.remove, $domEmpty = $DomUtil.empty, $domAppendText = $DomUtil.appendText, $isInDom = $DomUtil.isInDom, $domGetAttrSelector = $DomUtil.getAttributeSelector;
    var $DomEle = {
        initSelectOptions: function(selects, options, initOption) {
            var value_field, label_field, value, restore_value, children_filed, append;
            if ($isObject(initOption)) {
                value_field = initOption.value_field;
                label_field = initOption.label_field;
                value = initOption.value;
                restore_value = initOption.restore_value;
                children_filed = initOption.children_field;
                append = initOption.append;
            } else if ($isString(initOption)) {
                value_field = initOption;
            }
            children_filed = children_filed || "children";
            if ($isString(selects)) {
                selects = $domQueryAll(selects);
            } else if (!$isArray(selects)) {
                selects = [ selects ];
            }
            if (options == null) {
                options = [];
            } else if (!$isArray(options)) {
                options = [ options ];
            }
            selects.forEach(function(select) {
                select = $domQueryElement(select);
                if (!select) {
                    return;
                }
                var ov = $domGetValue(select);
                if (append !== true) {
                    $domEmpty(select);
                }
                options.forEach(function(item) {
                    if ($isObject(item)) {
                        if (item.hasOwnProperty(children_filed)) {
                            var optGroup = $DomEle._createSelectOptionGroup(select, item, label_field);
                            item.children.forEach(function(cItem) {
                                $DomEle._createSelectOption(optGroup, cItem, label_field, value_field);
                            });
                        } else {
                            $DomEle._createSelectOption(select, item, label_field, value_field);
                        }
                    } else {
                        $DomEle._createSelectOption(select, {
                            label: item
                        }, label_field, value_field);
                    }
                });
                if (value != null) {
                    $domSetValue(select, value);
                } else if (append !== true && restore_value !== false && ov !== "" && ov != null) {
                    var nv = $domGetValue(select);
                    $domSetValue(select, ov);
                    if ($domGetValue(select) === "") {
                        $domSetValue(select, nv);
                    }
                }
            });
        },
        _createSelectOptionGroup: function(select, item, label_field) {
            var optgroup = $domCreate("optgroup");
            var label;
            if (label_field) {
                label = item[label_field];
            } else {
                label = $DomEle._getValueByOrder(item, [ "label", "name" ], "");
            }
            optgroup.setAttribute("label", label);
            select.appendChild(optgroup);
            return optgroup;
        },
        _createSelectOption: function(parent, item, label_field, valueField) {
            if (!$isObject(item)) {
                item = {
                    label: item
                };
            }
            var option = $domCreate("option");
            var label;
            if (label_field) {
                label = item[label_field];
            } else {
                label = $DomEle._getValueByOrder(item, [ "label", "name" ], "");
            }
            var value;
            if (valueField) {
                value = item[valueField];
            } else {
                value = $DomEle._getValueByOrder(item, [ "value", "id" ]);
            }
            if (value != null) {
                option.setAttribute("value", value);
            }
            if (label == null) {
                label = value;
            }
            option.innerHTML = label;
            var attributes = item.attributes;
            if (attributes) {
                z.dom.setAttribute(option, attributes);
            }
            parent.appendChild(option);
        },
        _getValueByOrder: function(obj, keys, defaultValue) {
            var value = null;
            $eachArray(keys, function(key) {
                if (obj.hasOwnProperty(key)) {
                    value = obj[key];
                    return false;
                }
            });
            if (value == null) {
                return defaultValue;
            }
            return value;
        }
    };
    var $DomEventCommonModifier = {
        stop: function(evt) {
            evt.stopPropagation();
        },
        prevent: function(evt) {
            evt.preventDefault();
        },
        ctrl: function(evt) {
            return evt.ctrlKey === true;
        },
        shift: function(evt) {
            return evt.shiftKey === true;
        },
        alt: function(evt) {
            return evt.altKey === true;
        },
        meta: function(evt) {
            return evt.metaKey === true;
        },
        keyboardKey: function(evt, modifier) {
            return evt.key === modifier;
        }
    };
    var $DomEventModifier = {
        getModifierHandler: function(evtType, modifier, event) {
            if ($DomEventCommonModifier.hasOwnProperty(modifier)) {
                return $DomEventCommonModifier[modifier];
            }
            if (evtType === "keydown" || evtType === "keyup" || evtType === "keypress") {
                return $DomEventCommonModifier.keyboardKey;
            }
        }
    };
    var $DomEventUtil = {
        _wrapperList: [],
        addEventListener: function(ele, type, listener, thisArg) {
            var wrapper = $DomEventUtil._addWrapper(ele, type, listener, thisArg);
            ele.addEventListener(wrapper._event, wrapper._listener, false);
        },
        removeEventListener: function(ele, type, listener, thisArg) {
            var wrapper = $DomEventUtil._removeWrapper(ele, type, listener, thisArg);
            if (wrapper) {
                ele.removeEventListener(wrapper._event, wrapper._listener, false);
            }
        },
        addTypeEventListener: function(ele, type, listener, thisArg) {
            if (type === "resize") {
                return $DomResizeEventUtil.addResizeListener(ele, listener, thisArg);
            } else if (type === "wheel") {
                return $DomWheelEventUtil.addWheelListener(ele, listener, thisArg);
            }
            return $DomEventUtil.addEventListener(ele, type, listener, thisArg);
        },
        removeTypeEventListener: function(ele, type, listener, thisArg) {
            if (type === "resize") {
                return $DomResizeEventUtil.removeResizeListener(ele, listener, thisArg);
            } else if (type === "wheel") {
                return $DomWheelEventUtil.removeWheelListener(ele, listener, thisArg);
            }
            return $DomEventUtil.removeEventListener(ele, type, listener, thisArg);
        },
        getEventTarget: function(evt, selectors) {
            return evt.target.closest(selectors);
        },
        isPointerEvent: function(evt) {
            return $TypeCheck.isPrimitiveType(evt, "MouseEvent") || $TypeCheck.isPrimitiveType(evt, "Touch") || $TypeCheck.isPrimitiveType(evt, "PointerEvent");
        },
        isMouseMainButton: function(evt) {
            return evt.button === 0;
        },
        isMouseAuxiliaryButton: function(evt) {
            return evt.button === 1;
        },
        isMouseSecondaryButton: function(evt) {
            return evt.button === 2;
        },
        _addWrapper: function(ele, type, listener, thisArg) {
            var types = type.split(".");
            var _eventType = types[0];
            var _listener;
            if (types.length <= 1) {
                _listener = function(evt) {
                    listener.apply(thisArg, arguments);
                };
            } else {
                var modifiers = types.slice(1);
                _listener = function(evt) {
                    var match = true;
                    $eachArray(modifiers, function(modifier) {
                        var handler = $DomEventModifier.getModifierHandler(_eventType, modifier, evt);
                        if (handler && handler(evt, modifier) === false) {
                            match = false;
                            return false;
                        }
                    });
                    if (match === false) {
                        return;
                    }
                    listener.apply(thisArg, arguments);
                };
            }
            var wrapper = {
                element: ele,
                type: type,
                listener: listener,
                context: thisArg,
                _event: _eventType,
                _listener: _listener
            };
            $DomEventUtil._wrapperList.push(wrapper);
            return wrapper;
        },
        _removeWrapper: function(ele, type, listener, thisArg) {
            return $removeArrayItem($DomEventUtil._wrapperList, function(item, index) {
                return item.element === ele && item.type === type && item.listener === listener && item.context === thisArg;
            });
        }
    };
    var $domOn = $DomEventUtil.addEventListener;
    var $domOff = $DomEventUtil.removeEventListener;
    var $domTypeOn = $DomEventUtil.addTypeEventListener;
    var $domTypeOff = $DomEventUtil.removeTypeEventListener;
    var $DomReadyEventUtil = {
        _readyListeners: [],
        addReadyListener: function(listener, thisArg) {
            if ($DomReadyEventUtil._isDocumentReady()) {
                listener.apply(thisArg);
            } else {
                if ($DomReadyEventUtil._readyListeners.length === 0) {
                    $domOn(document, "DOMContentLoaded", $DomReadyEventUtil._handleReady);
                }
                $DomReadyEventUtil._readyListeners.push({
                    listener: listener,
                    context: thisArg
                });
            }
        },
        _handleReady: function(evt) {
            $callRAFLater(function() {
                $DomReadyEventUtil._readyListeners.forEach(function(item) {
                    item.listener.apply(item.context, [ evt ]);
                });
            });
        },
        _isDocumentReady: function() {
            var readyState = document.readyState;
            if (readyState === "complete") {
                return true;
            }
            if (!document.body) {
                return false;
            }
            return readyState === "interactive";
        }
    };
    var $DomResizeEventUtil = {
        _createResizeTrigger: function(ele) {
            var obj = $createDomElement("object");
            obj.__ze_resize_element__ = ele;
            ele.__ze_resize_trigger__ = obj;
            obj.setAttribute("style", "display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;opacity:0;pointer-events:none;z-index: -1;");
            obj.onload = $DomResizeEventUtil._handleObjLoad;
            obj.type = "text/html";
            $callRAFLater(function() {
                ele.insertBefore(obj, ele.firstChild);
                obj.data = "about:blank";
            });
            return obj;
        },
        _handleObjLoad: function(e) {
            var contentDocument = this.contentDocument;
            if (contentDocument && contentDocument.defaultView) {
                contentDocument.defaultView.__ze_resize_trigger__ = this.__ze_resize_element__;
                contentDocument.defaultView.addEventListener("resize", $DomResizeEventUtil._handleResize);
            }
        },
        _handleResize: function(evt) {
            var ele = evt.target || evt.srcElement;
            var trigger = ele.__ze_resize_trigger__;
            trigger.__ze_resize_listeners__.forEach(function(obj) {
                var listener = obj.listener;
                var context = obj.context;
                listener.apply(context, [ evt ]);
            });
        }
    };
    if (document.attachEvent) {
        $DomResizeEventUtil.addResizeListener = function(ele, listener, thisArg) {
            var handlers = ele.__ze_resize_listeners__;
            if (!handlers) {
                handlers = [];
                ele.__ze_resize_listeners__ = handlers;
                ele.__ze_resize_trigger__ = ele;
                ele.attachEvent("onresize", $DomResizeEventUtil._handleResize);
            }
            handlers.push({
                listener: listener,
                context: thisArg
            });
        };
        $DomResizeEventUtil.removeResizeListener = function(ele, listener, thisArg) {
            var handlers = ele.__ze_resize_listeners__;
            if (handlers) {
                $removeArrayItem(handlers, function(item) {
                    return item.listener === listener && item.context === thisArg;
                });
                if (handlers.length === 0) {
                    ele.detachEvent("onresize", $DomResizeEventUtil._handleResize);
                    delete ele.__ze_resize_listeners__;
                }
            }
        };
    } else {
        $DomResizeEventUtil.addResizeListener = function(ele, listener, thisArg) {
            var handlers = ele.__ze_resize_listeners__;
            if (!handlers) {
                handlers = [];
                ele.__ze_resize_listeners__ = handlers;
                if ($DomStyle.getStyle(ele, "position") === "static") {
                    $DomStyle.setStyle(ele, "position", "relative");
                }
                $DomResizeEventUtil._createResizeTrigger(ele);
            }
            handlers.push({
                listener: listener,
                context: thisArg
            });
        };
        $DomResizeEventUtil.removeResizeListener = function(ele, listener, thisArg) {
            var handlers = ele.__ze_resize_listeners__;
            if (handlers) {
                $removeArrayItem(handlers, function(item) {
                    return item.listener === listener && item.context === thisArg;
                });
                if (handlers.length === 0) {
                    var trigger = ele.__ze_resize_trigger__;
                    if (trigger) {
                        trigger.contentDocument.defaultView.removeEventListener("resize", $DomResizeEventUtil._handleResize);
                        ele.removeChild(trigger);
                        delete ele.__ze_resize_trigger__;
                    }
                    delete ele.__ze_resize_listeners__;
                }
            }
        };
    }
    var $wheelEvent = "onwheel" in $createDomElement("div") ? "wheel" : document.onmousewheel !== undefined ? "mousewheel" : "MozMousePixelScroll";
    var $DomWheelEventUtil = {
        addWheelListener: function(ele, listener, thisArg) {
            $domOn(ele, $wheelEvent, listener, thisArg);
        },
        removeWheelListener: function(ele, listener, thisArg) {
            $domOff(ele, $wheelEvent, listener, thisArg);
        },
        isWheelDown: function(evt) {
            return evt.wheelDelta < 0 || evt.deltaY > 0 || evt.detail > 0;
        }
    };
    var $DomClickEventUtil = {
        _clickListeners: [],
        addClickListener: function(listener, thisArg) {
            if ($DomClickEventUtil._clickListeners.length === 0) {
                $domOn(document, "click", $DomClickEventUtil._handleClick);
            }
            $DomClickEventUtil._clickListeners.push({
                listener: listener,
                context: thisArg
            });
        },
        removeClickListener: function(listener, thisArg) {
            $removeArrayItem($DomClickEventUtil._clickListeners, function(item) {
                return item.listener === listener && item.context === thisArg;
            });
            if ($DomClickEventUtil._clickListeners.length === 0) {
                $domOff(document, "click", $DomClickEventUtil._handleClick);
            }
        },
        _handleClick: function(evt) {
            $DomClickEventUtil._clickListeners.forEach(function(item) {
                item.listener.apply(item.context, [ evt ]);
            });
        }
    };
    var $TemplateEngine = {
        render: function(templateStr, vars, varRegExp) {
            var re = varRegExp || /<%(.+?)%>/;
            if (re.test(templateStr) === true) {
                re = new RegExp(re, "g");
                var reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g;
                var code = "with(obj) { var r=[];\n";
                var cursor = 0;
                var match;
                var add = function(line, js) {
                    js ? code += line.match(reExp) ? line + "\n" : "r.push(" + line + ");\n" : code += line !== "" ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : "";
                    return add;
                };
                while (match = re.exec(templateStr)) {
                    add(templateStr.slice(cursor, match.index))(match[1], true);
                    cursor = match.index + match[0].length;
                }
                add(templateStr.substr(cursor, templateStr.length - cursor));
                code = (code + 'return r.join(""); }').replace(/[\r\t\n]/g, " ");
                var result;
                try {
                    result = new Function("obj", code).apply(vars, [ vars ]);
                } catch (err) {
                    console.error("Template Engine error:'" + err.message + "'" + " in \n\nCode:\n" + code + "\n", null, "error");
                }
                return result;
            }
            return templateStr;
        }
    };
    var $renderTemplate = $TemplateEngine.render;
    $setSysDefault({
        AJAX_PROMISE: false,
        AJAX_TIMEOUT: 12e4,
        AJAX_VARIABLE_REGEXP: /{{(.+?)}}/,
        AJAX_HEADERS: {
            "X-Requested-With": "XMLHttpRequest"
        }
    });
    var $AjaxUtil = {
        get: function(url) {
            var args = $getArgsArray(arguments);
            args.unshift("GET");
            return $AjaxUtil.ajax.apply(null, args);
        },
        post: function(url) {
            var args = $getArgsArray(arguments);
            args.unshift("POST");
            return $AjaxUtil.ajax.apply(null, args);
        },
        ajax: function(method, url) {
            method = method.toUpperCase();
            var params = $AjaxUtil._getAjaxParams.apply(null, $getArgsArray(arguments, 2));
            var promise = window.Promise != null;
            if (promise) {
                if (params.hasOwnProperty("promise")) {
                    promise = params.promise === true;
                } else {
                    promise = $getDefault("AJAX_PROMISE") === true;
                }
            }
            if (promise) {
                return new Promise(function(resolve, reject) {
                    $AjaxUtil._request(method, url, params, resolve, reject);
                });
            } else {
                $AjaxUtil._request(method, url, params);
            }
        },
        _request: function(method, url, params, promiseResolve, promiseReject) {
            var data = params.data;
            var completeCB = params.complete, completeCBContext = params.context;
            var timeout = params.timeout || $getDefault("AJAX_TIMEOUT");
            var responseType = params.responseType;
            var headers = params.headers;
            var data_type = params.data_type;
            var async = params.async !== false;
            var vars = params.variables;
            var setupBeforeSendCB, setupCompleteCB;
            var glBeforeSend = $getDefault("AJAX_BEFORE_SEND");
            if ($isFunction(glBeforeSend)) {
                setupBeforeSendCB = glBeforeSend;
            }
            var glComplete = $getDefault("AJAX_COMPLETE");
            if ($isFunction(glComplete)) {
                setupCompleteCB = glComplete;
            }
            if (vars) {
                url = $StrUtil.replaceVars(url, vars, $getDefault("AJAX_VARIABLE_REGEXP"));
            }
            if (method === "GET" && data != null) {
                url = $URLUtil.appendURLSearchParam(url, data);
                data = null;
            }
            var setupHeaders = $mergeObject({}, $getDefault("AJAX_HEADERS"));
            if (data) {
                if ($isObject(data) || $isArray(data)) {
                    setupHeaders["Content-Type"] = "application/json; charset=utf-8";
                    data = JSON.stringify(data);
                } else if (method === "POST") {
                    setupHeaders["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
                }
            }
            var ready = false;
            var httpRequest = new XMLHttpRequest();
            if (async) {
                httpRequest.onreadystatechange = function() {
                    if (httpRequest.readyState === XMLHttpRequest.DONE) {
                        ready = true;
                        $AjaxUtil._callBack(httpRequest, data_type, completeCB, completeCBContext, promiseResolve, promiseReject);
                        if (setupCompleteCB) {
                            setupCompleteCB(httpRequest);
                        }
                    }
                };
            }
            if (responseType) {
                httpRequest.responseType = responseType;
            }
            httpRequest.open(method, url, async);
            $eachObject($mergeObject(setupHeaders, headers), function(key, value) {
                if (value !== false) {
                    httpRequest.setRequestHeader(key, value);
                }
            });
            if (setupBeforeSendCB) {
                setupBeforeSendCB(httpRequest);
            }
            httpRequest.send(data);
            if (async === false) {
                $AjaxUtil._callBack(httpRequest, data_type, completeCB, completeCBContext, promiseResolve, promiseReject);
                if (setupCompleteCB) {
                    setupCompleteCB(httpRequest);
                }
            } else {
                $callLater(function() {
                    if (ready === true) {
                        return;
                    }
                    if (httpRequest) {
                        httpRequest.onreadystatechange = null;
                        httpRequest.onerror = null;
                        httpRequest.onabort = null;
                    }
                    if (completeCB) {
                        completeCB.apply(completeCBContext, [ 408, null, httpRequest ]);
                    }
                    if (setupCompleteCB) {
                        setupCompleteCB(httpRequest, true);
                    }
                    if (promiseReject) {
                        promiseReject({
                            status: 408,
                            request: httpRequest
                        });
                    }
                    httpRequest = null;
                }, timeout);
            }
            return httpRequest;
        },
        _callBack: function(httpRequest, data_type, completeCallBack, context, resolve, reject) {
            var status = httpRequest.status;
            var success = status >= 200 && status < 300 || status === 304;
            var responseResult;
            if (!data_type) {
                var responseHeaderContentType = httpRequest.getResponseHeader("Content-Type");
                if (responseHeaderContentType && responseHeaderContentType.indexOf("json") >= 0) {
                    data_type = "JSON";
                }
            } else {
                data_type = data_type.trim().toUpperCase();
            }
            var responseType = httpRequest.responseType;
            if (data_type && (responseType === "" || responseType === "text")) {
                responseResult = httpRequest.responseText;
                if (data_type === "JSON") {
                    responseResult = JSON.parse(responseResult);
                }
            } else {
                responseResult = httpRequest.response;
            }
            if (completeCallBack) {
                completeCallBack.apply(context, [ status, responseResult, httpRequest ]);
            }
            if (success) {
                if (resolve) {
                    resolve({
                        status: status,
                        response: responseResult,
                        request: httpRequest
                    });
                }
            } else {
                if (reject) {
                    reject({
                        status: status,
                        response: responseResult,
                        request: httpRequest
                    });
                }
            }
        },
        _getAjaxParams: function() {
            var params;
            var argLen = arguments.length;
            if (argLen === 1) {
                params = arguments[0];
            } else if (argLen > 1) {
                params = $mergeObject({
                    data: arguments[0]
                }, arguments[1]);
            }
            if (!$isObject(params)) {
                return {};
            }
            return params;
        },
        setup: function(obj) {}
    };
    var $JSONPUtil = {
        jsonp: function(url) {
            var params = $AjaxUtil._getAjaxParams.apply(null, $getArgsArray(arguments, 1));
            var data = params.data;
            var completeCallBack = params.complete, context = params.context;
            var timeout = params.timeout || $getDefault("AJAX_TIMEOUT");
            if (data) {
                url = $URLUtil.appendURLSearchParam(url, data);
            }
            var callBack = "_z_jsonp_callback_" + Date.now();
            var ready = false;
            window[callBack] = function(result) {
                ready = true;
                delete window[callBack];
                completeCallBack.apply(context, [ false, true, result ]);
            };
            url = url + (/\?/.test(url) ? "&" : "?") + "callback=" + callBack;
            $JSONPUtil._loadJS(url);
            $callLater(function() {
                if (ready === true) {
                    return;
                }
                delete window[callBack];
                completeCallBack.apply(context, [ true ]);
            }, timeout);
        },
        _loadJS: function(src) {
            var node = $createDomElement("script");
            node.type = "text/javascript";
            node.onload = function() {
                node.onload = null;
                node.parentNode.removeChild(node);
            };
            node.onerror = function() {
                node.onerror = null;
                node.parentNode.removeChild(node);
            };
            var parent = $domQuery("head") || $domQuery("body");
            parent.appendChild(node);
            node.src = src;
        }
    };
    z.$ = {
        AjaxUtil: $AjaxUtil,
        JSONPUtil: $JSONPUtil,
        AnimationUtil: $AnimationUtil,
        AnimationTiming: $AnimationTiming,
        BrowserUtil: $BrowserUtil,
        CookieUtil: $CookieUtil,
        LocalStorageUtil: $LocalStorageUtil,
        SessionStorageUtil: $SessionStorageUtil,
        URLUtil: $URLUtil,
        ChangeSupport: $ChangeSupport,
        EventDispatcher: $EventDispatcher,
        ZObject: $ZObject,
        DomClass: $DomClass,
        DomEle: $DomEle,
        DomGeom: $DomGeom,
        DomQuery: $DomQuery,
        DomStyle: $DomStyle,
        DomType: $DomType,
        DomUtil: $DomUtil,
        DomValue: $DomValue,
        DomClickEventUtil: $DomClickEventUtil,
        DomEventUtil: $DomEventUtil,
        DomReadyEventUtil: $DomReadyEventUtil,
        DomResizeEventUtil: $DomResizeEventUtil,
        DomWheelEventUtil: $DomWheelEventUtil,
        TemplateEngine: $TemplateEngine,
        ImageUtil: $ImageUtil,
        MathConvexHullUtil: $MathConvexHullUtil,
        MathLineUtil: $MathLineUtil,
        MathPathUtil: $MathPathUtil,
        MathPointUtil: $MathPointUtil,
        MathRectUtil: $MathRectUtil,
        MathUtil: $MathUtil,
        ArrayMap: $ArrayMap,
        ArrayUtil: $ArrayUtil,
        ClassUtil: $ClassUtil,
        ColorUtil: $ColorUtil,
        Defaults: $Defaults,
        FuncUtil: $FuncUtil,
        I18nUtil: $I18nUtil,
        ObjectUtil: $ObjectUtil,
        PathUtil: $PathUtil,
        StrUtil: $StrUtil,
        TimerUtil: $TimerUtil,
        DateUtil: $DateUtil,
        TypeCheck: $TypeCheck,
        Util: $Util,
        setSysDefault: $setSysDefault
    };
    z.util = {
        isArray: $isArray,
        isString: $isString,
        isBoolean: $isBoolean,
        isObject: $isObject,
        isFunction: $isFunction,
        isNumber: $isNumber,
        mergeArray: $mergeArray,
        eachArray: $eachArray,
        filterArray: $filterArray,
        findArray: $findArray,
        removeArrayItem: $removeArrayItem,
        toArrayMap: $toArrayMap,
        mergeObject: $mergeObject,
        deepMergeObject: $deepMergeObject,
        eachObject: $eachObject,
        filterObject: $filterObject,
        getObjectDeepValue: $getObjectDeepValue,
        setObjectDeepValue: $setObjectDeepValue,
        getObjectValues: $getObjectValues,
        getObjectDeepKVMap: $ObjectUtil.getDeepKVMap,
        extendClass: $extendClass,
        newClass: $ClassUtil.newClass,
        exec: $Util.exec,
        formatDate: $DateUtil.format,
        callBatch: function(callBack, context, obj, batch_flag, reset_flag) {
            obj = obj || window;
            batch_flag = batch_flag || "_call_batch_flag";
            $callBatch(callBack, context, obj, batch_flag, reset_flag);
        },
        callLater: function(callBack, delay, context) {
            if (delay == null || delay <= 0) {
                delay = 20;
            }
            return $callLater(callBack, delay, context);
        },
        cancelCallLater: function(callBack, delay, context) {
            if (delay == null || delay <= 0) {
                delay = 20;
            }
            return $TimerUtil.cancelCallLater(callBack, delay, context);
        },
        callInterval: function(callBack, delay, context, immediately, onlyDomVisible) {
            if (delay == null || delay <= 0) {
                delay = 20;
            }
            return $callInterval(callBack, delay, context, immediately, onlyDomVisible);
        },
        cancelCallInterval: function(callBack, delay, context) {
            if (delay == null || delay <= 0) {
                delay = 20;
            }
            return $TimerUtil.cancelCallInterval(callBack, delay, context);
        },
        callRAFLater: $callRAFLater,
        callRAFInterval: $callRAFInterval,
        cancelCallRAFInterval: $TimerUtil.cancelCallRAFInterval,
        animate: $AnimationUtil.animate,
        cancelAnimate: $AnimationUtil.cancelAnimate,
        color: {
            toRGB: $ColorUtil.toRGB,
            toRGBA: $ColorUtil.toRGBA,
            toHSL: $ColorUtil.toHSL,
            toHSLA: $ColorUtil.toHSLA,
            toHex: $ColorUtil.toHex,
            toName: $ColorUtil.toName,
            lighten: $ColorUtil.lighten,
            darken: $ColorUtil.darken,
            saturate: $ColorUtil.saturate,
            desaturate: $ColorUtil.desaturate,
            random: $ColorUtil.random,
            defaults: $ColorUtil.defaults,
            mix: $ColorUtil.mix
        },
        image: {
            register: $ImageUtil.register,
            get: $ImageUtil.get,
            clear: $ImageUtil.clearCache
        }
    };
    z.type = {
        isArray: $isArray,
        isString: $isString,
        isBoolean: $isBoolean,
        isObject: $isObject,
        isFunction: $isFunction,
        isNumber: $isNumber
    };
    z.dom = {
        query: function(selectors, rootElement) {
            if (rootElement) {
                rootElement = $domQueryElement(rootElement);
                if (rootElement) {
                    return $domQueryElement(selectors, rootElement);
                }
                return null;
            }
            return $domQueryElement(selectors);
        },
        queryAll: function(selectors, rootElement) {
            if (rootElement) {
                rootElement = $domQueryElement(rootElement);
                if (rootElement) {
                    return $domQueryAll(selectors, rootElement);
                }
                return [];
            }
            return $domQueryAll(selectors);
        },
        nextElementSibling: function(ele) {
            return $domQueryElement(ele).nextElementSibling;
        },
        previousElementSibling: function(ele) {
            return $domQueryElement(ele).previousElementSibling;
        },
        addClass: function(ele, cls) {
            var args = $getArgsArray(arguments, 1);
            args.unshift($domQueryElement(ele));
            return $domAddClass.apply(null, args);
        },
        removeClass: function(ele, cls) {
            var args = $getArgsArray(arguments, 1);
            args.unshift($domQueryElement(ele));
            return $domRemoveClass.apply(null, args);
        },
        toggleClass: function(ele, cls, force) {
            var args = $getArgsArray(arguments, 1);
            args.unshift($domQueryElement(ele));
            return $domToggleClass.apply(null, args);
        },
        setClass: function(ele, cls) {
            var args = $getArgsArray(arguments, 1);
            args.unshift($domQueryElement(ele));
            return $domSetClass.apply(null, args);
        },
        containsClass: function(ele, cls) {
            ele = $domQueryElement(ele);
            return $domContainsClass(ele, cls);
        },
        setStyle: function(ele, style, value) {
            ele = $domQueryElement(ele);
            $DomStyle.setStyles(ele, style, value);
        },
        getStyle: function(ele, style) {
            return $domGetStyle($domQueryElement(ele), $domFormatStyle(style));
        },
        removeStyle: function(ele, style) {
            return $domRemoveStyle($domQueryElement(ele), $domFormatStyle(style));
        },
        setAttribute: function(ele, attr, value) {
            ele = $domQueryElement(ele);
            if ($isObject(attr)) {
                $eachObject(attr, function(p, v) {
                    ele.setAttribute(p, v);
                });
            } else {
                return ele.setAttribute(attr, value);
            }
        },
        getAttribute: function(ele, attr) {
            ele = $domQueryElement(ele);
            return ele.getAttribute(attr);
        },
        removeAttribute: function(ele, attr) {
            ele = $domQueryElement(ele);
            return ele.removeAttribute(attr);
        },
        hasAttribute: function(ele, attr) {
            ele = $domQueryElement(ele);
            return ele.hasAttribute(attr);
        },
        getAttributes: function(ele) {
            ele = $domQueryElement(ele);
            var attr = ele.attributes;
            var map = {};
            for (var i = attr.length - 1; i >= 0; i--) {
                var att = attr[i];
                map[att.name] = att.value;
            }
            return map;
        },
        setValue: function(ele, value) {
            ele = $domQueryElement(ele);
            return $DomValue.setValue(ele, value);
        },
        getValue: function(ele) {
            ele = $domQueryElement(ele);
            return $DomValue.getValue(ele);
        },
        isTagType: function(ele, tagName) {
            ele = $domQueryElement(ele);
            return $DomType.isTagType(ele, tagName.toUpperCase());
        },
        create: $domCreate,
        appendText: function(ele, text) {
            return $domAppendText($domQueryNode(ele), text);
        },
        remove: function(ele) {
            return $domRemove($domQueryNode(ele));
        },
        empty: function(ele) {
            return $domEmpty($domQueryNode(ele));
        },
        insertBefore: function(newNode, referenceNode) {
            newNode = $domQueryNode(newNode);
            referenceNode = $domQueryNode(referenceNode);
            referenceNode.parentNode.insertBefore(newNode, referenceNode);
            return newNode;
        },
        insertAfter: function(newNode, referenceNode) {
            newNode = $domQueryNode(newNode);
            referenceNode = $domQueryNode(referenceNode);
            referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
            return newNode;
        },
        insertFirst: function(newNode, parentNode) {
            newNode = $domQueryNode(newNode);
            parentNode = $domQueryNode(parentNode);
            parentNode.insertBefore(newNode, parentNode.firstChild);
            return newNode;
        },
        appendChild: function(newNode, parentNode) {
            newNode = $domQueryElement(newNode);
            parentNode = $domQueryElement(parentNode);
            parentNode.appendChild(newNode);
            return newNode;
        },
        focus: function(ele, focusOptions) {
            $callRAFLater(function() {
                $callLater(function() {
                    $domQueryElement(ele).focus(focusOptions);
                }, 60);
            });
        },
        initSelectOptions: $DomEle.initSelectOptions,
        event: {
            ready: $DomReadyEventUtil.addReadyListener,
            addEventListener: function(ele, type, listener, context) {
                return $domTypeOn($domQueryEventElement(ele), type, listener, context);
            },
            removeEventListener: function(ele, type, listener, context) {
                return $domTypeOff($domQueryEventElement(ele), type, listener, context);
            },
            on: function(ele, type, listener, context) {
                return $domTypeOn($domQueryEventElement(ele), type, listener, context);
            },
            off: function(ele, type, listener, context) {
                return $domTypeOff($domQueryEventElement(ele), type, listener, context);
            },
            onclick: function(ele, listener, context) {
                return $domOn($domQueryEventElement(ele), "click", listener, context);
            },
            onchange: function(ele, listener, context) {
                return $domOn($domQueryEventElement(ele), "change", listener, context);
            },
            onresize: function(ele, listener, context) {
                return $DomResizeEventUtil.addResizeListener($domQueryEventElement(ele), listener, context);
            },
            onwheel: function(ele, listener, context) {
                return $DomWheelEventUtil.addWheelListener($domQueryEventElement(ele), listener, context);
            },
            getTarget: function(evt, selectors) {
                return $DomEventUtil.getEventTarget(evt, selectors);
            }
        }
    };
    z.bom = {
        setCookie: $CookieUtil.setCookie,
        getCookie: $CookieUtil.getCookie,
        removeCookie: $CookieUtil.removeCookie,
        setLocalStorage: $LocalStorageUtil.setItem,
        getLocalStorage: $LocalStorageUtil.getItem,
        removeLocalStorage: $LocalStorageUtil.removeItem,
        clearLocalStorage: $LocalStorageUtil.clear,
        onstorage: $LocalStorageUtil.addChangeListener,
        setSessionStorage: $SessionStorageUtil.setItem,
        getSessionStorage: $SessionStorageUtil.getItem,
        removeSessionStorage: $SessionStorageUtil.removeItem,
        clearSessionStorage: $SessionStorageUtil.clear,
        getURLQuery: $URLUtil.getLocationSearchParam,
        getLocationSearchParam: $URLUtil.getLocationSearchParam,
        getURLSearchParam: $URLUtil.getURLSearchParam,
        appendURLSearchParam: $URLUtil.appendURLSearchParam,
        setURLSearchParam: $URLUtil.setURLSearchParam,
        getLocationHash: $URLUtil.getLocationHash,
        getURLHash: $URLUtil.getURLHash,
        browser: $BrowserUtil.browser,
        browserVersion: $BrowserUtil.version
    };
    z.ajax = {
        get: $AjaxUtil.get,
        post: $AjaxUtil.post,
        ajax: $AjaxUtil.ajax,
        jsonp: $JSONPUtil.jsonp
    };
    z.math = {
        toRadians: $MathUtil.toRadians,
        toDegrees: $MathUtil.toDegrees,
        calcDistance: $MathUtil.calcDistance,
        calcAngle: $MathUtil.calcAngle,
        calcPointOnCircle: $MathPointUtil.calcPointOnCircle,
        calcPointOnEllipse: $MathPointUtil.calcPointOnEllipse,
        calcRotatedPoint: $MathPointUtil.calcRotatedPoint,
        calcPointsBounds: $MathPointUtil.calcPointsBounds,
        calcPathLength: $MathPathUtil.calcPathLength,
        calcOffsetPointOnPath: $MathPathUtil.calcOffsetPointOnPath,
        createGrowRect: $MathRectUtil.createGrowRect
    };
    z.Defaults = $Defaults;
    z.setDefault = $setDefault;
    z.getDefault = $getDefault;
    z.ready = $DomReadyEventUtil.addReadyListener;
    z.i18n = $I18nUtil;
    z.ArrayMap = $ArrayMap;
    z.ZObject = $ZObject;
    var _z$ = window.z;
    z.noConflict = function() {
        if (window.z === z) {
            window.z = _z$;
        }
        return z;
    };
    window.z = z;
    $setSysDefault({
        CANVAS_2D_TEXT_NEWLINE: "\n",
        CANVAS_2D_TEXT_LINE_SPACING: 2,
        CANVAS_2D_TEXT_MULTILINE_ALIGN: "center"
    });
    var $I_CVS = $domCreate("canvas");
    $domSetStyle($I_CVS, "display", "block");
    var $I_CVS_2D = $I_CVS.getContext("2d");
    var $I_CVS_FONT_SPAN = $domCreate("span");
    $I_CVS_FONT_SPAN.innerHTML = "gM";
    var $C2DUtil = {
        getRenderStyle: function(style) {
            if (style == null) {
                return {};
            }
            var _style = {};
            var fillStyle = style.fillStyle || style.fill || style.fill_style;
            if (fillStyle) {
                _style.fillStyle = fillStyle;
            }
            var strokeStyle = style.strokeStyle || style.stroke || style.stroke_style;
            if (strokeStyle) {
                _style.strokeStyle = strokeStyle;
            }
            return _style;
        },
        isNoneRenderStyle: function(style) {
            return style.fillStyle == null && style.strokeStyle == null;
        },
        set2DAttribute: function(g2d, attr, value) {
            return $C2DUtil._set2DAttribute(g2d, attr, value);
        },
        set2DAttributes: function(g2d, attributes) {
            var changed = false;
            $eachObject(attributes, function(attr, value) {
                changed = $C2DUtil._set2DAttribute(g2d, attr, value) || changed;
            });
            return changed;
        },
        _set2DAttribute: function(g2d, attr, value, save) {
            if (attr === "lineDash") {
                return $C2DUtil._setLineDash(g2d, value, save);
            }
            if (g2d[attr] !== value) {
                if (save === true) {
                    g2d.save();
                }
                g2d[attr] = value;
                return true;
            }
            return false;
        },
        _setLineDash: function(g2d, value, save) {
            if (!$isArray(value)) {
                return false;
            }
            if (g2d.getLineDash().join(",") !== value.join(",")) {
                if (save === true) {
                    g2d.save();
                }
                g2d.setLineDash(value);
                return true;
            }
            return false;
        },
        saveAndSet2DAttribute: function(g2d, attr, value, callBack, context) {
            var saved = $C2DUtil._set2DAttribute(g2d, attr, value, true);
            if (callBack) {
                callBack.apply(context, [ g2d ]);
                if (saved === true) {
                    g2d.restore();
                    return false;
                }
            }
            return saved;
        },
        rotateAround: function(g2d, rotation, point, callBack, context) {
            if (rotation !== 0) {
                g2d.save();
                g2d.translate(point.x, point.y);
                g2d.rotate($mathToRadians(rotation));
                g2d.translate(-point.x, -point.y);
            }
            callBack.apply(context, [ g2d ]);
            if (rotation !== 0) {
                g2d.restore();
            }
        },
        saveAndSet2DAttributes: function(g2d, attributes, callBack, context) {
            var saved = false;
            if (attributes) {
                $eachObject(attributes, function(attr, value) {
                    saved = $C2DUtil._set2DAttribute(g2d, attr, value, !saved) || saved;
                });
            }
            if (callBack) {
                callBack.apply(context, [ g2d ]);
                if (saved === true) {
                    g2d.restore();
                    return false;
                }
            }
            return saved;
        },
        renderPath: function(g2d, style, callBack, closed) {
            var fillStyle = style.fillStyle;
            var strokeStyle = style.strokeStyle;
            var fs = fillStyle != null || strokeStyle != null;
            if (fs === true) {
                g2d.beginPath();
            }
            callBack.apply(null, [ g2d ]);
            if (fs === true) {
                if (closed !== true) {
                    g2d.closePath();
                }
                $saveAndSet2DAttributes(g2d, style, function() {
                    if (fillStyle != null) {
                        g2d.fill();
                    }
                    if (strokeStyle != null) {
                        g2d.stroke();
                    }
                });
            }
        },
        clear: function(cvs) {
            cvs.width = cvs.width + 0;
            return cvs;
        },
        ctxClear: function(ctx, width, height) {
            ctx.clearRect(0, 0, width, height);
            return ctx;
        },
        isOpaque: function(ctx, rect) {
            try {
                var imageData = ctx.getImageData(rect.x, rect.y, rect.width, rect.height);
                var pixs = imageData.data;
                for (var c = 0; c < imageData.width; c++) {
                    for (var r = 0; r < imageData.height; r++) {
                        var index = 4 * (r * imageData.width + c);
                        var a = pixs[index + 3];
                        if (a !== 0) {
                            return "yes";
                        }
                    }
                }
            } catch (e) {
                return "error";
            }
            return "no";
        },
        getRoundRectRadii: function(rect, radii) {
            var arr;
            if ($isArray(radii)) {
                var len = radii.length;
                if (len > 0) {
                    var r0 = radii[0];
                    var r1 = radii[1];
                    var r2 = radii[2];
                    var r3 = radii[3];
                    if (len === 1) {
                        arr = [ r0, r0, r0, r0 ];
                    } else if (len === 2) {
                        arr = [ r0, r1, r0, r1 ];
                    } else if (len === 3) {
                        arr = [ r0, r1, r2, r1 ];
                    } else {
                        arr = [ r0, r1, r2, r3 ];
                    }
                }
            } else {
                radii = parseFloat(radii);
                arr = [ radii, radii, radii, radii ];
            }
            if (arr) {
                return [ $C2DUtil._getRoundRectRadius(rect, arr[0]), $C2DUtil._getRoundRectRadius(rect, arr[1]), $C2DUtil._getRoundRectRadius(rect, arr[2]), $C2DUtil._getRoundRectRadius(rect, arr[3]) ];
            }
            return arr;
        },
        _getRoundRectRadius: function(rect, radii) {
            if (radii <= 0) {
                return 0;
            }
            var minSize = $MathMin(rect.width, rect.height);
            if (radii < 1) {
                radii = radii * minSize;
            }
            return $MathMin(radii, minSize / 2);
        }
    };
    var $setCanvas2DAttribute = $C2DUtil.set2DAttribute, $setCanvas2DAttributes = $C2DUtil.set2DAttributes, $saveAndSet2DAttributes = $C2DUtil.saveAndSet2DAttributes, $canvasRotateAround = $C2DUtil.rotateAround, $canvasRenderPath = $C2DUtil.renderPath;
    var $C2DAlphaUtil = {
        _resetAlphaCanvas: function() {
            $C2DAlphaUtil._alpha_cvs = null;
        },
        _getAlphaCanvas: function(w, h) {
            var cvs = $C2DAlphaUtil._alpha_cvs;
            if (cvs == null) {
                cvs = $domCreate("canvas");
                $C2DAlphaUtil._alpha_cvs = cvs;
            }
            $C2DUtil.clear(cvs);
            return cvs;
        },
        _getAlphaC2d: function(w, h) {
            var cvs = this._getAlphaCanvas();
            cvs.width = w;
            cvs.height = h;
            var c2d = cvs.getContext("2d", {
                willReadFrequently: true
            });
            c2d.restore();
            c2d.save();
            return c2d;
        },
        isDrawRectOpaque: function(draw, rect) {
            var ctx = $C2DAlphaUtil._getAlphaC2d(rect.width, rect.height);
            ctx.translate(-rect.x, -rect.y);
            var drawRect = {
                x: 0,
                y: 0,
                width: rect.width,
                height: rect.height
            };
            draw(ctx);
            var isOpa = $C2DUtil.isOpaque(ctx, drawRect);
            if (isOpa === "error") {
                $C2DAlphaUtil._resetAlphaCanvas();
            }
            return isOpa === "yes";
        }
    };
    var $C2DGradientUtil = {
        createRectDirectionLinearGradient: function(rect, direction, colorStops) {
            var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
            var rectAngle = $MathUtil.calcAngle({
                x: x,
                y: y
            }, {
                x: x + w,
                y: y + h
            });
            var angle;
            switch (direction) {
                case "lt_to_rb":
                    angle = rectAngle;
                    break;

                case "t_to_b":
                    angle = 90;
                    break;

                case "rt_to_lb":
                    angle = $180 - rectAngle;
                    break;

                case "r_to_l":
                    angle = $180;
                    break;

                case "rb_to_lt":
                    angle = $180 + rectAngle;
                    break;

                case "b_to_t":
                    angle = 270;
                    break;

                case "lb_to_rt":
                    angle = 360 - rectAngle;
                    break;

                default:
                    angle = 0;
            }
            return $C2DGradientUtil.createRectLinearGradient(rect, angle, colorStops);
        },
        createRectLinearGradient: function(rect, angle, colorStops) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var center = {
                x: x + width / 2,
                y: y + height / 2
            };
            var points = $MathLineUtil.calcRectLineIntersection(rect, center, $MathPointUtil.calcPointOnCircle(center, $MathMax(width, height), angle), false);
            var startPoint = points[0], endPoint = points[1];
            return $C2DGradientUtil.createLinearGradient(startPoint, endPoint, colorStops);
        },
        createLinearGradient: function(startPoint, endPoint, colorStops) {
            var gradient = $I_CVS_2D.createLinearGradient(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
            $eachObject(colorStops || {}, function(offset, color) {
                gradient.addColorStop(offset, color);
            });
            return gradient;
        },
        createRectDirectionRadialGradient: function(rect, direction, colorStops) {
            return $C2DGradientUtil.createRectRadialGradient(rect, $C2DGradientUtil._getRectDirectionGradientCenter(rect, direction), colorStops);
        },
        createRectRadialGradient: function(rect, center, colorStops) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var radius = $MathMax($mathCalcDistance(center, {
                x: x,
                y: y
            }), $mathCalcDistance(center, {
                x: x + width,
                y: y
            }), $mathCalcDistance(center, {
                x: x + width,
                y: y + height
            }), $mathCalcDistance(center, {
                x: x,
                y: y + height
            }));
            return $C2DGradientUtil.createRadialGradient(center, 0, center, radius, colorStops);
        },
        createRadialGradient: function(startCircleCenter, startCircleRadius, endCircleCenter, endCircleRadius, colorStops) {
            var gradient = $I_CVS_2D.createRadialGradient(startCircleCenter.x, startCircleCenter.y, startCircleRadius, endCircleCenter.x, endCircleCenter.y, endCircleRadius);
            $eachObject(colorStops || {}, function(offset, color) {
                gradient.addColorStop(offset, color);
            });
            return gradient;
        },
        createRectConicGradient: function(rect, colorStops, startAngle) {
            return $C2DGradientUtil.createConicGradient($MathRectUtil.getRectCenter(rect), colorStops, startAngle);
        },
        createConicGradient: function(center, colorStops, startAngle) {
            if (startAngle == null) {
                startAngle = 0;
            }
            var gradient = $I_CVS_2D.createConicGradient(startAngle, center.x, center.y);
            $eachObject(colorStops || {}, function(offset, color) {
                gradient.addColorStop(offset, color);
            });
            return gradient;
        },
        _getRectDirectionGradientCenter: function(rect, direction) {
            var x = rect.x, y = rect.y, w = rect.width, h = rect.height;
            var center;
            switch (direction) {
                case "lt_to_rb":
                    center = {
                        x: x,
                        y: y
                    };
                    break;

                case "t_to_b":
                    center = {
                        x: x + w / 2,
                        y: y
                    };
                    break;

                case "rt_to_lb":
                    center = {
                        x: x + w,
                        y: y
                    };
                    break;

                case "r_to_l":
                    center = {
                        x: x + w,
                        y: y + h / 2
                    };
                    break;

                case "rb_to_lt":
                    center = {
                        x: x + w,
                        y: y + h
                    };
                    break;

                case "b_to_t":
                    center = {
                        x: x + w / 2,
                        y: y + h
                    };
                    break;

                case "lb_to_rt":
                    center = {
                        x: x,
                        y: y + h
                    };
                    break;

                case "l_to_r":
                    center = {
                        x: x,
                        y: y + h / 2
                    };
                    break;

                default:
                    center = {
                        x: x + w / 2,
                        y: y + h / 2
                    };
            }
            return center;
        }
    };
    if (!$I_CVS_2D.createConicGradient) {
        $C2DGradientUtil.createConicGradient = function(center, colorStops, startAngle) {
            return null;
        };
    }
    var $C2DPathUtil = {
        path: function(g2d, points) {
            var count = points.length;
            if (count < 1) {
                return;
            }
            var point = points[0];
            g2d.moveTo(point.x, point.y);
            var lastSeg = point.seg;
            for (var i = 1; i < count; i++) {
                point = points[i];
                if (lastSeg != null) {
                    if ($PathUtil.isMoveTo(lastSeg)) {
                        g2d.moveTo(point.x, point.y);
                    } else if ($PathUtil.isQuadraticCurveTo(lastSeg)) {
                        if (i < count - 1) {
                            var cpx = point.x;
                            var cpy = point.y;
                            point = points[++i];
                            g2d.quadraticCurveTo(cpx, cpy, point.x, point.y);
                        } else {
                            g2d.lineTo(point.x, point.y);
                        }
                    } else if ($PathUtil.isBezierCurveTo(lastSeg)) {
                        if (i < count - 2) {
                            var cp1x = point.x, cp1y = point.y;
                            point = points[++i];
                            var cp2x = point.x, cp2y = point.y;
                            point = points[++i];
                            g2d.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, point.x, point.y);
                        } else {
                            g2d.lineTo(point.x, point.y);
                        }
                    }
                } else {
                    g2d.lineTo(point.x, point.y);
                }
                lastSeg = point.seg;
                if ($PathUtil.isClose(lastSeg)) {
                    lastSeg = point.next_seg;
                    g2d.closePath();
                }
            }
        },
        render: function(g2d, points, style, noneStyleRender) {
            style = $C2DUtil.getRenderStyle(style);
            if (noneStyleRender !== true && $C2DUtil.isNoneRenderStyle(style)) {
                return;
            }
            var count = points.length;
            if (count < 1) {
                return;
            }
            var fillStyle = style.fillStyle;
            $canvasRenderPath(g2d, style, function() {
                $C2DPathUtil.path(g2d, points);
                if (count > 2 && fillStyle != null) {
                    var point = points[count - 1];
                    if (!$PathUtil.isClose(point.seg)) {
                        g2d.closePath();
                    }
                }
            }, true);
        }
    };
    var $canvasPath = $C2DPathUtil.path;
    var $C2DPatternUtil = {
        createPattern: function(image) {
            if ($isString(image)) {
                image = $ImageUtil.get(image);
            }
            if (image) {
                return $I_CVS_2D.createPattern(image, "repeat");
            }
        }
    };
    var $C2DRectShapeUtil = {
        _custom_shapes: {},
        register: function(name, drawShapeFunc) {
            $C2DRectShapeUtil._custom_shapes[name] = drawShapeFunc;
        },
        render: function(g2d, rect, shape, style, option, noneStyleRender) {
            style = $C2DUtil.getRenderStyle(style);
            if (noneStyleRender !== true && $C2DUtil.isNoneRenderStyle(style)) {
                return;
            }
            $canvasRenderPath(g2d, style, function() {
                $C2DRectShapeUtil.rectShape(g2d, rect, shape, option);
            }, true);
        },
        rectShape: function(g2d, rect, shape, config) {
            if ($C2DRectShapeUtil._custom_shapes.hasOwnProperty(shape)) {
                return $C2DRectShapeUtil._custom_shapes[shape](g2d, rect);
            }
            switch (shape) {
                case "rect":
                    $C2DRectShapeUtil.rect(g2d, rect);
                    break;

                case "circle":
                    $C2DRectShapeUtil.circle(g2d, rect);
                    break;

                case "ellipse":
                    $C2DRectShapeUtil.ellipse(g2d, rect);
                    break;

                case "roundrect":
                    var radius = 0;
                    if (config) {
                        radius = config.radius || 0;
                    }
                    $C2DRectShapeUtil.roundRect(g2d, rect, config.radius || 0);
                    break;

                case "triangle":
                    $C2DRectShapeUtil.triangle(g2d, rect);
                    break;

                case "right_triangle":
                    $C2DRectShapeUtil.rightTriangle(g2d, rect);
                    break;

                case "diamond":
                    $C2DRectShapeUtil.diamond(g2d, rect);
                    break;

                case "pentagon":
                    $C2DRectShapeUtil.pentagon(g2d, rect);
                    break;

                case "hexagon":
                    $C2DRectShapeUtil.hexagon(g2d, rect);
                    break;

                case "star":
                    $C2DRectShapeUtil.star(g2d, rect);
                    break;

                case "parallelogram":
                    $C2DRectShapeUtil.parallelogram(g2d, rect);
                    break;

                case "cloud":
                    $C2DRectShapeUtil.cloud(g2d, rect);
                    break;
            }
        },
        cloud: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var cx = x + width / 2, cy = y + height / 2;
            var bw = 60, bh = 40;
            var bl = $MathMin(height / bh, width / bw);
            width = bl * bw;
            height = bl * bh;
            x = cx - width / 2;
            y = cy - height / 2;
            var gap = 0;
            var p1 = {
                x: 51 * bl + x,
                y: 18 * bl + y
            };
            var p2 = {
                x: 60 * bl + x - gap,
                y: 30 * bl + y
            };
            var p3 = {
                x: 50 * bl + x,
                y: 40 * bl + y - gap
            };
            var center = $MathPointUtil.calc3PointsCircleCenter(p1, p2, p3);
            var radius = $mathCalcDistance(center, p1);
            g2d.moveTo(p1.x, p1.y);
            $C2DRectShapeUtil.arc(g2d, {
                x: center.x - radius,
                y: center.y - radius,
                width: radius * 2,
                height: radius * 2
            }, $mathCalcAngle(center, p1), $mathCalcAngle(center, p3));
            p1 = {
                x: 9 * bl + x,
                y: 40 * bl + y - gap
            };
            g2d.lineTo(p1.x, p1.y);
            p2 = {
                x: 0 * bl + x + gap,
                y: 30 * bl + y
            };
            p3 = {
                x: 9 * bl + x,
                y: 16 * bl + y
            };
            center = $MathPointUtil.calc3PointsCircleCenter(p1, p2, p3);
            radius = $mathCalcDistance(center, p1);
            $C2DRectShapeUtil.arc(g2d, {
                x: center.x - radius,
                y: center.y - radius,
                width: radius * 2,
                height: radius * 2
            }, $mathCalcAngle(center, p1), $mathCalcAngle(center, p3));
            p1 = {
                x: 22 * bl + x,
                y: 10 * bl + y
            };
            p2 = {
                x: 11 * bl + x,
                y: 11 * bl + y
            };
            center = $MathPointUtil.calc3PointsCircleCenter(p1, p2, p3);
            radius = $mathCalcDistance(center, p1);
            $C2DRectShapeUtil.arc(g2d, {
                x: center.x - radius,
                y: center.y - radius,
                width: radius * 2,
                height: radius * 2
            }, $mathCalcAngle(center, p3), $mathCalcAngle(center, p1));
            p2 = {
                x: 38 * bl + x,
                y: 0 * bl + y + gap
            };
            p3 = {
                x: 51 * bl + x,
                y: 18 * bl + y
            };
            center = $MathPointUtil.calc3PointsCircleCenter(p1, p2, p3);
            radius = $mathCalcDistance(center, p1);
            $C2DRectShapeUtil.arc(g2d, {
                x: center.x - radius,
                y: center.y - radius,
                width: radius * 2,
                height: radius * 2
            }, $mathCalcAngle(center, p1), $mathCalcAngle(center, p3));
            g2d.closePath();
        },
        arc: function(g2d, rect, start, end) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var radius = $MathMin(width / 2, height / 2);
            g2d.save();
            g2d.translate(x + width / 2, y + height / 2);
            if (width !== height) {
                var sx = width / (radius * 2);
                var sy = height / (radius * 2);
                g2d.scale(sx, sy);
            }
            g2d.arc(0, 0, radius, $mathToRadians(start), $mathToRadians(end), false);
            g2d.restore();
        },
        rect: function(g2d, rect) {
            g2d.rect(rect.x, rect.y, rect.width, rect.height);
        },
        circle: function(g2d, rect) {
            var half_width = rect.width / 2, half_height = rect.height / 2;
            var cx = rect.x + half_width, cy = rect.y + half_height, radius = $MathMin(half_width, half_height);
            g2d.moveTo(cx + radius, cy);
            g2d.arc(cx, cy, radius, 0, 2 * $MathPI, false);
            g2d.closePath();
        },
        triangle: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            $canvasPath(g2d, [ {
                x: x + width / 2,
                y: y
            }, {
                x: x + width,
                y: y + height
            }, {
                x: x,
                y: y + height
            } ]);
            g2d.closePath();
        },
        rightTriangle: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            $canvasPath(g2d, [ {
                x: x,
                y: y
            }, {
                x: x,
                y: y + height
            }, {
                x: x + width,
                y: y + height
            } ]);
            g2d.closePath();
        },
        diamond: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            $canvasPath(g2d, [ {
                x: x + width / 2,
                y: y
            }, {
                x: x + width,
                y: y + height / 2
            }, {
                x: x + width / 2,
                y: y + height
            }, {
                x: x,
                y: y + height / 2
            } ]);
            g2d.closePath();
        },
        pentagon: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var cx = x + width / 2, cy = y + height / 2;
            $canvasPath(g2d, [ {
                x: cx,
                y: y
            }, {
                x: cx + width / 2,
                y: cy - height / 6
            }, {
                x: cx + width / 3,
                y: cy + height / 2
            }, {
                x: cx - width / 3,
                y: cy + height / 2
            }, {
                x: cx - width / 2,
                y: cy - height / 6
            } ]);
            g2d.closePath();
        },
        hexagon: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            $canvasPath(g2d, [ {
                x: x + width / 4,
                y: y
            }, {
                x: x + width * 3 / 4,
                y: y
            }, {
                x: x + width,
                y: y + height / 2
            }, {
                x: x + width * 3 / 4,
                y: y + height
            }, {
                x: x + width / 4,
                y: y + height
            }, {
                x: x,
                y: y + height / 2
            } ]);
            g2d.closePath();
        },
        star: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            var cx = x + width / 2, cy = y + height / 2;
            $canvasPath(g2d, [ {
                x: x + width * .388,
                y: y + height * .332
            }, {
                x: cx + 0,
                y: cy - height / 2
            }, {
                x: x + width * .611,
                y: y + height * .332
            }, {
                x: cx + width / 2,
                y: cy - height / 6
            }, {
                x: x + width * .693,
                y: y + height * .579
            }, {
                x: cx + width / 3,
                y: cy + height / 2
            }, {
                x: x + width / 2,
                y: y + height * .733
            }, {
                x: cx - width / 3,
                y: cy + height / 2
            }, {
                x: x + width * .306,
                y: y + height * .579
            }, {
                x: cx - width / 2,
                y: cy - height / 6
            } ]);
            g2d.closePath();
        },
        parallelogram: function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            $canvasPath(g2d, [ {
                x: x,
                y: y + height
            }, {
                x: x + width / 4,
                y: y
            }, {
                x: x + width,
                y: y
            }, {
                x: x + width * 3 / 4,
                y: y + height
            } ]);
            g2d.closePath();
        }
    };
    if ($I_CVS_2D.ellipse) {
        $C2DRectShapeUtil.ellipse = function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, half_width = width / 2, half_height = rect.height / 2;
            if (half_width === half_height) {
                $C2DRectShapeUtil.circle(g2d, rect);
                return;
            }
            var cx = x + half_width, cy = y + half_height;
            g2d.moveTo(x + width, cy);
            g2d.ellipse(cx, cy, half_width, half_height, 0, $mathToRadians(360), false);
        };
    } else {
        $C2DRectShapeUtil.ellipse = function(g2d, rect) {
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            if (width === height) {
                $C2DRectShapeUtil.circle(g2d, rect);
                return;
            }
            var cx = x + width / 2;
            var cy = y + height / 2;
            var radius = $MathMin(width / 2, height / 2);
            var sx = width / (radius * 2);
            var sy = height / (radius * 2);
            g2d.moveTo(x + width, cy);
            g2d.save();
            g2d.translate(cx, cy);
            g2d.scale(sx, sy);
            g2d.arc(0, 0, radius, 0, 2 * $MathPI, false);
            g2d.restore();
            g2d.closePath();
        };
    }
    if ($I_CVS_2D.roundRect) {
        $C2DRectShapeUtil.roundRect = function(g2d, rect, radius) {
            radius = $C2DUtil.getRoundRectRadii(rect, radius);
            if (!radius) {
                return $C2DRectShapeUtil.rect(g2d, rect);
            }
            g2d.roundRect(rect.x, rect.y, rect.width, rect.height, radius);
        };
    } else {
        $C2DRectShapeUtil.roundRect = function(g2d, rect, radius) {
            radius = $C2DUtil.getRoundRectRadii(rect, radius);
            if (!radius) {
                return $C2DRectShapeUtil.rect(g2d, rect);
            }
            var x = rect.x, y = rect.y, width = rect.width, height = rect.height;
            g2d.moveTo(x + radius[0], y);
            g2d.lineTo(x + width - radius[1], y);
            g2d.quadraticCurveTo(x + width, y, x + width, y + radius[1]);
            g2d.lineTo(x + width, y + height - radius[2]);
            g2d.quadraticCurveTo(x + width, y + height, x + width - radius[2], y + height);
            g2d.lineTo(x + radius[3], y + height);
            g2d.quadraticCurveTo(x, y + height, x, y + height - radius[3]);
            g2d.lineTo(x, y + radius[0]);
            g2d.quadraticCurveTo(x, y, x + radius[0], y);
            g2d.closePath();
        };
    }
    var $C2DTextUtil = {
        _fontHeightMap: {},
        _textSizeMap: {},
        _defaultRenderConfig: {
            h_direction: "center",
            v_direction: "middle",
            wrap_text_align: "left"
        },
        render: function(g2d, text, point, style, direction, option) {
            if (text == null) {
                return;
            }
            text = text + "";
            direction = direction || "center";
            style = $C2DUtil.getRenderStyle(style);
            if ($C2DUtil.isNoneRenderStyle(style)) {
                return;
            }
            option = $mergeObject({
                newline: $getDefault("CANVAS_2D_TEXT_NEWLINE"),
                line_spacing: $getDefault("CANVAS_2D_TEXT_LINE_SPACING"),
                align: $getDefault("CANVAS_2D_TEXT_MULTILINE_ALIGN")
            }, option);
            $canvasRotateAround(g2d, option.rotation | 0, point, function() {
                if (text.indexOf(option.newline) > -1) {
                    $C2DTextUtil._renderMText(g2d, text, point, direction, style, option);
                } else {
                    var alignOpt = $C2DTextUtil._getTextAlign(direction);
                    $saveAndSet2DAttributes(g2d, $C2DTextUtil._getTextAttr(alignOpt.textAlign, alignOpt.textBaseline, option.font, style), function() {
                        if (style.fillStyle) {
                            g2d.fillText(text, point.x, point.y);
                        }
                        if (style.strokeStyle) {
                            g2d.strokeText(text, point.x, point.y);
                        }
                    });
                }
            });
        },
        _renderMText: function(g2d, text, point, direction, style, option) {
            text = text + "";
            var font = option.font;
            var text_size = option.text_size;
            var lineHeight, textWidth;
            if (text_size) {
                lineHeight = text_size.font_height;
                textWidth = text_size.width;
            }
            if (lineHeight == null) {
                lineHeight = $C2DTextUtil.calcFontHeight(font);
            }
            if (textWidth == null) {
                textWidth = $C2DTextUtil.calcTextWidth(font, text);
            }
            var lineSpacing = option.line_spacing | 0;
            var textArr = text.split($getDefault("CANVAS_2D_TEXT_NEWLINE"));
            var textRow = textArr.length;
            var px = point.x, py = point.y;
            var text_align = option.align;
            var hv = $C2DTextUtil._getHVDirection(direction);
            var h_direction = hv.horizontal, v_direction = hv.vertical;
            var topY;
            if (v_direction === "top") {
                topY = py - (textRow * lineHeight + lineSpacing * (textRow - 1));
            } else if (v_direction === "bottom") {
                topY = py;
            } else {
                var hf = $MathFloor(textRow / 2);
                var isEven = textRow % 2 === 0;
                if (isEven) {
                    topY = py - (hf * lineHeight + (hf - 1) * lineSpacing + lineSpacing / 2);
                } else {
                    topY = py - (hf * lineHeight + lineHeight / 2 + hf * lineSpacing);
                }
            }
            if (h_direction === "left") {
                if (text_align === "left") {
                    px = px - textWidth;
                } else if (text_align === "right") {} else {
                    px = px - textWidth / 2;
                }
            } else if (h_direction === "right") {
                if (text_align === "left") {} else if (text_align === "right") {
                    px = px + textWidth;
                } else {
                    px = px + textWidth / 2;
                }
            } else {
                if (text_align === "left") {
                    px = px - textWidth / 2;
                } else if (text_align === "right") {
                    px = px + textWidth / 2;
                } else {}
            }
            $saveAndSet2DAttributes(g2d, $C2DTextUtil._getTextAttr(text_align, "top", font, style), function() {
                var rowIndex = 0;
                if (style.strokeStyle) {
                    for (rowIndex = 0; rowIndex < textRow; rowIndex++) {
                        g2d.strokeText(textArr[rowIndex], px, topY + (lineHeight + lineSpacing) * rowIndex);
                    }
                }
                if (style.fillStyle) {
                    for (rowIndex = 0; rowIndex < textRow; rowIndex++) {
                        g2d.fillText(textArr[rowIndex], px, topY + (lineHeight + lineSpacing) * rowIndex);
                    }
                }
            });
        },
        _getTextAttr: function(textAlign, textBaseline, font, style) {
            var attr = {};
            if (textAlign) {
                attr.textAlign = textAlign;
            }
            if (textBaseline) {
                attr.textBaseline = textBaseline;
            }
            if (font) {
                attr.font = font;
            }
            if (style.fillStyle) {
                attr.fillStyle = style.fillStyle;
            }
            if (style.strokeStyle) {
                attr.strokeStyle = style.strokeStyle;
            }
            return attr;
        },
        calcFontHeight: function(font) {
            var height;
            if ($C2DTextUtil._fontHeightMap.hasOwnProperty(font)) {
                height = $C2DTextUtil._fontHeightMap[font];
            } else {
                height = $C2DTextUtil._calcFontHeight(font);
                $C2DTextUtil._fontHeightMap[font] = height;
            }
            return height;
        },
        calcTextSize: function(font, text, lineSpacing) {
            text = text + "";
            var cacheKey = [ font, text, lineSpacing ].join("$");
            if ($C2DTextUtil._textSizeMap.hasOwnProperty(cacheKey)) {
                return $C2DTextUtil._textSizeMap[cacheKey];
            }
            var fontHeight = $C2DTextUtil.calcFontHeight(font);
            var textHeight;
            var c2d_text_newline = $getDefault("CANVAS_2D_TEXT_NEWLINE");
            var isWrap = text.indexOf(c2d_text_newline) !== -1;
            if (isWrap === true) {
                var textArr = text.split(c2d_text_newline);
                var textRow = textArr.length;
                if (lineSpacing >= 0) {
                    lineSpacing = +lineSpacing;
                } else {
                    lineSpacing = $getDefault("CANVAS_2D_TEXT_LINE_SPACING");
                }
                textHeight = fontHeight * textRow + (textRow - 1) * lineSpacing;
            } else {
                textHeight = fontHeight;
            }
            var size = {
                width: $C2DTextUtil.calcTextWidth(font, text),
                height: textHeight,
                font_height: fontHeight
            };
            $C2DTextUtil._textSizeMap[cacheKey] = size;
            return size;
        },
        calcTextWidth: function(font, text) {
            if (text == null) {
                return 0;
            }
            var width = 0;
            var c2d_text_newline = $getDefault("CANVAS_2D_TEXT_NEWLINE");
            var isWrap = text.indexOf(c2d_text_newline) !== -1;
            $setCanvas2DAttribute($I_CVS_2D, "font", font);
            if (isWrap === true) {
                var textArr = text.split(c2d_text_newline);
                textArr.forEach(function(txt) {
                    width = $MathMax(width, $I_CVS_2D.measureText(txt).width);
                });
            } else {
                width = $I_CVS_2D.measureText(text).width;
            }
            return width;
        },
        getSystemFont: function() {
            if ($C2DTextUtil._systemFont != null) {
                return $C2DTextUtil._systemFont;
            }
            if (document.body) {
                var bodyStyles = window.getComputedStyle(document.body, null);
                if (bodyStyles) {
                    var sysFont = bodyStyles["font"];
                    if (!sysFont) {
                        sysFont = bodyStyles["font-style"] + " " + bodyStyles["font-variant"] + " " + bodyStyles["font-weight"] + " " + bodyStyles["font-size"] + "/" + bodyStyles["line-height"] + " " + bodyStyles["font-family"];
                    }
                    if (sysFont) {
                        $C2DTextUtil._systemFont = sysFont;
                        return sysFont;
                    }
                }
            }
            return "10px sans-serif";
        },
        _calcFontHeight: function(font) {
            $domSetStyle($I_CVS_FONT_SPAN, "font", font);
            document.body.appendChild($I_CVS_FONT_SPAN);
            var height = $I_CVS_FONT_SPAN.offsetHeight;
            document.body.removeChild($I_CVS_FONT_SPAN);
            return height;
        },
        _getTextAlign: function(direction) {
            var textAlign, textBaseline;
            if (direction.startsWith("left")) {
                textAlign = "right";
            } else if (direction.startsWith("right")) {
                textAlign = "left";
            } else {
                textAlign = "center";
            }
            if (direction.endsWith("top")) {
                textBaseline = "bottom";
            } else if (direction.endsWith("bottom")) {
                textBaseline = "top";
            } else {
                textBaseline = "middle";
            }
            return {
                textAlign: textAlign,
                textBaseline: textBaseline
            };
        },
        _getHVDirection: function(direction) {
            var horizontal, vertical;
            if (direction.startsWith("left")) {
                horizontal = "left";
            } else if (direction.startsWith("right")) {
                horizontal = "right";
            } else {
                horizontal = "center";
            }
            if (direction.endsWith("top")) {
                vertical = "top";
            } else if (direction.endsWith("bottom")) {
                vertical = "bottom";
            } else {
                vertical = "middle";
            }
            return {
                horizontal: horizontal,
                vertical: vertical
            };
        }
    };
    $mergeObject(z.$, {
        canvas: {
            C2DAlphaUtil: $C2DAlphaUtil,
            C2DGradientUtil: $C2DGradientUtil,
            C2DPathUtil: $C2DPathUtil,
            C2DPatternUtil: $C2DPatternUtil,
            C2DRectShapeUtil: $C2DRectShapeUtil,
            C2DTextUtil: $C2DTextUtil,
            C2DUtil: $C2DUtil
        }
    });
    z.canvas2d = {
        clear: function(cvs) {
            $C2DUtil.clear($domQueryElement(cvs));
        },
        renderText: $C2DTextUtil.render,
        renderShape: $C2DRectShapeUtil.render,
        registerShape: $C2DRectShapeUtil.register,
        path: $canvasPath,
        renderPath: $C2DPathUtil.render
    };
    $setSysDefault({
        VIEW_LABEL_FIELD: "name",
        VIEW_INFO_FIELD: "info"
    });
    var $ModelTypeCheck = {
        isIModel: function(obj) {
            if (obj != null && obj.__toTypeString_Model_$) {
                return obj.__toTypeString_Model_$() === $TypeConst.MODEL;
            }
            return false;
        },
        _isIModelType: function(obj, type, typeValue) {
            if ($ModelTypeCheck.isIModel(obj)) {
                var method = "__toTypeString_" + type + "_$";
                var fun = obj[method];
                if (fun) {
                    return fun.apply(obj) === typeValue;
                }
            }
            return false;
        },
        isData: function(obj) {
            return $ModelTypeCheck._isIModelType(obj, "Data", $TypeConst.DATA);
        },
        isView: function(obj) {
            return $ModelTypeCheck._isIModelType(obj, "View", $TypeConst.VIEW);
        },
        isProvider: function(obj) {
            return $ModelTypeCheck._isIModelType(obj, "Provider", $TypeConst.PROVIDER);
        }
    };
    var $isData = $ModelTypeCheck.isData;
    var $isView = $ModelTypeCheck.isView;
    var $isProvider = $ModelTypeCheck.isProvider;
    var $DataLevelUtil = {
        isParentSettable: function(childData, parentData) {
            if (childData === parentData) {
                return false;
            }
            return !$DataLevelUtil.isDescendantOf(parentData, childData);
        },
        getDataRoot: function(data) {
            var parent = data.getProperty("parent");
            while (parent) {
                data = parent;
                parent = data.getProperty("parent");
            }
            return data;
        },
        isDescendantOf: function(data, otherData) {
            var parent = data.getProperty("parent");
            while (parent) {
                if (otherData === parent) {
                    return true;
                } else {
                    parent = parent.getProperty("parent");
                }
            }
            return false;
        },
        getAncestorArray: function(data, rootData) {
            var aArray = [];
            var parent = data.getProperty("parent");
            while (parent) {
                aArray.push(parent);
                if (rootData === parent) {
                    return aArray;
                }
                parent = parent.getProperty("parent");
            }
            return aArray;
        },
        getAddedDescendantArray: function(provider, data) {
            var dArray = [];
            $DataLevelUtil._getAddedDescendantArray(dArray, provider, data);
            return dArray;
        },
        _getAddedDescendantArray: function(dArray, provider, data) {
            var children = $DataLevelUtil.getAddedChildren(provider, data);
            if (children.length > 0) {
                $mergeArray(dArray, children);
                children.forEach(function(child) {
                    $DataLevelUtil._getAddedDescendantArray(dArray, provider, child);
                });
            }
        },
        getAddedChildren: function(provider, data) {
            return $filterArray(data.getChildren(false), provider.contains, provider);
        },
        getAddedSiblingArray: function(provider, data) {
            var parent = data.getProperty("parent");
            if (parent) {
                return $filterArray(parent.getChildren(false), provider.contains, provider);
            }
            return provider.toRootArray(false);
        },
        isAncestorAdded: function(provider, data) {
            var array = $DataLevelUtil.getAncestorArray(data);
            if (array.length === 0) {
                return true;
            }
            var added = true;
            array.forEach(function(parent) {
                if (!provider.contains(parent)) {
                    added = false;
                }
            });
            return added;
        }
    };
    var $HTMLDataParser = {
        parse: function(rootEle, isLevel, attrConverter, dataKeywordMapping) {
            var dataArr = $HTMLDataParser.parseToObjectArray(rootEle, isLevel, attrConverter);
            return $JSONDataParser.parse(dataArr, dataKeywordMapping);
        },
        parseToObjectArray: function(rootEle, isLevel, attrConverter) {
            var dataArr;
            if (isLevel === true) {
                dataArr = $HTMLDataParser._parseLevelHTMLData(rootEle);
            } else {
                dataArr = $HTMLDataParser._parseListHTMLData(rootEle);
            }
            if ($isFunction(attrConverter)) {
                dataArr.forEach(function(item) {
                    $HTMLDataParser._convertItemAttr(item, attrConverter);
                });
            }
            return dataArr;
        },
        _convertItemAttr: function(item, attrConverter) {
            $eachObject(item, function(prop, value) {
                item[prop] = attrConverter(prop, value);
            });
            var children = item.children;
            if (children) {
                children.forEach(function(childItem) {
                    $HTMLDataParser._convertItemAttr(childItem, attrConverter);
                });
            }
        },
        parseAttributes: function(element, attrMap) {
            var eleAttributes = element.attributes;
            var attrCount = eleAttributes.length;
            for (var i = 0; i < attrCount; i++) {
                var attr = eleAttributes[i];
                var nodeName = attr.nodeName;
                if (nodeName !== "style" && nodeName !== "class") {
                    attrMap[nodeName] = attr.nodeValue;
                }
            }
            return attrMap;
        },
        _parseListHTMLData: function(viewEle) {
            var dataList = [];
            var childList = viewEle.children;
            var childCount = childList.length;
            for (var i = 0; i < childCount; i++) {
                var childEle = childList[i];
                var childObj = {
                    tag: childEle.tagName
                };
                $HTMLDataParser.parseAttributes(childEle, childObj);
                $HTMLDataParser.parseTemplate(childEle, childObj);
                if (childObj.content_type === "text") {
                    $HTMLDataParser._parseTextContent(childEle, childObj);
                } else {
                    $HTMLDataParser._parseElementContent(childEle, childObj);
                }
                dataList.push(childObj);
            }
            return dataList;
        },
        parseTemplate: function(element, object) {
            var templateEle = $domQuery("zw-template", element);
            if (templateEle) {
                object.template = $HTMLDataParser._htmlDecode(templateEle.innerHTML);
                $domRemove(templateEle);
            }
            return templateEle;
        },
        _htmlDecode: function(str) {
            return String(str).replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        },
        _getChildren: function(ele) {
            var childList = ele.children;
            if (childList.length === 1) {
                var first = childList[0];
                if ($DomType.isTagType(first, "UL") || $DomType.isTagType(first, "OL")) {
                    childList = first.children;
                }
            }
            return childList;
        },
        _parseLevelHTMLData: function(viewEle) {
            var dataList = [];
            var childList = $HTMLDataParser._getChildren(viewEle);
            var childCount = childList.length;
            for (var i = 0; i < childCount; i++) {
                var childEle = childList[i];
                var item = {
                    tag: childEle.tagName
                };
                $HTMLDataParser.parseAttributes(childEle, item);
                $HTMLDataParser.parseTemplate(childEle, item);
                $HTMLDataParser._parseElementChildren(childEle, item);
                dataList.push(item);
            }
            return dataList;
        },
        _parseElementChildren: function(element, item) {
            var childList = $HTMLDataParser._getChildren(element);
            var childCount = childList.length;
            if (childCount === 0) {
                $HTMLDataParser._parseTextContent(element, item);
            } else {
                var children = [];
                for (var i = 0; i < childCount; i++) {
                    var childEle = childList[i];
                    var childItem = {
                        tag: childEle.tagName
                    };
                    $HTMLDataParser.parseAttributes(childEle, childItem);
                    $HTMLDataParser.parseTemplate(childEle, childItem);
                    $HTMLDataParser._parseElementChildren(childEle, childItem);
                    children.push(childItem);
                }
                item.children = children;
            }
        },
        _parseTextContent: function(ele, obj, eleContent) {
            var textContent = ele.textContent.trim();
            if (textContent) {
                if (!obj.hasOwnProperty("content")) {
                    obj.content = ele.innerHTML;
                }
                if (!obj.hasOwnProperty("name")) {
                    obj.name = textContent;
                }
            }
            return obj;
        },
        _parseElementContent: function(ele, obj) {
            var innerHTML = ele.innerHTML;
            var str = innerHTML.trim();
            if (str) {
                if (!obj.hasOwnProperty("content")) {
                    var children = $mergeArray([], ele.children);
                    if (children.length > 0) {
                        var contentDiv = $domCreate("div", "element_content");
                        $eachArray(children, function(ele) {
                            contentDiv.appendChild(ele);
                        });
                        obj.content = {
                            type: "element",
                            content: contentDiv
                        };
                    } else {
                        obj.content = innerHTML;
                    }
                }
                if (!obj.hasOwnProperty("name")) {
                    obj.name = str;
                }
            }
        }
    };
    var $JSONDataParser = {
        parse: function(dataArray, dataKeywordMapping, existingDataArray) {
            dataKeywordMapping = $mergeObject({
                clazz: "clazz",
                parent: "parent",
                children: "children",
                link_from: "link_from",
                link_to: "link_to"
            }, dataKeywordMapping);
            var clazzKey = dataKeywordMapping.clazz, parentKey = dataKeywordMapping.parent, childrenKey = dataKeywordMapping.children, linkFromKey = dataKeywordMapping.link_from, linkToKey = dataKeywordMapping.link_to, idKey = dataKeywordMapping.id;
            var keywords = [ clazzKey, parentKey, childrenKey, linkFromKey, linkToKey ];
            var _clazzKey = "_z_" + clazzKey, _parentKey = "_z_" + parentKey, _childrenKey = "_z_" + childrenKey;
            var resultArray = [];
            dataArray.forEach(function(item) {
                if ($isData(item)) {
                    resultArray.push(item);
                } else if ($isObject(item)) {
                    $JSONDataParser._createItemData($JSONDataParser._replaceKeyword(item, keywords, childrenKey), resultArray, _clazzKey, _childrenKey);
                } else if ($isString(item)) {
                    $JSONDataParser._createItemData({
                        name: item
                    }, resultArray, _clazzKey, _childrenKey);
                }
            });
            var idMap = {};
            var idDataArray;
            if (existingDataArray) {
                idDataArray = $mergeArray([], existingDataArray, resultArray);
            } else {
                idDataArray = resultArray;
            }
            if (idKey) {
                idDataArray.forEach(function(data) {
                    if (data.hasProperty(idKey)) {
                        idMap[data.getProperty(idKey)] = data;
                    }
                });
            } else {
                [ "name", "id" ].forEach(function(key) {
                    idDataArray.forEach(function(data) {
                        if (data.hasProperty(key)) {
                            idMap[data.getProperty(key)] = data;
                        }
                    });
                });
            }
            resultArray.forEach(function(data) {
                var parentProp = data.getProperty(_parentKey);
                if (parentProp) {
                    var parentData;
                    if ($isData(parentProp)) {
                        parentData = parentProp;
                    } else {
                        parentData = idMap[parentProp];
                    }
                    if (parentData) {
                        data.set("parent", parentData);
                    }
                }
            });
            keywords = [ "_z_" + clazzKey, "_z_" + parentKey, "_z_" + childrenKey, "_z_" + linkFromKey, "_z_" + linkToKey ];
            resultArray.forEach(function(data) {
                keywords.forEach(data.removeProperty, data);
            });
            return resultArray;
        },
        _replaceKeyword: function(item, replaceProps, childrenKey) {
            var dataValues = {};
            var noDataValues = {};
            $eachObject(item, function(key, value) {
                if ($isData(value)) {
                    dataValues[key] = value;
                } else {
                    noDataValues[key] = value;
                }
            });
            var _item = $deepMergeObject({}, noDataValues);
            _item = $mergeObject(_item, dataValues);
            var children = _item[childrenKey];
            if ($isArray(children)) {
                var _children = [];
                children.forEach(function(child) {
                    if ($isObject(child)) {
                        _children.push($JSONDataParser._replaceKeyword(child, replaceProps, childrenKey));
                    } else if ($isString(child)) {
                        _children.push({
                            name: child
                        });
                    }
                });
                _item[childrenKey] = _children;
            }
            replaceProps.forEach(function(prop) {
                if (_item.hasOwnProperty(prop)) {
                    _item["_z_" + prop] = _item[prop];
                    delete _item[prop];
                }
            });
            _item["_$z_data"] = item;
            return _item;
        },
        _createItemData: function(item, array, clazzKey, childrenKey, parentData) {
            var clazz = item[clazzKey] || $Data;
            var data = $ClassUtil.createInstance(clazz, [ item ]);
            if (parentData) {
                data.set("parent", parentData);
            }
            array.push(data);
            var children = item[childrenKey];
            if ($isArray(children)) {
                children.forEach(function(childItem) {
                    $JSONDataParser._createItemData(childItem, array, clazzKey, childrenKey, data);
                });
            }
        }
    };
    var $ArgsUtil = {
        getSingleObjectArg: function(args, key) {
            if (args.length === 1) {
                var arg0 = args[0];
                if ($isObject(arg0)) {
                    return arg0[key];
                }
            }
        }
    };
    var $getSingleObjectArg = $ArgsUtil.getSingleObjectArg;
    var $IModel = function() {
        $IModel.superClass.constructor.apply(this, arguments);
    };
    $extendClass($IModel, $ChangeSupport, {
        __toTypeString_Model_$: function() {
            return $TypeConst.MODEL;
        }
    });
    var $Data = function(props) {
        if (!(this instanceof $Data)) {
            return $ClassUtil.createInstance($Data, arguments);
        }
        this._childArrayMap = new $ArrayMap();
        $Data.superClass.constructor.apply(this, arguments);
    };
    $extendClass($Data, $IModel, {
        ___zsg: [ "parent" ],
        ___zdefaults_: {
            parent: undefined,
            name: undefined,
            icon: undefined
        },
        __toTypeString_Data_$: function() {
            return $TypeConst.DATA;
        },
        isPropertyValid: function(key, parent, oldParent) {
            if (key === "parent") {
                if (this.__pcrChanging === true) {
                    return false;
                }
                if (parent) {
                    if (!$isData(parent)) {
                        return false;
                    }
                    if (!$DataLevelUtil.isParentSettable(this, parent)) {
                        return false;
                    }
                }
            }
            return $Data.superClass.isPropertyValid.apply(this, arguments);
        },
        beforeSetProperty: function(key, parent, oldParent) {
            if (key === "parent") {
                this.__pcrChanging = true;
                if (oldParent) {
                    oldParent.removeChild(this);
                }
            }
            $Data.superClass.beforeSetProperty.apply(this, arguments);
        },
        afterSetProperty: function(key, parent, oldParent) {
            if (key === "parent") {
                if (parent) {
                    parent.addChild(this);
                }
                this.__pcrChanging = false;
            }
            $Data.superClass.afterSetProperty.apply(this, arguments);
        },
        addChild: function(child) {
            if (this.__pcrChanging === true) {
                return;
            }
            if (!$isData(child)) {
                return;
            }
            if (this.isParentOf(child)) {
                return;
            }
            if (!$DataLevelUtil.isParentSettable(child, this)) {
                return;
            }
            this.__pcrChanging = true;
            this._childArrayMap.add(child.id(), child);
            child.setProperty("parent", this);
            this.__pcrChanging = false;
            this.dispatchChangeEvent("children", child, undefined);
        },
        removeChild: function(child) {
            if (this.__pcrChanging === true) {
                return;
            }
            if (!$isData(child)) {
                return;
            }
            if (!this.isParentOf(child)) {
                return;
            }
            this.__pcrChanging = true;
            this._childArrayMap.remove(child.id());
            child.removeProperty("parent");
            this.__pcrChanging = false;
            this.dispatchChangeEvent("children", null, child);
        },
        clearChildren: function() {
            this.__pcrChanging = true;
            var list = this._childArrayMap.toArray();
            list.forEach(function(data) {
                data.removeProperty("parent");
            });
            this._childArrayMap.clear();
            this.__pcrChanging = false;
            this.dispatchChangeEvent("children", this._childArrayMap.toArray(), list);
        },
        getChildren: function(copy) {
            return this._childArrayMap.toArray(copy);
        },
        isParentOf: function(child) {
            return this._childArrayMap.has(child.id());
        },
        hasChildren: function() {
            return this._childArrayMap.size() > 0;
        },
        eachChildren: function(callBack, context) {
            this._childArrayMap.eachArray(callBack, context);
        },
        clone: function(filter, newProps) {
            var props = this.getProperties(false);
            var cloneProps = {};
            if ($isFunction(filter)) {
                $eachObject(props, function(p, v) {
                    if (filter(p, v) !== false) {
                        cloneProps[p] = v;
                    }
                });
            } else if ($isObject(filter)) {
                $eachObject(props, function(p, v) {
                    if (filter[p] !== false) {
                        cloneProps[p] = v;
                    }
                });
            } else {
                cloneProps = $mergeObject(cloneProps, props);
            }
            return $ClassUtil.createInstance(this.constructor, [ $mergeObject(cloneProps, newProps) ]);
        },
        _getAttachedDataArray: function() {
            return this._childArrayMap.toArray(false);
        }
    });
    var $IProvider = function() {
        this._dataArrayMap = new $ArrayMap();
        var args;
        var dataArray;
        if ($isArray(arguments[0])) {
            dataArray = arguments[0];
            args = $getArgsArray(arguments, 1);
        } else {
            args = arguments;
        }
        $IProvider.superClass.constructor.apply(this, args);
        if (dataArray) {
            dataArray.forEach(this.add, this);
        }
    };
    $extendClass($IProvider, $IModel, {
        __toTypeString_Provider_$: function() {
            return $TypeConst.PROVIDER;
        },
        add: function(data, index) {
            var argLen = arguments.length;
            if ($isArray(data)) {
                if (argLen > 1) {
                    data.forEach(function(_data, dIndex) {
                        this.add(_data, index + dIndex);
                    }, this);
                } else {
                    data.forEach(function(_data) {
                        this.add(_data);
                    }, this);
                }
                return;
            }
            if (!$isData(data)) {
                $Util.throwError("Only z.Data instance is allowed");
            }
            if (this.isAddable(data) !== true || this.contains(data)) {
                return;
            }
            if (argLen > 1) {
                this._dataArrayMap.add(data.id(), data, index);
                this._onAdd(data, index);
            } else {
                this._dataArrayMap.add(data.id(), data);
                this._onAdd(data);
            }
            this.dispatchProviderChangeEvent("add", data);
        },
        _onAdd: function(data) {},
        isAddable: function(data) {
            return true;
        },
        remove: function(data) {
            if (this.contains(data)) {
                this._dataArrayMap.remove(data.id());
                this._onRemove(data);
                this.dispatchProviderChangeEvent("remove", data);
            }
        },
        _onRemove: function(data) {},
        clear: function() {
            if (this._dataArrayMap.size() > 0) {
                var dataArray = this._dataArrayMap.toArray();
                this._dataArrayMap.clear();
                this._onClear(dataArray);
                this.dispatchProviderChangeEvent("clear", dataArray);
            }
        },
        _onClear: function(dataArray) {},
        contains: function(data) {
            return this._dataArrayMap.has(data.id());
        },
        find: function(prop, value) {
            if ($isObject(prop)) {
                return this._dataArrayMap.findArray(function(data) {
                    var match = true;
                    $eachObject(prop, function(key, value) {
                        if (data.getProperty(key) !== value) {
                            match = false;
                            return false;
                        }
                    });
                    return match;
                });
            }
            if ($isFunction(prop)) {
                return this._dataArrayMap.findArray.apply(this._dataArrayMap, arguments);
            }
            var aLen = arguments.length;
            if (aLen === 1) {
                return this._dataArrayMap.findArray(function(data) {
                    return data.hasProperty(prop);
                });
            } else if (aLen >= 2) {
                return this._dataArrayMap.findArray(function(data) {
                    return data.getProperty(prop) === value;
                });
            }
            return undefined;
        },
        filter: function(prop, value) {
            if ($isObject(prop)) {
                return this._dataArrayMap.filterArray(function(data) {
                    var match = true;
                    $eachObject(function(key, value) {
                        if (data.getProperty(key) !== value) {
                            match = false;
                            return false;
                        }
                    });
                    return match;
                });
            }
            if ($isFunction(prop)) {
                return this._dataArrayMap.filterArray.apply(this._dataArrayMap, arguments);
            }
            var aLen = arguments.length;
            if (aLen === 1) {
                return this._dataArrayMap.filterArray(function(data) {
                    return data.hasProperty(prop);
                });
            } else if (aLen >= 2) {
                return this._dataArrayMap.filterArray(function(data) {
                    return data.getProperty(prop) === value;
                });
            }
            return [];
        },
        toArray: function(copy) {
            return this._dataArrayMap.toArray(copy);
        },
        size: function() {
            return this._dataArrayMap.size();
        },
        each: function(callBack, context) {
            this._dataArrayMap.eachArray(callBack, context);
        },
        addProviderChangeListener: function(listener, context) {
            this.addListener("provider.change", listener, context);
        },
        removeProviderChangeListener: function(listener, context) {
            this.removeListener("provider.change", listener, context);
        },
        dispatchProviderChangeEvent: function(type, data, info) {
            this.dispatchEvent("provider.change", {
                type: type,
                data: data,
                info: info
            });
        }
    });
    var $Provider = function() {
        this._rootArrayMap = new $ArrayMap();
        $Provider.superClass.constructor.apply(this, arguments);
    };
    $extendClass($Provider, $IProvider, {
        _onAdd: function(data) {
            if (data.getProperty("parent") == null) {
                this._rootArrayMap.add(data.id(), data);
            }
            data.addChangeListener(this._handleDataChange, this);
        },
        _onRemove: function(data) {
            var attachedArray = data._getAttachedDataArray();
            if (attachedArray) {
                attachedArray.forEach(this.remove, this);
            }
            if (data.getProperty("parent") == null) {
                this._rootArrayMap.remove(data.id());
            }
            data.removeChangeListener(this._handleDataChange, this);
        },
        _onClear: function(dataArray) {
            this._rootArrayMap.clear();
            dataArray.forEach(function(data) {
                data.removeChangeListener(this._handleDataChange, this);
            }, this);
        },
        _handleDataChange: function(e) {
            if (e.property === "parent") {
                var data = e.source;
                var oldParent = e.old_value;
                var newParent = e.new_value;
                if (oldParent == null && newParent != null) {
                    this._rootArrayMap.remove(data.id());
                } else if (newParent == null && oldParent != null) {
                    this._rootArrayMap.add(data.id(), data);
                }
            }
            e.data = e.source;
            this.dispatchDataChangeEvent(e);
        },
        addDataChangeListener: function(listener, context) {
            this.addListener("provider.data.change", listener, context);
        },
        removeDataChangeListener: function(listener, context) {
            this.removeListener("provider.data.change", listener, context);
        },
        dispatchDataChangeEvent: function(event) {
            this.dispatchEvent("provider.data.change", event);
        },
        toRootArray: function(copy) {
            return this._rootArrayMap.toArray(copy);
        },
        hEach: function(callBack, context) {
            this._rootArrayMap.eachArray(function(data) {
                return this._hEach(data, callBack, context);
            }, this);
        },
        hEachByData: function(data, callBack, context) {
            data.eachChildren(function(child) {
                if (this.contains(child)) {
                    return this._hEach(child, callBack, context);
                }
            }, this);
        },
        _hEach: function(data, callBack, context) {
            var result = callBack.apply(context, [ data ]);
            if (result === false) {
                return false;
            }
            data.eachChildren(function(child) {
                if (this.contains(child)) {
                    result = this._hEach(child, callBack, context);
                    if (result === false) {
                        return false;
                    }
                }
            }, this);
            return result;
        },
        getSelectProvider: function() {
            if (this._selectProvider == null) {
                this._selectProvider = new $IAttachProvider(this);
            }
            return this._selectProvider;
        },
        getCheckProvider: function() {
            if (this._checkProvider == null) {
                this._checkProvider = new $IAttachProvider(this);
            }
            return this._checkProvider;
        },
        getExpandProvider: function() {
            if (this._expandProvider == null) {
                this._expandProvider = new $IAttachProvider(this);
            }
            return this._expandProvider;
        },
        moveToPrevious: function(data) {
            var array = this._getIndexArray(data);
            var index = array.indexOf(data);
            if (index === 0) {
                return;
            }
            array.splice(index, 1);
            array.splice(index - 1, 0, data);
            this.dispatchIndexChangeEvent(data, index, index - 1);
        },
        moveToNext: function(data) {
            var array = this._getIndexArray(data);
            var length = array.length;
            var index = array.indexOf(data);
            if (index === length - 1) {
                return;
            }
            array.splice(index, 1);
            array.splice(index + 1, 0, data);
            this.dispatchIndexChangeEvent(data, index + 1, index);
        },
        moveToFirst: function(data) {
            var array = this._getIndexArray(data);
            var index = array.indexOf(data);
            if (index === 0) {
                return;
            }
            array.splice(index, 1);
            array.unshift(data);
            this.dispatchIndexChangeEvent(data, 0, index);
        },
        moveToLast: function(data) {
            var array = this._getIndexArray(data);
            var length = array.length;
            var index = array.indexOf(data);
            if (index === length - 1) {
                return;
            }
            array.splice(index, 1);
            array.push(data);
            this.dispatchIndexChangeEvent(data, length - 1, index);
        },
        moveTo: function(data, new_index) {
            var array = this._getIndexArray(data);
            var index = array.indexOf(data);
            if (index === new_index) {
                return;
            }
            array.splice(index, 1);
            array.splice(new_index, 0, data);
            this.dispatchIndexChangeEvent(data, new_index, index);
        },
        _getIndexArray: function(data) {
            var p = data.getProperty("parent");
            if (p) {
                return p.getChildren(false);
            } else {
                return this._rootArrayMap.toArray(false);
            }
        },
        addIndexChangeListener: function(fun, context) {
            this.addListener("provider.index.change", fun, context);
        },
        removeIndexChangeListener: function(fun, context) {
            this.removeListener("provider.index.change", fun, context);
        },
        dispatchIndexChangeEvent: function(data, newIndex, oldIndex) {
            this.dispatchEvent("provider.index.change", {
                data: data,
                new_index: newIndex,
                old_index: oldIndex
            });
        }
    });
    var $IAttachProvider = function(provider) {
        $IAttachProvider.superClass.constructor.apply(this);
        this.setProvider(provider);
    };
    $extendClass($IAttachProvider, $IProvider, {
        set: function(data) {
            this.clear();
            if ($isData(data)) {
                if (this.isAddable(data)) {
                    this._dataArrayMap.add(data.id(), data);
                }
            } else if ($isArray(data)) {
                $eachArray(data, function(data) {
                    if ($isData(data) && this.isAddable(data)) {
                        this._dataArrayMap.add(data.id(), data);
                    }
                }, this);
            }
            if (this._dataArrayMap.size() > 0) {
                this.dispatchProviderChangeEvent("set", this._dataArrayMap.toArray());
            }
        },
        getLast: function() {
            var array = this._dataArrayMap.toArray(false);
            return array[array.length - 1];
        },
        isAddable: function(data) {
            if (this._provider) {
                return this._provider.contains(data);
            }
            return true;
        },
        setProvider: function(provider) {
            if (this._provider) {
                this._provider.removeProviderChangeListener(this._handleProviderChange, this);
                if (this._provider.removeDataChangeListener) {
                    this._provider.removeDataChangeListener(this._handleDataChange, this);
                }
            }
            this._provider = provider;
            this.clear();
            if (provider) {
                provider.addProviderChangeListener(this._handleProviderChange, this);
                if (provider.addDataChangeListener) {
                    provider.addDataChangeListener(this._handleDataChange, this);
                }
            }
        },
        _handleDataChange: function(e) {
            this.onDataChange(e);
        },
        onDataChange: function() {},
        _handleProviderChange: function(e) {
            var type = e.type;
            if (type === "remove") {
                this._dataArrayMap.remove(e.data.id());
            } else if (type === "clear") {
                this._dataArrayMap.clear();
            }
            this.onProviderChange(e);
        },
        onProviderChange: function(e) {}
    });
    var $DataParser = {
        parseHtml: function(rootEle, isLevel, attrConverter, dataKeywordMapping) {
            return $HTMLDataParser.parse(rootEle, isLevel, attrConverter, dataKeywordMapping);
        },
        parseJSON: function(dataArray, dataKeywordMapping, existingDataArray) {
            return $JSONDataParser.parse(dataArray, dataKeywordMapping, existingDataArray);
        }
    };
    var $CheckInterface = function(clazz) {
        return {
            _isCheck_: true,
            isCheckable: function(data) {
                return this.getDataViewProperty(data, "checkable") !== false;
            },
            _updateCheckProvider: function() {
                this._removeCheckProviderListener();
                if (this._provider) {
                    if (this.getProperty("model_check") !== false) {
                        this._checkProvider = this._provider.getCheckProvider();
                    } else {
                        if (!this._checkProvider) {
                            this._checkProvider = new $IAttachProvider(this._provider);
                        }
                        this._checkProvider.setProvider(this._provider);
                    }
                    this._addCheckProviderListener();
                }
            },
            _removeCheckProviderListener: function() {
                if (this._checkProvider) {
                    this._checkProvider.removeProviderChangeListener(this._handleCheckProviderChange, this);
                }
            },
            _addCheckProviderListener: function() {
                this._checkProvider.addProviderChangeListener(this._handleCheckProviderChange, this);
            },
            _handleCheckProviderChange: function(evt) {
                var type = evt.type;
                if (type === "add") {
                    this._onCheckAdd(evt.data);
                } else if (type === "remove") {
                    this._onCheckRemove(evt.data);
                } else if (type === "clear") {
                    this._onCheckClear(evt.data);
                } else if (type === "set") {
                    this._onCheckSet(evt.data);
                }
                this._onCheckChange(evt);
            },
            _addCheckNeedUpdateData: function(data) {
                this._addNeedUpdateData(data, true, true);
            },
            _onCheckAdd: function(data) {
                this._addCheckNeedUpdateData(data);
                this._callOn("onCheckAdd", "on.check.add", data, [ data ]);
            },
            onCheckAdd: function(listener, context) {
                this.addListener("on.check.add", listener, context);
            },
            _onCheckRemove: function(data) {
                this._addCheckNeedUpdateData(data);
                this._callOn("onCheckRemove", "on.check.remove", data, [ data ]);
            },
            onCheckRemove: function(listener, context) {
                this.addListener("on.check.remove", listener, context);
            },
            _onCheckClear: function(dataArray) {
                dataArray.forEach(this._addCheckNeedUpdateData, this);
                this._callOn("onCheckClear", "on.check.clear", dataArray, [ dataArray ]);
            },
            onCheckClear: function(listener, context) {
                this.addListener("on.check.clear", listener, context);
            },
            _onCheckSet: function(dataArray) {
                dataArray.forEach(this._addCheckNeedUpdateData, this);
                this._callOn("onCheckSet", "on.check.set", dataArray, [ dataArray ]);
            },
            onCheckSet: function(listener, context) {
                this.addListener("on.check.set", listener, context);
            },
            _onCheckChange: function(evt) {
                this._update();
                this._callOn("onCheckChange", "on.check.change", evt, [ evt ]);
            },
            onCheckChange: function(listener, context) {
                this.addListener("on.check.change", listener, context);
            },
            check: function(data, isAdd) {
                var arr = this._getModelDataArr(data);
                if (isAdd === true) {
                    return this._addCheck(arr);
                }
                return this._setCheck(arr);
            },
            uncheck: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                this._removeCheck(arr);
            },
            addCheck: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                return this._addCheck(arr);
            },
            removeCheck: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                this._removeCheck(arr);
            },
            setCheck: function(data) {
                var arr = this._getModelDataArr(data);
                this._setCheck(arr);
            },
            checkAll: function(onlyVisible) {
                var checkArray = this.getDataArray(false);
                if (onlyVisible !== false) {
                    checkArray = $filterArray(checkArray, this._isVisible, this);
                }
                return this._checkProvider.set(this._filterCheckableData(checkArray));
            },
            clearCheck: function() {
                return this._checkProvider.clear.apply(this._checkProvider, arguments);
            },
            uncheckAll: function() {
                return this._checkProvider.clear.apply(this._checkProvider, arguments);
            },
            getChecked: function(copy) {
                return this._checkProvider.toArray.apply(this._checkProvider, arguments);
            },
            getLastChecked: function() {
                return this._checkProvider.getLast.apply(this._checkProvider, arguments);
            },
            isChecked: function(data) {
                data = this._getModelData(data);
                if (data) {
                    return this._checkProvider.contains(data);
                }
                return false;
            },
            toggleCheck: function(data) {
                data = this._getModelData(data);
                if (!data) {
                    return;
                }
                if (this.isChecked(data)) {
                    this.removeCheck(data);
                } else {
                    this.addCheck(data);
                }
            },
            _addCheck: function(dataArr) {
                return this._checkProvider.add(this._filterCheckableData(dataArr));
            },
            _removeCheck: function(dataArr) {
                dataArr.forEach(function(d) {
                    this._checkProvider.remove(d);
                }, this);
            },
            _setCheck: function(dataArr) {
                return this._checkProvider.set(this._filterCheckableData(dataArr));
            },
            _filterCheckableData: function(data) {
                return data.filter(function(data) {
                    return this.isCheckable(data) && !this.isDisabled(data);
                }, this);
            }
        };
    };
    var $ControllerInterface = function(clazz) {
        return {
            _getControllerRoot: function() {
                return this._root;
            },
            setControllers: function(controllerArray) {
                this._controllerArray.forEach(function(controller) {
                    controller.remove();
                });
                this._controllerArray = $mergeArray([], controllerArray);
                this._controllerArray.forEach(function(controller) {
                    controller.add(this);
                }, this);
                this._onControllerChange("set");
            },
            addController: function(controller) {
                this._controllerArray.push(controller);
                controller.add(this);
                this._onControllerChange("add");
            },
            removeController: function(controller) {
                var index = this._controllerArray.indexOf(controller);
                if (index >= 0) {
                    controller.remove();
                    this._controllerArray.splice(index, 1);
                    this._onControllerChange("remove");
                }
            },
            clearController: function() {
                if (this._controllerArray.length > 0) {
                    this._controllerArray.forEach(function(controller) {
                        controller.remove();
                    });
                    this._controllerArray = [];
                    this._onControllerChange("clear");
                }
            },
            _onControllerChange: function(type) {},
            _onDataClick: function(data, evt) {
                this._callOn("onDataClick", "on.data.click", {
                    data: data,
                    event: evt
                }, [ data, evt ]);
            },
            onDataClick: function(listener, context) {
                this.addListener("on.data.click", listener, context);
            },
            _onDataDblClick: function(data, evt) {
                this._callOn("onDataDblClick", "on.data.dblclick", {
                    data: data,
                    event: evt
                }, [ data, evt ]);
            },
            onDataDblClick: function(listener, context) {
                this.addListener("on.data.dblclick", listener, context);
            }
        };
    };
    var $ExpandInterface = function(clazz) {
        return {
            _isExpand_: true,
            _isExpandable: function(data) {
                return this.isExpandable(data);
            },
            isExpandable: function(data) {
                return this.getDataViewProperty(data, "expandable") !== false;
            },
            _isAccordion: function() {
                return this.getProperty("accordion") === true;
            },
            _updateExpandProvider: function() {
                this._removeExpandProviderListener();
                if (this._provider) {
                    if (this.getProperty("model_expand") !== false) {
                        this._expandProvider = this._provider.getExpandProvider();
                    } else {
                        if (!this._expandProvider) {
                            this._expandProvider = new $IAttachProvider(this._provider);
                        }
                        this._expandProvider.setProvider(this._provider);
                    }
                    this._addExpandProviderListener();
                }
            },
            _removeExpandProviderListener: function() {
                if (this._expandProvider) {
                    this._expandProvider.removeProviderChangeListener(this._handleExpandProviderChange, this);
                }
            },
            _addExpandProviderListener: function() {
                this._expandProvider.addProviderChangeListener(this._handleExpandProviderChange, this);
            },
            _handleExpandProviderChange: function(evt) {
                var type = evt.type;
                if (type === "add") {
                    this._onExpandAdd(evt.data);
                } else if (type === "remove") {
                    this._onExpandRemove(evt.data);
                } else if (type === "clear") {
                    this._onExpandClear(evt.data);
                } else if (type === "set") {
                    this._onExpandSet(evt.data);
                }
                this._onExpandChange(evt);
            },
            _addExpandNeedUpdateData: function(data) {
                this._addNeedUpdateData(data, false, true);
            },
            _onExpandAdd: function(data) {
                this._addExpandNeedUpdateData(data);
                this._callOn("onExpand", "on.expand.add", data, [ data ]);
                if (this._isAccordion()) {
                    var expandedArray = this._expandProvider.toArray();
                    var ancestorArray = $DataLevelUtil.getAncestorArray(data);
                    expandedArray.forEach(function(_data) {
                        if (_data !== data && ancestorArray.indexOf(_data) < 0) {
                            this.collapse(_data);
                        }
                    }, this);
                }
            },
            onExpand: function(listener, context) {
                this.addListener("on.expand.add", listener, context);
            },
            _onExpandRemove: function(data) {
                this._addExpandNeedUpdateData(data, false);
                this._callOn("onCollapse", "on.expand.remove", data, [ data ]);
            },
            onCollapse: function(listener, context) {
                this.addListener("on.expand.remove", listener, context);
            },
            _onExpandClear: function(dataArray) {
                dataArray.forEach(this._addExpandNeedUpdateData, this);
                this._callOn("onCollapseAll", "on.expand.clear", dataArray, [ dataArray ]);
            },
            onCollapseAll: function(listener, context) {
                this.addListener("on.expand.clear", listener, context);
            },
            _onExpandSet: function(dataArray) {
                dataArray.forEach(this._addExpandNeedUpdateData, this);
                this._callOn("onExpandSet", "on.expand.set", dataArray, [ dataArray ]);
            },
            onExpandSet: function(listener, context) {
                this.addListener("on.expand.set", listener, context);
            },
            _onExpandChange: function(evt) {
                this._update();
                this._callOn("onExpandChange", "on.expand.change", evt, [ evt ]);
            },
            onExpandChange: function(listener, context) {
                this.addListener("on.expand.change", listener, context);
            },
            getExpanded: function(copy) {
                return this._expandProvider.toArray.apply(this._expandProvider, arguments);
            },
            expand: function(data, expand_ancestor) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                if (arr.length === 1 && expand_ancestor === true) {
                    arr.forEach(function(data) {
                        $mergeArray(arr, $DataLevelUtil.getAncestorArray(data));
                    });
                }
                return this._addExpand(arr);
            },
            collapse: function(data, collapse_descendant) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                if (collapse_descendant === true) {
                    arr.forEach(function(data) {
                        $mergeArray(arr, $DataLevelUtil.getAddedDescendantArray(data));
                    });
                }
                return this._removeExpand(arr);
            },
            expandAll: function(onlyVisible) {
                var expandArray = this.getDataArray(false);
                if (onlyVisible !== false) {
                    expandArray = $filterArray(expandArray, this._isVisible_, this);
                }
                return this._expandProvider.set(this._filterExpandableData(expandArray));
            },
            collapseAll: function() {
                return this._expandProvider.clear.apply(this._expandProvider, arguments);
            },
            isExpanded: function(data) {
                data = this._getModelData(data);
                if (data) {
                    return this._expandProvider.contains(data);
                }
                return false;
            },
            toggleExpand: function(data) {
                data = this._getModelData(data);
                if (!data) {
                    return;
                }
                if (this.isExpanded(data)) {
                    this.collapse(data);
                } else {
                    this.expand(data);
                }
            },
            _addExpand: function(dataArr) {
                return this._expandProvider.add(this._filterExpandableData(dataArr));
            },
            _removeExpand: function(dataArr) {
                dataArr.forEach(function(d) {
                    this._expandProvider.remove(d);
                }, this);
            },
            _filterExpandableData: function(data) {
                return data.filter(function(data) {
                    return this._isExpandable(data) && !this.isDisabled(data);
                }, this);
            },
            _isDataAncestorExpanded: function(data) {
                var array = $DataLevelUtil.getAncestorArray(data);
                if (array.length === 0) {
                    return true;
                }
                var expanded = true;
                array.forEach(function(parent) {
                    if (!this.isExpanded(parent)) {
                        expanded = false;
                    }
                }, this);
                return expanded;
            }
        };
    };
    var $HoverInterface = function(clazz) {
        return {
            _onDataRemove: function(data) {
                clazz.superClass._onDataRemove.apply(this, arguments);
                this._removeHover(data, false);
            },
            _onDataClear: function() {
                clazz.superClass._onDataClear.apply(this, arguments);
                this._clearHover(false);
            },
            _onModelChange: function(type) {
                clazz.superClass._onModelChange.apply(this, arguments);
                if (type === "set_provider") {
                    this._clearHover(false);
                }
            },
            setHoverData: function(data) {
                this._setHoverData(this._getModelData(data), true);
            },
            getHoverData: function() {
                return this._hoverData;
            },
            isHover: function(data) {
                data = this._getModelData(data);
                if (data) {
                    return this._hoverData === data;
                }
                return false;
            },
            hasHover: function() {
                return this._hoverData != null;
            },
            _isHoverable: function(data) {
                return this.isHoverable(data);
            },
            isHoverable: function(data) {
                return this.getDataViewProperty(data, "hoverable") === true;
            },
            _removeHover: function(data, fireEvent) {
                if (data === this._hoverData) {
                    this._setHoverData(null, fireEvent);
                }
            },
            _clearHover: function(fireEvent) {
                this._setHoverData(null, fireEvent);
            },
            _setHoverData: function(data, fireEvent, evt) {
                if (this._hoverData !== data) {
                    var fire = fireEvent !== false;
                    if (fire && this._hoverData) {
                        this._onHoverChange(this._hoverData, false, evt);
                    }
                    this._hoverData = data;
                    if (fire && this._hoverData) {
                        this._onHoverChange(this._hoverData, true, evt);
                    }
                }
            },
            _onHoverChange: function(data, isHover, evt) {
                this._addHoverNeedUpdateData(data);
                this._update();
                this._callOn("onHoverChange", "on.hover.change", {
                    data: data,
                    event: evt,
                    isHover: isHover
                }, [ data, isHover ]);
            },
            onHoverChange: function(listener, context) {
                this.addListener("on.hover.change", listener, context);
            },
            _addHoverNeedUpdateData: function(data) {
                this._addNeedUpdateData(data, false, false);
            }
        };
    };
    var $ModelInterface = function(clazz) {
        return {
            setProvider: function(provider) {
                if (this._provider === provider) {
                    return;
                }
                if (!$ModelTypeCheck.isProvider(provider)) {
                    $Util.throwError("Only z.Provider instance is allowed");
                }
                this._removeProviderListener();
                this._provider = provider;
                this._addProviderListener();
                this._beforeModelChange("set_provider");
                this._onProviderChange();
                this._onModelChange("set_provider");
            },
            getProvider: function() {
                return this._provider;
            },
            _onProviderChange: function() {},
            _removeProviderListener: function() {
                if (this._provider) {
                    this._provider.removeProviderChangeListener(this._handleProviderChange, this);
                    this._provider.removeDataChangeListener(this._handleProviderDataChange, this);
                    this._provider.removeIndexChangeListener(this._handleProviderDataIndexChange, this);
                }
            },
            _addProviderListener: function() {
                this._provider.addProviderChangeListener(this._handleProviderChange, this);
                this._provider.addDataChangeListener(this._handleProviderDataChange, this);
                this._provider.addIndexChangeListener(this._handleProviderDataIndexChange, this);
            },
            _handleProviderChange: function(evt) {
                this._beforeModelChange("provider", evt);
                var type = evt.type;
                if (type === "add") {
                    this._onDataAdd(evt.data);
                } else if (type === "remove") {
                    this._onDataRemove(evt.data);
                } else if (type === "clear") {
                    this._onDataClear(evt.data);
                }
                this._onModelChange("provider", evt);
            },
            _handleProviderDataChange: function(evt) {
                this._beforeModelChange("data", evt);
                this._onDataChange(evt.data, evt);
                this._onModelChange("data", evt);
            },
            _handleProviderDataIndexChange: function(evt) {
                this._beforeModelChange("index", evt);
                this._onDataIndexChange(evt.data, evt);
                this._onModelChange("index", evt);
            },
            _beforeModelChange: function(type, evt) {},
            _onModelChange: function(type, evt) {
                this._update();
                this._callOn("onModelChange", "on.model.change", {
                    type: type,
                    event: evt
                }, [ type, evt ]);
            },
            onModelChange: function(listener, context) {
                this.addListener("on.model.change", listener, context);
            },
            offModelChange: function(listener, context) {
                this.removeListener("on.model.change", listener, context);
            },
            _onDataAdd: function(data) {
                this._callOn("onDataAdd", "on.data.add", data, [ data ]);
            },
            onDataAdd: function(listener, context) {
                this.addListener("on.data.add", listener, context);
            },
            _onDataRemove: function(data) {
                this._callOn("onDataRemove", "on.data.remove", data, [ data ]);
            },
            onDataRemove: function(listener, context) {
                this.addListener("on.data.remove", listener, context);
            },
            _onDataClear: function(dataArray) {
                this._callOn("onDataClear", "on.data.clear", dataArray, [ dataArray ]);
            },
            onDataClear: function(listener, context) {
                this.addListener("on.data.clear", listener, context);
            },
            _onDataIndexChange: function(data, evt) {
                this._callOn("onDataIndexChange", "on.data.index.change", {
                    data: data,
                    event: evt
                }, [ data, evt ]);
            },
            onDataIndexChange: function(listener, context) {
                this.addListener("on.data.index.change", listener, context);
            },
            _onDataChange: function(data, evt) {
                this._callOn("onDataChange", "on.data.change", {
                    data: data,
                    event: evt
                }, [ data, evt ]);
            },
            onDataChange: function(listener, context) {
                this.addListener("on.data.change", listener, context);
            },
            setData: function(data, dataBind) {
                var dp;
                if ($isProvider(data)) {
                    dp = data;
                } else {
                    if (!$isArray(data)) {
                        data = [ data ];
                    }
                    dp = new $Provider();
                    var daraArr = $DataParser.parseJSON(data);
                    if (dataBind === true) {
                        daraArr.forEach(function(d) {
                            d._bind(d.get("_$z_data"));
                        });
                    }
                    dp.add(daraArr);
                }
                this.setProvider(dp);
            },
            addData: function(data, index) {
                if (!$isData(data)) {
                    if (!$isArray(data)) {
                        data = [ data ];
                    }
                    if (!$isData(data[0])) {
                        data = $DataParser.parseJSON(data, null, this.getDataArray());
                    }
                }
                if (arguments.length > 1) {
                    return this._provider.add(data, index);
                }
                return this._provider.add(data);
            },
            removeData: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                arr.forEach(function(d) {
                    this._provider.remove(d);
                }, this);
            },
            clearData: function() {
                return this._provider.clear.apply(this._provider, arguments);
            },
            containsData: function(data) {
                if (!$isData(data)) {
                    data = this._provider.find.apply(this._provider, arguments);
                }
                if (data) {
                    return this._provider.contains.apply(this._provider, arguments);
                }
                return false;
            },
            findData: function(prop, value) {
                return this._provider.find.apply(this._provider, arguments);
            },
            filterData: function(prop, value) {
                return this._provider.filter.apply(this._provider, arguments);
            },
            eachData: function(callBack, context) {
                if (this._provider) {
                    return this._provider.each.apply(this._provider, arguments);
                }
            },
            hEachData: function(callBack, context) {
                if (this._provider) {
                    return this._provider.hEach.apply(this._provider, arguments);
                }
            },
            getDataArray: function(copy) {
                return this._provider.toArray.apply(this._provider, arguments);
            },
            getRootDataArray: function(copy) {
                return this._provider.toRootArray.apply(this._provider, arguments);
            },
            getDataSize: function() {
                return this._provider.size.apply(this._provider, arguments);
            },
            _getModelDataArr: function(data, filter) {
                var arr = [];
                if ($isData(data)) {
                    arr.push(data);
                } else if ($isArray(data)) {
                    data.forEach(function(item) {
                        if ($isData(item)) {
                            arr.push(item);
                        } else if ($isObject(item)) {
                            var itemData = this.findData(item);
                            if (itemData) {
                                arr.push(itemData);
                            }
                        }
                    }, this);
                } else if ($isObject(data)) {
                    data = this.findData(data);
                    if (data) {
                        arr.push(data);
                    }
                }
                if (filter) {
                    return $filterArray(arr, filter);
                }
                return arr;
            },
            _getModelData: function(data) {
                if ($isData(data)) {
                    return data;
                }
                if ($isObject(data)) {
                    return this.findData(data);
                }
            }
        };
    };
    var $MoveInterface = function(clazz) {
        return {
            _isMovable: function(data) {
                return this.isMovable(data);
            },
            isMovable: function(data) {
                return this.getDataViewProperty(data, "movable") !== false;
            }
        };
    };
    var $OnResizeInterface = function(clazz) {
        return {
            _doViewOnResizeUpdate: function(key, value, old) {
                if (key === "onresize") {
                    if (old === true) {
                        $DomResizeEventUtil.removeResizeListener(this._root, this._handleViewResize, this);
                    }
                    if (value === true) {
                        $DomResizeEventUtil.addResizeListener(this._root, this._handleViewResize, this);
                    }
                    return true;
                }
            },
            _handleViewResize: function() {
                this._callBatch(this._doBatchResizeUpdate, "onresize_cb_");
            },
            _doBatchResizeUpdate: function() {
                var size = this.getRootSize();
                if (size.width > 0 && size.height > 0) {
                    this._doResizeUpdate();
                }
                this._onViewResize();
            },
            _onViewResize: function() {
                this._callOn("onViewResize", "on.view.resize", {}, []);
            },
            onViewResize: function(listener, context) {
                this.addListener("on.view.resize", listener, context);
            },
            _doResizeUpdate: function() {},
            getRootSize: function() {
                return {
                    width: this._root.clientWidth,
                    height: this._root.clientHeight
                };
            }
        };
    };
    var $RendererViewInterface = function(clazz) {
        return {
            _doUpdateDataRenderer: function(data) {
                var renderer = this.getDataRenderer(data);
                if (renderer) {
                    renderer.update();
                }
            },
            getDataRenderProperty: function(data, property) {
                return data.getProperty(property);
            },
            _addDataRenderer: function(data) {
                var renderer = this.createDataRenderer(data);
                if (renderer) {
                    this._rendererArrayMap.add(data.id(), renderer);
                    this._addDataRendererImpl(data, renderer);
                }
            },
            _addDataRendererImpl: function(data, renderer) {},
            _removeDataRenderer: function(data) {
                var renderer = this._rendererArrayMap.get(data.id());
                if (renderer) {
                    this._rendererArrayMap.remove(data.id());
                    this._removeDataRendererImpl(data, renderer);
                    renderer.dispose();
                }
            },
            _removeDataRendererImpl: function(data, renderer) {},
            _clearDataRendererImpl: function() {},
            _updateDataRenderer: function(data, evt) {
                var renderer = this._rendererArrayMap.get(data.id());
                if (renderer) {
                    this._updateDataRendererImpl(data, renderer, evt.property === "parent");
                }
            },
            _updateDataRendererImpl: function(data, renderer, reorder) {},
            _initAllDataRenderer: function() {
                this.getDataArray(false).forEach(function(data) {
                    var renderer = this.createDataRenderer(data);
                    if (renderer) {
                        this._rendererArrayMap.add(data.id(), renderer);
                        this._addDataRendererImpl(data, renderer);
                    }
                }, this);
            },
            _reorderAllDataRenderer: function() {},
            getDataRenderer: function(data) {
                return this._rendererArrayMap.get(data.id());
            },
            createDataRenderer: function(data) {
                var clazz = this.getDataRendererClass(data);
                return $ClassUtil.createInstance(clazz, [ this, data ]);
            },
            getDataRendererClass: function(data) {}
        };
    };
    var $SelectInterface = function(clazz) {
        return {
            isSelectable: function(data) {
                return this.getDataViewProperty(data, "selectable") !== false;
            },
            getSelectMode: function() {
                return this.getProperty("select_mode");
            },
            _updateSelectProvider: function() {
                this._removeSelectProviderListener();
                if (this._provider) {
                    if (this.getProperty("model_select") !== false) {
                        this._selectProvider = this._provider.getSelectProvider();
                    } else {
                        if (!this._selectProvider) {
                            this._selectProvider = new $IAttachProvider(this._provider);
                        }
                        this._selectProvider.setProvider(this._provider);
                    }
                    this._addSelectProviderListener();
                }
            },
            _removeSelectProviderListener: function() {
                if (this._selectProvider) {
                    this._selectProvider.removeProviderChangeListener(this._handleSelectProviderChange, this);
                }
            },
            _addSelectProviderListener: function() {
                this._selectProvider.addProviderChangeListener(this._handleSelectProviderChange, this);
            },
            _handleSelectProviderChange: function(evt) {
                var type = evt.type;
                if (type === "add") {
                    this._onSelectAdd(evt.data);
                } else if (type === "remove") {
                    this._onSelectRemove(evt.data);
                } else if (type === "clear") {
                    this._onSelectClear(evt.data);
                } else if (type === "set") {
                    this._onSelectSet(evt.data);
                }
                this._onSelectChange(evt);
            },
            _addSelectNeedUpdateData: function(data) {
                this._addNeedUpdateData(data, false, false);
            },
            _onSelectAdd: function(data) {
                this._addSelectNeedUpdateData(data);
                this._callOn("onSelectAdd", "on.select.add", data, [ data ]);
            },
            onSelectAdd: function(listener, context) {
                this.addListener("on.select.add", listener, context);
            },
            _onSelectRemove: function(data) {
                this._addSelectNeedUpdateData(data);
                this._callOn("onSelectRemove", "on.select.remove", data, [ data ]);
            },
            onSelectRemove: function(listener, context) {
                this.addListener("on.select.remove", listener, context);
            },
            _onSelectClear: function(dataArray) {
                dataArray.forEach(this._addSelectNeedUpdateData, this);
                this._callOn("onSelectClear", "on.select.clear", dataArray, [ dataArray ]);
            },
            onSelectClear: function(listener, context) {
                this.addListener("on.select.clear", listener, context);
            },
            _onSelectSet: function(dataArray) {
                dataArray.forEach(this._addSelectNeedUpdateData, this);
                this._callOn("onSelectSet", "on.select.set", dataArray, [ dataArray ]);
            },
            onSelectSet: function(listener, context) {
                this.addListener("on.select.set", listener, context);
            },
            _onSelectChange: function(evt) {
                this._update();
                this._callOn("onSelectChange", "on.select.change", evt, [ evt ]);
                this._callBatch(this._onSelectBatchChange, "select_batch_cb_");
            },
            onSelectChange: function(listener, context) {
                this.addListener("on.select.change", listener, context);
            },
            _onSelectBatchChange: function() {
                var selected = this.getSelected();
                this._callOn("onSelectBatchChange", "on.select.batch.change", selected, [ selected ]);
                if (selected.length > 0) {
                    if (this.getProperty("make_visible_on_select") === true) {
                        this.makeVisible(this.getLastSelected());
                    }
                }
            },
            onSelectBatchChange: function(listener, context) {
                this.addListener("on.select.batch.change", listener, context);
            },
            select: function(data, isAdd) {
                var arr = this._getModelDataArr(data);
                if (isAdd === true) {
                    return this._addSelect(arr);
                }
                return this._setSelect(arr);
            },
            unselect: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                return this._removeSelect(arr);
            },
            addSelect: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                return this._addSelect(arr);
            },
            removeSelect: function(data) {
                var arr = this._getModelDataArr(data);
                if (arr.length === 0) {
                    return;
                }
                return this._removeSelect(arr);
            },
            setSelect: function(data) {
                var arr = this._getModelDataArr(data);
                return this._setSelect(arr);
            },
            selectAll: function(onlyVisible) {
                var checkArray = this.getDataArray(false);
                if (onlyVisible !== false) {
                    checkArray = $filterArray(checkArray, this._isVisible, this);
                }
                return this._selectProvider.set(this._filterSelectableData(checkArray));
            },
            clearSelect: function() {
                return this._selectProvider.clear.apply(this._selectProvider, arguments);
            },
            getSelected: function(copy) {
                return this._selectProvider.toArray.apply(this._selectProvider, arguments);
            },
            getLastSelected: function() {
                return this._selectProvider.getLast.apply(this._selectProvider, arguments);
            },
            isSelected: function(data) {
                data = this._getModelData(data);
                if (data) {
                    return this._selectProvider.contains(data);
                }
                return false;
            },
            _addSelect: function(dataArr) {
                return this._selectProvider.add(this._filterSelectableData(dataArr));
            },
            _removeSelect: function(dataArr) {
                dataArr.forEach(function(d) {
                    this._selectProvider.remove(d);
                }, this);
            },
            _setSelect: function(dataArr) {
                return this._selectProvider.set(this._filterSelectableData(dataArr));
            },
            _filterSelectableData: function(dataArr) {
                return dataArr.filter(function(data) {
                    return this.isSelectable(data) && !this.isDisabled(data);
                }, this);
            }
        };
    };
    var $VisibleInterface = function(clazz) {
        return {
            _isVisible: function(data) {
                return this._isVisible_(data);
            },
            _isVisible_: function(data) {
                return this.containsData(data) && this.isVisible(data) && this._isFilterVisible(data);
            },
            isVisible: function(data) {
                return this.getDataViewProperty(data, "visible") !== false;
            },
            _isFilterVisible: function(data) {
                var visible = true;
                if (this._dataVisibleFilterArray.length > 0) {
                    $eachArray(this._dataVisibleFilterArray, function(filter) {
                        if (filter(data) === false) {
                            visible = false;
                            return false;
                        }
                    });
                }
                return visible;
            },
            addVisibleFilter: function(filter) {
                this._dataVisibleFilterArray.push(filter);
                this._update();
            },
            removeVisibleFilter: function(filter) {
                $arrayRemoveItem(this._dataVisibleFilterArray, filter);
                this._update();
            },
            clearVisibleFilter: function() {
                this._dataVisibleFilterArray.length = 0;
                this._update();
            }
        };
    };
    var $IView = function() {
        var appendTo = $getSingleObjectArg(arguments, "appendTo");
        var root = $createDomElement("div");
        this._root = root;
        this._controllerArray = [];
        $IView.superClass.constructor.apply(this, arguments);
        if (this.getProperty("onresize") === true && this.hasProperty("onresize") === false) {
            $DomResizeEventUtil.addResizeListener(root, this._handleViewResize, this);
        }
        this._appendToUpdate();
        $domSetStyle(root, "visibility", "hidden");
        if (appendTo) {
            this.appendTo(appendTo);
        }
        $callLater(function() {
            $domRemoveStyle(root, "visibility");
        }, 20);
    };
    $extendClass($IView, $IModel, $mergeObject({
        __toTypeString_View_$: function() {
            return $TypeConst.VIEW;
        },
        appendTo: function(parentEle) {
            parentEle = $domQueryElement(parentEle);
            parentEle.appendChild(this.getRoot());
        },
        _appendToUpdate: function() {
            var root = this.getRoot();
            $callRAFInterval(function() {
                if ($isInDom(root)) {
                    this.update();
                    this._displayToResize();
                    return false;
                }
            }, this);
        },
        _displayToResize: function() {
            if (this.getProperty("onresize") === true) {
                var root = this.getRoot();
                $callInterval(function() {
                    var rootParent = root.parentNode;
                    var isDisplay = true;
                    while (rootParent) {
                        if ($domGetStyle(rootParent, "display") === "none") {
                            isDisplay = false;
                            break;
                        }
                        rootParent = rootParent.parentNode;
                        if (rootParent === document) {
                            break;
                        }
                    }
                    if (isDisplay) {
                        this._doResizeUpdate();
                        return false;
                    }
                }, 600, this);
            }
        },
        afterSetProperty: function(key, value, old) {
            $IView.superClass.afterSetProperty.apply(this, arguments);
            this._onViewChange(key, value, old);
        },
        _onViewChange: function(key, value, old) {
            this._callOn("onViewChange", "on.view.change", {
                property: key,
                new_value: value,
                old_value: old
            }, [ key, value, old ]);
            if (this._doViewCSSUpdate(key, value, old) === true) {
                return;
            }
            if (this._doViewOnResizeUpdate(key, value, old) === true) {
                return;
            }
            this._update();
        },
        onViewChange: function(listener, context) {
            this.addListener("on.view.change", listener, context);
        },
        offViewChange: function(listener, context) {
            this.removeListener("on.view.change", listener, context);
        },
        update: function(batch) {
            if (batch === true) {
                this._update();
                this._handleViewResize();
            } else {
                this._doBatchUpdate();
                this._doBatchResizeUpdate();
            }
        },
        _update: function() {
            this._callBatch(this._doBatchUpdate, "update_cb_");
        },
        _doBatchUpdate: function() {
            this._doUpdate();
            this._onViewUpdate();
        },
        _onViewUpdate: function() {
            this._callOn("onViewUpdate", "on.view.update", {}, []);
        },
        onViewUpdate: function(listener, context) {
            this.addListener("on.view.update", listener, context);
        },
        _doUpdate: function() {},
        _doViewCSSUpdate: function(key, value, old) {
            if (key === "style") {
                var styles = {};
                if ($isString(old)) {
                    old = $DomStyle.parseStyle(old);
                }
                if ($isObject(old)) {
                    $ObjectKeys(old).forEach(function(item) {
                        styles[item] = "";
                    });
                }
                if ($isString(value)) {
                    value = $DomStyle.parseStyle(value);
                }
                if ($isObject(value)) {
                    styles = $mergeObject(styles, value);
                }
                z.dom.setStyle(this._root, styles);
                return true;
            } else if (key === "class") {
                if (old) {
                    $domRemoveClass(this._root, old);
                }
                if (value) {
                    $domAddClass(this._root, value);
                }
                return true;
            }
        },
        _callBatch: function(callBack, key) {
            $callBatch(callBack, {
                key: key,
                context: this
            });
        },
        getRoot: function() {
            return this._root;
        }
    }, $OnResizeInterface($IView), $ControllerInterface($IView)));
    var $IDataView = function() {
        var data = $getSingleObjectArg(arguments, "data");
        this._dataVisibleFilterArray = [];
        $IDataView.superClass.constructor.apply(this, arguments);
        if ($isProvider(data)) {
            this.setProvider(data);
        } else {
            this.setProvider(new $Provider());
            if (data) {
                this.setData(data);
            }
        }
    };
    $extendClass($IDataView, $IView, $mergeObject({
        makeVisible: function(data) {},
        _isDisabled: function(data) {
            return this.isDisabled(data);
        },
        isDisabled: function(data) {
            return this.getDataViewProperty(data, "disabled") === true;
        },
        getDataViewProperty: function(data, property, viewProperty) {
            viewProperty = viewProperty || property;
            var customProps = this.getDataProperties(data);
            if (customProps) {
                if (customProps.hasOwnProperty(property)) {
                    return customProps[property];
                }
                if (customProps.hasOwnProperty(viewProperty)) {
                    return customProps[viewProperty];
                }
            }
            if (data.hasProperty(property)) {
                return data.getProperty(property);
            }
            if (this.hasProperty(viewProperty)) {
                return this.getProperty(viewProperty);
            }
            var value = data.getProperty(property);
            if (value != null) {
                return value;
            }
            return this.getProperty(viewProperty);
        },
        hasDataViewProperty: function(data, property, viewProperty) {
            viewProperty = viewProperty || property;
            var customProps = this.getDataProperties(data);
            if (customProps) {
                if (customProps.hasOwnProperty(property)) {
                    return true;
                }
                if (customProps.hasOwnProperty(viewProperty)) {
                    return true;
                }
            }
            if (data.hasProperty(property)) {
                return true;
            }
            if (this.hasProperty(viewProperty)) {
                return true;
            }
            return false;
        },
        getDataProperties: function(data) {}
    }, $ModelInterface($IDataView), $VisibleInterface($IDataView)));
    var $IDataRendererView = function() {
        this._rendererArrayMap = new $ArrayMap();
        this._needUpdateDataArray = [];
        this._needUpdateDataADMap = {};
        $IDataRendererView.superClass.constructor.apply(this, arguments);
    };
    $extendClass($IDataRendererView, $IDataView, $mergeObject({
        ___zdefaults_: {
            model_select: false,
            model_expand: false,
            model_check: false,
            make_visible_on_select: true,
            selectable: true,
            label_field: $getDefault("VIEW_LABEL_FIELD"),
            label_visible: true,
            info_field: $getDefault("VIEW_INFO_FIELD"),
            info_visible: true
        },
        _onViewChange: function(key, value, old) {
            this._updateDataOnViewChange(key, value, old);
            $IDataRendererView.superClass._onViewChange.apply(this, arguments);
            this._doAttachProviderUpdate(key);
        },
        _updateDataOnViewChange: function(key, value, old) {
            this._updateAllDataVar();
        },
        _onProviderChange: function() {
            $IDataRendererView.superClass._onProviderChange.apply(this, arguments);
            this._updateSelectProvider();
            this._updateExpandProvider();
            this._updateCheckProvider();
        },
        _doAttachProviderUpdate: function(key) {
            if (key === "model_select") {
                this._updateSelectProvider();
                return true;
            }
            if (key === "model_expand") {
                this._updateExpandProvider();
                return true;
            }
            if (key === "model_check") {
                this._updateCheckProvider();
                return true;
            }
        },
        _updateSelectProvider: function() {},
        _updateExpandProvider: function() {},
        _updateCheckProvider: function() {},
        _updateAllDataVar: function() {
            this._update_all_data_ = true;
            this._needUpdateDataArray.length = 0;
        },
        _updateAllData: function() {
            this._updateAllDataVar();
            this._update();
        },
        _updateData: function(data) {
            this._addNeedUpdateData(data);
            this._update();
        },
        _onModelChange: function(type) {
            if (type === "set_provider") {
                this._updateAllDataVar();
                this._clearDataRendererImpl();
                this._initAllDataRenderer();
            }
            $IDataRendererView.superClass._onModelChange.apply(this, arguments);
        },
        update: function() {
            this._updateAllDataVar();
            $IDataRendererView.superClass.update.apply(this, arguments);
        },
        _doUpdate: function(key, value, old) {
            $IDataRendererView.superClass._doUpdate.apply(this, arguments);
            if (this._update_all_data_ === true) {
                this._doUpdateDataArray(this.getDataArray(false));
            } else {
                this._doUpdateDataArray(this._needUpdateDataArray);
            }
            this._needUpdateDataArray.length = 0;
            this._update_all_data_ = false;
        },
        _doUpdateDataArray: function(dataArray) {
            var updateArr = [];
            dataArray.forEach(function(data) {
                var did = data.id();
                var relatedDataArray = this._getDataRelatedDataArray(data, this._needUpdateDataADMap[did + "_$_ancestor"] === true, this._needUpdateDataADMap[did + "_$_descendant"] === true) || [];
                $mergeArray([ data ], relatedDataArray).forEach(function(item) {
                    var index = updateArr.indexOf(item);
                    if (index > -1) {
                        updateArr.splice(index, 1);
                    }
                    updateArr.push(item);
                });
            }, this);
            updateArr.forEach(this._doUpdateDataRenderer, this);
            this._needUpdateDataADMap = {};
        },
        _addNeedUpdateData: function(data, ancestorRelated, descendantRelated) {
            if (this._update_all_data_ !== true) {
                this._needUpdateDataArray.push(data);
                var did = data.id();
                this._needUpdateDataADMap[did + "_$_ancestor"] = this._needUpdateDataADMap[did + "_$_ancestor"] || ancestorRelated !== false;
                this._needUpdateDataADMap[did + "_$_descendant"] = this._needUpdateDataADMap[did + "_$_descendant"] || descendantRelated !== false;
            }
        },
        _getDataRelatedDataArray: function(data, ancestorRelated, descendantRelated) {},
        getLabel: function(data) {
            return data.getProperty(this.getProperty("label_field"));
        },
        getInfo: function(data) {
            return data.getProperty(this.getProperty("info_field"));
        },
        _onDataAdd: function(data) {
            this._addNeedUpdateData(data);
            this._addDataRenderer(data);
            $IDataRendererView.superClass._onDataAdd.apply(this, arguments);
        },
        _onDataRemove: function(data) {
            this._addNeedUpdateData(data);
            this._removeDataRenderer(data);
            $IDataRendererView.superClass._onDataRemove.apply(this, arguments);
        },
        _onDataClear: function() {
            this._updateAllDataVar();
            this._clearDataRendererImpl();
            $IDataRendererView.superClass._onDataClear.apply(this, arguments);
        },
        _onDataChange: function(data, evt) {
            this._addNeedUpdateData(data);
            this._updateDataRenderer(data, evt);
            $IDataRendererView.superClass._onDataChange.apply(this, arguments);
        },
        _onDataIndexChange: function(data) {
            this._addNeedUpdateData(data);
            var renderer = this._rendererArrayMap.get(data.id());
            if (renderer) {
                this._updateDataRendererImpl(data, renderer, true);
            }
            $IDataRendererView.superClass._onDataIndexChange.apply(this, arguments);
        }
    }, $SelectInterface($IDataRendererView), $RendererViewInterface($IDataRendererView)));
    var $IDataElementRendererView = function() {
        $IDataElementRendererView.superClass.constructor.apply(this, arguments);
    };
    $extendClass($IDataElementRendererView, $IDataRendererView, {
        ___zdefaults_: {
            sort_compare: null
        },
        update: function() {
            if (this.getProperty("sort_compare")) {
                this._reorderAllDataRenderer();
            }
            $IDataElementRendererView.superClass.update.apply(this, arguments);
        },
        _onViewChange: function(key, value, old) {
            if (key === "sort_compare") {
                this._reorderAllDataRenderer();
            }
            $IDataElementRendererView.superClass._onViewChange.apply(this, arguments);
        },
        _onViewUpdate: function() {
            $IDataElementRendererView.superClass._onViewUpdate.apply(this, arguments);
            this._updateRendererVIndex();
        },
        _updateRendererVIndex: function() {
            $domQueryAll(".item:not(.hidden)", this.getRendererRootContainer()).forEach(function(renderer, index) {
                renderer.setAttribute("v_index", index);
                renderer.setAttribute("v_index_oe", index % 2 === 0 ? "odd" : "even");
            });
        },
        getRendererRootContainer: function() {
            return this.getRoot();
        },
        getRendererContainer: function(data) {
            return this.getRoot();
        },
        _getSortDataArray: function(array) {
            var sort_compare = this.getProperty("sort_compare");
            if ($isFunction(sort_compare)) {
                return array.slice().sort(sort_compare);
            }
            return array;
        },
        _removeDataRendererImpl: function(data, renderer) {
            $domRemove(renderer.getRenderer());
        },
        _clearDataRendererImpl: function() {
            $domEmpty(this.getRendererRootContainer());
        },
        getDataRendererElement: function(data) {
            var renderer = this.getDataRenderer(data);
            if (renderer) {
                return renderer.getRenderer();
            }
            return null;
        },
        getDataAt: function(evt) {
            var renderer = $DomEventUtil.getEventTarget(evt, "[__z_did_]");
            if (renderer) {
                var did = renderer.getAttribute("__z_did_");
                return $findArray(this.getDataArray(false), function(data) {
                    return data.id() === did;
                });
            }
            return null;
        },
        makeVisible: function(data) {
            if (data) {
                var renderEle = this.getDataRendererElement(data);
                if (renderEle) {
                    $callRAFLater(function() {
                        $DomUtil.scrollIntoView(renderEle, this._getScrollView());
                    }, this);
                }
            }
        },
        _getScrollView: function() {
            return this.getRoot();
        }
    });
    var $IDataRenderer = function(view, data) {
        this._view = view;
        this._data = data;
        this._renderConfig = {};
    };
    $extendClass($IDataRenderer, Object, {
        update: function() {
            var visible = this._isRendererVisible(this._view, this._data);
            if (this._visible !== visible) {
                this._visible = visible;
                this.onVisibleChange(visible);
            }
            this._renderConfig = {};
            if (this._visible === true) {
                this.updateRenderConfig(this._view, this._data, this._renderConfig);
                this.updateRenderer(this._view, this._data, this._renderConfig);
            }
        },
        _isRendererVisible: function(view, data) {
            return view._isVisible(data);
        },
        onVisibleChange: function(visible) {},
        updateRenderConfig: function(view, data, renderConfig) {
            var label_visible = view.getDataViewProperty(data, "label_visible") !== false;
            if (label_visible) {
                var label = view.getLabel(data);
                if (label != null) {
                    renderConfig["label_visible"] = true;
                    renderConfig["label"] = label;
                    renderConfig["label_font"] = view.getDataViewProperty(data, "label_font");
                    renderConfig["label_color"] = view.getDataViewProperty(data, "label_color");
                }
            }
            var info_visible = view.getDataViewProperty(data, "info_visible") !== false;
            if (info_visible) {
                var info = view.getInfo(data);
                if (info != null) {
                    renderConfig["info_visible"] = true;
                    renderConfig["info"] = info;
                    renderConfig["info_font"] = view.getDataViewProperty(data, "info_font");
                    renderConfig["info_color"] = view.getDataViewProperty(data, "info_color");
                }
            }
            renderConfig["selected"] = view.isSelected(data);
            renderConfig["disabled"] = view._isDisabled(data);
        },
        updateRenderer: function(view, data, renderConfig) {
            this.updateRendererStatus();
        },
        updateRendererStatus: function(view, data, renderConfig) {},
        getRenderConfig: function(property) {
            return this._renderConfig[property];
        },
        getViewRenderConfig: function(property) {
            return this._view.getProperty(property);
        },
        updateData: function() {
            this._view._updateData(this._data);
        },
        dispose: function() {}
    });
    var $IDataElementRenderer = function() {
        $IDataElementRenderer.superClass.constructor.apply(this, arguments);
        $domSetStyle(this.getRenderer(), "display", "none");
        this.getRenderer().setAttribute("__z_did_", this._data.id());
    };
    $extendClass($IDataElementRenderer, $IDataRenderer, {
        getRenderer: function() {
            return this._renderer;
        },
        updateRenderConfig: function(view, data, renderConfig) {
            $IDataElementRenderer.superClass.updateRenderConfig.apply(this, arguments);
            var icon = view.getDataRenderProperty(data, "icon");
            if (icon) {
                renderConfig["icon"] = icon;
            }
        },
        updateRendererStatus: function(view, data, renderConfig) {
            $IDataElementRenderer.superClass.updateRendererStatus.apply(this, arguments);
            $domToggleClass(this._renderer, "disabled", this.getRenderConfig("disabled") === true);
            $domToggleClass(this._renderer, "selected", this.getRenderConfig("selected") === true);
        },
        onVisibleChange: function(visible) {
            $domToggleClass(this._renderer, "hidden", visible === false);
            if (visible === false) {
                $domSetStyle(this._renderer, "display", "none");
                $domEmpty(this._renderer);
            } else {
                $domSetStyle(this._renderer, "display", "");
                this.reBuildRenderer();
            }
        },
        reBuildRenderer: function() {}
    });
    var $IViewController = function() {
        this._typeMap = {};
    };
    $extendClass($IViewController, Object, {
        addViewListener: function(type) {
            this._addListener(this._controllerRoot, "view", type);
        },
        removeViewListener: function(type) {
            this._removeListener(this._controllerRoot, "view", type);
        },
        addWindowListener: function(type) {
            this._addListener(window, "window", type);
        },
        removeWindowListener: function(type) {
            this._removeListener(window, "window", type);
        },
        add: function(view) {
            this._view = view;
            this._controllerRoot = view._getControllerRoot();
            (this.getViewDefaultTypes() || []).forEach(this.addViewListener, this);
            (this.getWindowDefaultTypes() || []).forEach(this.addWindowListener, this);
        },
        remove: function() {
            (this.getViewDefaultTypes() || []).forEach(this.removeViewListener, this);
            (this.getWindowDefaultTypes() || []).forEach(this.addWindowListener, this);
            this._view = null;
            this._controllerRoot = null;
            this._typeMap = {};
        },
        update: function() {},
        getViewDefaultTypes: function() {},
        getWindowDefaultTypes: function() {},
        getView: function() {
            return this._view;
        },
        getViewRoot: function() {
            return this._controllerRoot;
        },
        getViewProperty: function(key) {
            return this._view.getProperty(key);
        },
        _addListener: function(ele, prefix, type) {
            var handlerName = this._getHandlerName(prefix, type);
            if (this._typeMap.hasOwnProperty(handlerName)) {
                return;
            }
            var handler = this[handlerName];
            if (!handler) {
                console.error(handlerName + " is null");
                return;
            }
            var iHandler = function(evt) {
                handler.apply(this, [ evt, this.getView() ]);
            };
            this._typeMap[handlerName] = iHandler;
            $domTypeOn(ele, type, iHandler, this);
        },
        _removeListener: function(ele, prefix, type) {
            var handlerName = this._getHandlerName(prefix, type);
            if (this._typeMap.hasOwnProperty(handlerName)) {
                var iHandler = this._typeMap[handlerName];
                $domTypeOff(this._controllerRoot, type, iHandler, this);
                delete this._typeMap[handlerName];
            }
        },
        _getHandlerName: function(prefix, type) {
            var handlerName;
            if (prefix === "window") {
                handlerName = "handle_window_" + type;
            } else if (prefix === "view") {
                handlerName = "handle_" + type;
            }
            return handlerName;
        }
    });
    $mergeObject(z.$, {
        iview: {
            IViewController: $IViewController,
            Data: $Data,
            DataParser: $DataParser,
            IModel: $IModel,
            IAttachProvider: $IAttachProvider,
            IProvider: $IProvider,
            Provider: $Provider,
            ArgsUtil: $ArgsUtil,
            DataLevelUtil: $DataLevelUtil,
            HTMLDataParser: $HTMLDataParser,
            JSONDataParser: $JSONDataParser,
            ModelTypeCheck: $ModelTypeCheck,
            IDataElementRendererView: $IDataElementRendererView,
            IDataRendererView: $IDataRendererView,
            IDataView: $IDataView,
            IView: $IView,
            CheckInterface: $CheckInterface,
            ControllerInterface: $ControllerInterface,
            ExpandInterface: $ExpandInterface,
            HoverInterface: $HoverInterface,
            ModelInterface: $ModelInterface,
            MoveInterface: $MoveInterface,
            OnResizeInterface: $OnResizeInterface,
            RendererViewInterface: $RendererViewInterface,
            SelectInterface: $SelectInterface,
            VisibleInterface: $VisibleInterface,
            IDataElementRenderer: $IDataElementRenderer,
            IDataRenderer: $IDataRenderer
        }
    });
    z.Data = $Data;
    z.Provider = $Provider;
    $mergeObject(z.type, {
        isData: $isData,
        isView: $isView,
        isProvider: $isProvider
    });
    $setSysDefault({
        CVS_VIEW_GRID_LINE_VISIBLE: false,
        CVS_VIEW_GRID_LINE_SPACE: 50,
        CVS_VIEW_GRID_LINE_STROKE: "#e6e6e6",
        CVS_VIEW_GRID_LINE_STROKE_LINE_WIDTH: .6,
        CVS_VIEW_GRID_LINE_AXIS_STROKE_LINE_WIDTH: 1.2,
        CVS_VIEW_LINE_CAP: null,
        CVS_VIEW_LINE_JOIN: null,
        CVS_VIEW_ZOOM_FACTOR: 1.05,
        CVS_VIEW_MAX_ZOOM: 20,
        CVS_VIEW_MIN_ZOOM: .2
    });
    var $GridLineUtil = {
        drawGridLine: function(cvsView, c2d) {
            if (cvsView.getProperty("grid_line_visible") !== true) {
                return;
            }
            var strokeStyle = cvsView.getProperty("grid_line_stroke");
            if (strokeStyle) {
                var _points = $GridLineUtil._calcLinePoints(cvsView);
                var linkPoints = _points.line;
                var axisPoints = _points.axis;
                var strokeAttr = {
                    lineWidth: cvsView.getProperty("grid_line_stroke_line_width"),
                    lineDash: cvsView.getProperty("grid_line_stroke_line_dash")
                };
                if (linkPoints.length > 0) {
                    $saveAndSet2DAttributes(c2d, strokeAttr, function() {
                        $C2DPathUtil.render(c2d, linkPoints, {
                            stroke: strokeStyle
                        });
                    });
                }
                if (axisPoints.length > 0) {
                    strokeAttr.lineWidth = cvsView.getProperty("grid_line_axis_stroke_line_width");
                    $saveAndSet2DAttributes(c2d, strokeAttr, function() {
                        $C2DPathUtil.render(c2d, axisPoints, {
                            stroke: strokeStyle
                        });
                    });
                }
            }
        },
        _calcLinePoints: function(cvsView) {
            var rect = cvsView.getRootSize();
            var zoom = cvsView.getProperty("zoom");
            var grid_line_spacing = cvsView.getProperty("grid_line_space") * zoom;
            var ratio = devicePixelRatio;
            var rw = rect.width * ratio, rh = rect.height * ratio;
            var row = $MathFloor(rh / grid_line_spacing) + 2, col = $MathFloor(rw / grid_line_spacing) + 2;
            var ox = cvsView.getProperty("translate_x"), oy = cvsView.getProperty("translate_y");
            var topRowSize = $MathAbs($MathFloor(oy / grid_line_spacing)) + 1;
            var leftColSize = $MathAbs($MathFloor(ox / grid_line_spacing)) + 1;
            var axisPoints = [];
            var points = [];
            if (oy >= 0 && oy <= rh) {
                axisPoints.push({
                    x: 0,
                    y: oy
                });
                axisPoints.push({
                    x: rw,
                    y: oy,
                    seg: "mt"
                });
            }
            if (ox >= 0 && ox <= rw) {
                axisPoints.push({
                    x: ox,
                    y: 0
                });
                axisPoints.push({
                    x: ox,
                    y: rh,
                    seg: "mt"
                });
            }
            if (oy > 0) {
                for (var topIndex = 1; topIndex < topRowSize; topIndex++) {
                    var topY = oy - grid_line_spacing * topIndex;
                    if (topY >= 0) {
                        points.push({
                            x: 0,
                            y: topY
                        });
                        points.push({
                            x: rw,
                            y: topY,
                            seg: "mt"
                        });
                    }
                }
            } else {
                row += topRowSize;
            }
            for (var bottomIndex = 1; bottomIndex < row; bottomIndex++) {
                var bottomY = oy + grid_line_spacing * bottomIndex;
                if (bottomY <= rh) {
                    points.push({
                        x: 0,
                        y: bottomY
                    });
                    points.push({
                        x: rw,
                        y: bottomY,
                        seg: "mt"
                    });
                }
            }
            if (ox > 0) {
                for (var leftIndex = 1; leftIndex < leftColSize; leftIndex++) {
                    var leftX = ox - grid_line_spacing * leftIndex;
                    if (leftX >= 0) {
                        points.push({
                            x: leftX,
                            y: 0
                        });
                        points.push({
                            x: leftX,
                            y: rh,
                            seg: "mt"
                        });
                    }
                }
            } else {
                col += leftColSize;
            }
            for (var rightIndex = 1; rightIndex < col; rightIndex++) {
                var rightX = ox + grid_line_spacing * rightIndex;
                if (rightX <= rw) {
                    points.push({
                        x: rightX,
                        y: 0
                    });
                    points.push({
                        x: rightX,
                        y: rh,
                        seg: "mt"
                    });
                }
            }
            return {
                axis: axisPoints,
                line: points
            };
        }
    };
    var $PointUtil = {
        isPoint: function(obj) {
            return $isObject(obj) && obj.hasOwnProperty("x") && obj.hasOwnProperty("y");
        }
    };
    var $TransformInterface = function(clazz) {
        return {
            resetTransform: function() {
                this.set({
                    zoom: 1,
                    translate_x: 0,
                    translate_y: 0
                });
            },
            zoomIn: function(center) {
                var zoom = this.getProperty("zoom") * this.getProperty("zoom_factor");
                if (center !== false) {
                    this._zoomCenter(zoom);
                } else {
                    this.zoomByPoint(zoom, {
                        x: 0,
                        y: 0
                    });
                }
            },
            zoomOut: function(center) {
                var zoom = this.getProperty("zoom") / this.getProperty("zoom_factor");
                if (center !== false) {
                    this._zoomCenter(zoom);
                } else {
                    this._zoomByPoint(zoom, {
                        x: 0,
                        y: 0
                    });
                }
            },
            zoomCenter: function(newZoom) {
                this._zoomCenter(newZoom);
            },
            zoomByPoint: function(zoom, point) {
                this._zoomByPoint(zoom, point);
            },
            translate: function(x, y) {
                var point = $MathUtil.getArgsPoint.apply(null, arguments);
                if (point) {
                    this.setProperty("translate_x", point.x);
                    this.setProperty("translate_y", point.y);
                }
            },
            _zoomCenter: function(zoom) {
                var size = this.getRootSize();
                var halfVW = size.width / 2;
                var halfVH = size.height / 2;
                this._zoomByPoint(zoom, {
                    x: halfVW,
                    y: halfVH
                });
            },
            _zoomByPoint: function(zoom, point) {
                point = point || {
                    x: 0,
                    y: 0
                };
                zoom = this._getZoom(zoom);
                var old = this.getProperty("zoom");
                if (zoom === old) {
                    return;
                }
                this.set("zoom", zoom);
                var px = point.x;
                var py = point.y;
                var zoomFactor = zoom / old;
                this.translate(px - (px - this.getProperty("translate_x")) * zoomFactor, py - (py - this.getProperty("translate_y")) * zoomFactor);
            },
            _getZoom: function(zoom) {
                var min = this.get("min_zoom");
                var max = this.get("max_zoom");
                if (zoom < min) {
                    return min;
                }
                if (zoom > max) {
                    return max;
                }
                return zoom;
            },
            getTransformedPoint: function(evtOrRelativePoint) {
                var relativePoint;
                if ($PointUtil.isPoint(evtOrRelativePoint)) {
                    relativePoint = evtOrRelativePoint;
                } else if ($DomEventUtil.isPointerEvent(evtOrRelativePoint)) {
                    relativePoint = this.getEventRelativePoint(evtOrRelativePoint);
                }
                return this._getTransformedPoint(relativePoint);
            },
            getTransformedRect: function(relativeRect) {
                var p1 = this._getTransformedPoint({
                    x: relativeRect.x,
                    y: relativeRect.y
                });
                var p2 = this._getTransformedPoint({
                    x: relativeRect.x + relativeRect.width,
                    y: relativeRect.y + relativeRect.height
                });
                return {
                    x: p1.x,
                    y: p1.y,
                    width: p2.x - p1.x,
                    height: p2.y - p1.y
                };
            },
            getEventRelativePoint: function(evt) {
                var evtOffset = $DomGeom.getEventWindowOffset(evt);
                var viewOffset = $DomGeom.getElementWindowOffset(this.getRoot());
                var rx = evtOffset.x - viewOffset.x;
                var ry = evtOffset.y - viewOffset.y;
                return {
                    x: rx,
                    y: ry
                };
            },
            getDataWindowBounds: function(data, bodyOnly) {
                return this._getDataRelativeBounds(data, bodyOnly, $DomGeom.getElementWindowOffset(this.getRoot()));
            },
            getDataPageBounds: function(data, bodyOnly) {
                return this._getDataRelativeBounds(data, bodyOnly, $DomGeom.getElementPageOffset(this.getRoot()));
            },
            _getDataRelativeBounds: function(data, bodyOnly, offset) {
                if (bodyOnly !== false) {
                    bodyOnly = true;
                }
                var bounds = data.getBounds(this, bodyOnly);
                if (bounds) {
                    var ltPoint = this._getRelativePoint({
                        x: bounds.x,
                        y: bounds.y
                    });
                    var rbPoint = this._getRelativePoint({
                        x: bounds.x + bounds.width,
                        y: bounds.y + bounds.height
                    });
                    offset = offset || {
                        x: 0,
                        y: 0
                    };
                    return {
                        x: ltPoint.x + offset.x,
                        y: ltPoint.y + offset.y,
                        width: rbPoint.x - ltPoint.x,
                        height: rbPoint.y - ltPoint.y
                    };
                }
                return null;
            },
            _getTransformedPoint: function(relativePoint) {
                if (relativePoint == null) {
                    return null;
                }
                var zoom = this.get("zoom");
                var x = (relativePoint.x - this.getProperty("translate_x")) / zoom;
                var y = (relativePoint.y - this.getProperty("translate_y")) / zoom;
                return {
                    x: x,
                    y: y
                };
            },
            _getRelativePoint: function(dataPoint) {
                if (dataPoint == null) {
                    return null;
                }
                var zoom = this.get("zoom");
                var x = dataPoint.x * zoom + this.getProperty("translate_x");
                var y = dataPoint.y * zoom + this.getProperty("translate_y");
                return {
                    x: x,
                    y: y
                };
            }
        };
    };
    var $ControllerCanvasInterface = function(clazz) {
        return {
            _initControllerCanvas: function() {
                this._controllerCanvas = $domCreate("canvas");
                this._controllerC2d = this._controllerCanvas.getContext("2d");
                this._controllerDrawArray = [];
                this._appendCanvas(this._controllerCanvas);
            },
            addControllerDraw: function(draw, context) {
                this._controllerDrawArray.push({
                    draw: draw,
                    context: context
                });
                this.updateControllerCanvas();
            },
            removeControllerDraw: function(draw, context) {
                $removeArrayItem(this._controllerDrawArray, function(item) {
                    return item.draw === draw && item.context === context;
                });
                this.updateControllerCanvas();
            },
            updateControllerCanvas: function() {
                this._drawControllerCanvas();
            },
            _drawControllerCanvas: function() {
                $C2DUtil.clear(this._controllerCanvas);
                var c2d = this._controllerC2d;
                c2d.save();
                var ratio = devicePixelRatio;
                if (ratio !== 1) {
                    c2d.scale(ratio, ratio);
                }
                this._controllerDrawArray.forEach(function(item) {
                    item.draw.apply(item.context, [ c2d ]);
                });
                c2d.restore();
            }
        };
    };
    var $CVSControllerUtil = {
        setCursor: function(controller, cursor) {
            $domSetStyle(controller.getViewRoot(), "cursor", cursor || "default");
        },
        isInteractBodyOnly: function(view) {
            var bounds = view.getProperty("interact_bounds");
            return bounds === "body";
        }
    };
    var $CVSHoverController = function() {
        $CVSHoverController.superClass.constructor.apply(this, arguments);
    };
    $extendClass($CVSHoverController, $IViewController, {
        getViewDefaultTypes: function() {
            return [ "mousemove", "mouseleave" ];
        },
        handle_mousemove: function(evt, view) {
            if (evt.buttons > 0) {
                return;
            }
            if (view.getProperty("hoverable") !== true) {
                return;
            }
            var data = view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
            if (data) {
                if (!view._isDisabled(data) && view._isHoverable(data)) {
                    view._setHoverData(data, true, evt);
                    if (view.getProperty("select_on_hover") === true) {
                        if (view.isSelectable(data)) {
                            if (!view.isSelected(data)) {
                                view.setSelect(data);
                            }
                        }
                    }
                    return;
                }
            }
            view._setHoverData(null, true, evt);
        },
        handle_mouseleave: function(evt, view) {
            view._setHoverData(null, true, evt);
        }
    });
    var $IDataCanvasRenderer = function() {
        $IDataCanvasRenderer.superClass.constructor.apply(this, arguments);
    };
    $extendClass($IDataCanvasRenderer, $IDataRenderer, {
        updateRenderConfig: function(view, data, renderConfig) {
            $IDataCanvasRenderer.superClass.updateRenderConfig.apply(this, arguments);
            this.updateHoverConfig(view, data, renderConfig);
        },
        updateHoverConfig: function(view, data, renderConfig) {
            var isHover = view.isHover(data);
            renderConfig["hover"] = isHover;
            if (isHover !== true) {
                return;
            }
            renderConfig["hover_style"] = view.getDataViewProperty(data, "hover_style");
        },
        draw: function(g2d) {
            if (this._visible !== true) {
                return;
            }
            this._doDraw(g2d);
        },
        _doDraw: function(g2d, drawBodyOnly) {
            if (this._doCustomDraw(g2d, drawBodyOnly) === false) {
                return;
            }
            this.doDraw(g2d, drawBodyOnly);
        },
        _doCustomDraw: function(g2d, drawBodyOnly) {
            var dataDraw = this._data.draw;
            if (dataDraw && dataDraw.apply(this._data, [ g2d, this._data, this._view, drawBodyOnly, this ]) === false) {
                return false;
            }
            return true;
        },
        doDraw: function(g2d, drawBodyOnly) {},
        hits: function(point, bodyOnly) {
            var padding = $MathMax((this.getViewRenderConfig("hit_padding") | 0) / $MathMax(1, this._view.get("zoom")), .5);
            var rect = {
                x: point.x - padding,
                y: point.y - padding,
                width: padding * 2,
                height: padding * 2
            };
            var _this = this;
            return $C2DAlphaUtil.isDrawRectOpaque(function(g2d) {
                _this._hitsDraw(g2d, bodyOnly);
            }, rect);
        },
        _hitsDraw: function(g2d, bodyOnly) {
            return this._doDraw(g2d, bodyOnly);
        },
        contained: function(rect, bodyOnly) {
            var bounds = this.getBounds(bodyOnly);
            if (bounds) {
                return $MathRectUtil.containsRect(rect, bounds);
            }
            return false;
        },
        getBounds: function(bodyOnly) {}
    });
    var $IDataCanvasRendererView = function() {
        this._initCanvasView();
        $IDataCanvasRendererView.superClass.constructor.apply(this, arguments);
        var root = this.getRoot();
        $domSetStyle(root, "width", "100%");
        $domSetStyle(root, "height", "100%");
        $domSetStyle(root, "overflow", "hidden");
        $domSetStyle(root, "position", "relative");
        this._appendCanvas(this._dataCanvas);
        this.addController(new $CVSHoverController());
    };
    $extendClass($IDataCanvasRendererView, $IDataRendererView, $mergeObject({
        ___zdefaults_: {
            onresize: true,
            hoverable: false,
            select_on_hover: false,
            translate_x: 0,
            translate_y: 0,
            zoom: 1,
            zoom_factor: $getDefault("CVS_VIEW_ZOOM_FACTOR"),
            max_zoom: $getDefault("CVS_VIEW_MAX_ZOOM"),
            min_zoom: $getDefault("CVS_VIEW_MIN_ZOOM"),
            grid_line_visible: $getDefault("CVS_VIEW_GRID_LINE_VISIBLE"),
            grid_line_space: $getDefault("CVS_VIEW_GRID_LINE_SPACE"),
            grid_line_stroke: $getDefault("CVS_VIEW_GRID_LINE_STROKE"),
            grid_line_stroke_line_width: $getDefault("CVS_VIEW_GRID_LINE_STROKE_LINE_WIDTH"),
            grid_line_axis_stroke_line_width: $getDefault("CVS_VIEW_GRID_LINE_AXIS_STROKE_LINE_WIDTH"),
            line_cap: $getDefault("CVS_VIEW_LINE_CAP"),
            line_join: $getDefault("CVS_VIEW_LINE_JOIN"),
            interact_bounds: "body",
            update_data_on_transform: true
        },
        _updateDataOnViewChange: function(key, value, old) {
            if (key === "zoom" || key === "translate_x" || key === "translate_y") {
                if (this.getProperty("update_data_on_transform") === false) {
                    return;
                }
            }
            $IDataCanvasRendererView.superClass._updateDataOnViewChange.apply(this, arguments);
        },
        _initCanvasView: function() {
            this._canvasArray = [];
            this._dataCanvas = $domCreate("canvas");
            this._dataC2d = this._dataCanvas.getContext("2d", {
                willReadFrequently: true
            });
        },
        _doUpdate: function() {
            $IDataCanvasRendererView.superClass._doUpdate.apply(this, arguments);
            this.draw();
        },
        _doResizeUpdate: function() {
            $IDataCanvasRendererView.superClass._doResizeUpdate.apply(this, arguments);
            this._resizeCanvas();
            this.draw();
        },
        _resizeCanvas: function() {
            var size = this.getRootSize();
            var width = size.width;
            var height = size.height;
            var rWidth = width * devicePixelRatio;
            var rHeight = height * devicePixelRatio;
            this._canvasArray.forEach(function(cvs) {
                $domSetStyle(cvs, "width", width + "px");
                $domSetStyle(cvs, "height", height + "px");
                cvs.setAttribute("width", rWidth);
                cvs.setAttribute("height", rHeight);
            }, this);
        },
        _appendCanvas: function(canvas) {
            $domSetStyle(canvas, "position", "absolute");
            $domSetStyle(canvas, "left", "0");
            $domSetStyle(canvas, "top", "0");
            this._canvasArray.push(canvas);
            this.getRoot().appendChild(canvas);
        },
        _removeCanvas: function(canvas) {
            $arrayRemoveItem(this._canvasArray, canvas);
            $domRemove(canvas);
        }
    }, {
        getDataAt: function(evtOrRelativePoint, bodyOnly) {
            if (bodyOnly !== false) {
                bodyOnly = true;
            }
            var point = this.getTransformedPoint(evtOrRelativePoint);
            if (point == null) {
                return null;
            }
            return $findArray(this._getDrawDataReverseArray(), function(data) {
                var renderer = this.getDataRenderer(data);
                if (renderer && renderer.hits(point, bodyOnly)) {
                    return true;
                }
            }, this);
        },
        getDataArrayAt: function(evtOrRelativePoint, bodyOnly) {
            if (bodyOnly !== false) {
                bodyOnly = true;
            }
            var tp = this.getTransformedPoint(evtOrRelativePoint);
            if (tp == null) {
                return null;
            }
            return $filterArray(this._getDrawDataReverseArray(), function(data) {
                var renderer = this.getDataRenderer(data);
                if (renderer && renderer.hits(tp, bodyOnly)) {
                    return true;
                }
            }, this);
        },
        getDataArrayAtRect: function(relativeRect, bodyOnly) {
            if (relativeRect == null) {
                return [];
            }
            if (bodyOnly !== false) {
                bodyOnly = true;
            }
            var rect = this.getTransformedRect(relativeRect);
            return $filterArray(this._getDrawDataReverseArray(), function(data) {
                var renderer = this.getDataRenderer(data);
                if (renderer && renderer.contained(rect, bodyOnly)) {
                    return true;
                }
            }, this);
        }
    }, {
        draw: function() {
            var c2d = this._dataC2d;
            $C2DUtil.ctxClear(c2d, this._dataCanvas.width, this._dataCanvas.height);
            this._improveDrawPerf();
            c2d.save();
            var ratio = devicePixelRatio;
            if (ratio !== 1) {
                c2d.scale(ratio, ratio);
            }
            $GridLineUtil.drawGridLine(this, c2d);
            this._setTransform(c2d, ratio);
            this._drawData(c2d);
            c2d.restore();
        },
        _setTransform: function(c2d, ratio) {
            var tx = this.getProperty("translate_x") * ratio;
            var ty = this.getProperty("translate_y") * ratio;
            var zoom = this.get("zoom") * ratio;
            var transform = tx !== 0 || ty !== 0 || zoom !== 1;
            if (transform) {
                c2d.setTransform(zoom, 0, 0, zoom, tx, ty);
            }
        },
        _improveDrawPerf: function() {
            var c2d = this._dataC2d;
            var font = this.getProperty("label_font") || $C2DTextUtil.getSystemFont();
            if (c2d.font !== font) {
                c2d.font = font;
            }
            c2d.textAlign = "center";
            c2d.textBaseline = "middle";
            c2d.lineCap = this.getProperty("line_cap");
            c2d.lineJoin = this.getProperty("line_join");
        },
        _drawData: function(c2d) {
            var dataArray = this.getDrawDataArray(this.getDataArray(false));
            dataArray.forEach(function(data) {
                this._rendererDraw(c2d, data);
            }, this);
            this._draw_data_reverse_array = (dataArray || []).reverse();
        },
        _rendererDraw: function(g2d, data) {
            var renderer = this.getDataRenderer(data);
            if (renderer) {
                renderer.draw(g2d);
            }
        },
        getDrawDataArray: function(dataArray) {
            return dataArray;
        },
        _getDrawDataReverseArray: function() {
            return this._draw_data_reverse_array || [];
        }
    }, $TransformInterface($IDataCanvasRendererView), $MoveInterface($IDataCanvasRendererView), $ControllerCanvasInterface($IDataCanvasRendererView), $HoverInterface($IDataCanvasRendererView)));
    $mergeObject(z.$, {
        cvs_view: {
            CVSControllerUtil: $CVSControllerUtil,
            CVSHoverController: $CVSHoverController,
            ControllerCanvasInterface: $ControllerCanvasInterface,
            TransformInterface: $TransformInterface,
            IDataCanvasRenderer: $IDataCanvasRenderer,
            IDataCanvasRendererView: $IDataCanvasRendererView
        }
    });
    (function(window, undefined) {
        $setSysDefault({
            WIDGET_MESSAGEBOX_CONFIRM_CLASS: "z-button primary",
            WIDGET_MESSAGEBOX_CONFIRM_TEXT: "OK",
            WIDGET_MESSAGEBOX_CANCEL_CLASS: "z-button",
            WIDGET_MESSAGEBOX_CANCEL_TEXT: "Cancel",
            WIDGET_NOTIFICATION_DURATION: 0,
            WIDGET_NOTIFICATION_POSITION: "top_right",
            WIDGET_PAGINATION_LAYOUT: "sizes,pager,total,refresh",
            WIDGET_PAGINATION_PAGE_SIZES: [ 20, 50, 100 ],
            WIDGET_PAGINATION_PAGE_SIZE: 20,
            WIDGET_PAGINATION_TOTAL_TEMPLATE: "<%start%>-<%end%> | <%total%>",
            WIDGET_PAGINATION_PAGER_COUNT: 7,
            WIDGET_MODAL_OPEN_ANIMATION: "z-animation-fadeInDown",
            WIDGET_MODAL_CLOSE_ANIMATION: "z-animation-fadeOutUp"
        });
        var $CommonIconTemplate = {
            to_left: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='15 18 9 12 15 6'></polyline></svg></span>",
            to_right: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='9 18 15 12 9 6'></polyline></svg></span>",
            to_up: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='18 15 12 9 6 15'></polyline></svg></span>",
            to_down: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'></polyline></svg></span>",
            more_h: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='1'></circle><circle cx='19' cy='12' r='1'></circle><circle cx='5' cy='12' r='1'></circle></svg></span>",
            x: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><line x1='18' y1='6' x2='6' y2='18'></line><line x1='6' y1='6' x2='18' y2='18'></line></svg></span>",
            loader: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><line x1='12' y1='2' x2='12' y2='6'></line><line x1='12' y1='18' x2='12' y2='22'></line><line x1='4.93' y1='4.93' x2='7.76' y2='7.76'></line><line x1='16.24' y1='16.24' x2='19.07' y2='19.07'></line><line x1='2' y1='12' x2='6' y2='12'></line><line x1='18' y1='12' x2='22' y2='12'></line><line x1='4.93' y1='19.07' x2='7.76' y2='16.24'></line><line x1='16.24' y1='7.76' x2='19.07' y2='4.93'></line></svg></span>",
            minus: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><line x1='5' y1='12' x2='19' y2='12'></line></svg></span>"
        };
        var $IconTemplate = {
            remove: $CommonIconTemplate.x,
            refresh: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='1 4 1 10 7 10'></polyline><polyline points='23 20 23 14 17 14'></polyline><path d='M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15'></path></svg></span>",
            expand_collapsed: $CommonIconTemplate.to_right,
            expand_expanded: $CommonIconTemplate.to_down,
            checkbox_unchecked: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><rect x='3' y='3' width='18' height='18' rx='2' ry='2'></rect></svg></span>",
            checkbox_checked: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='20 6 9 17 4 12'></polyline></svg></span>",
            checkbox_indeterminate: $CommonIconTemplate.minus,
            sort_asc: $CommonIconTemplate.to_up,
            sort_desc: $CommonIconTemplate.to_down,
            pagination_to_prev: $CommonIconTemplate.to_left,
            pagination_to_next: $CommonIconTemplate.to_right,
            pagination_to_prev_more: $CommonIconTemplate.more_h,
            pagination_to_next_more: $CommonIconTemplate.more_h,
            tabs_scroll_to_left_arrow: $CommonIconTemplate.to_left,
            tabs_scroll_to_right_arrow: $CommonIconTemplate.to_right,
            tabs_scroll_to_up_arrow: $CommonIconTemplate.to_up,
            tabs_scroll_to_down_arrow: $CommonIconTemplate.to_down,
            notify_success: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'><path d='M22 11.08V12a10 10 0 1 1-5.93-9.14'></path><polyline points='22 4 12 14.01 9 11.01'></polyline></svg></span>",
            notify_info: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'></circle><line x1='12' y1='16' x2='12' y2='12'></line><line x1='12' y1='8' x2='12' y2='8'></line></svg></span>",
            notify_warning: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'></circle><line x1='12' y1='8' x2='12' y2='12'></line><line x1='12' y1='16' x2='12' y2='16'></line></svg></span>",
            notify_error: "<span><svg xmlns='http://www.w3.org/2000/svg' class='zw-svg-icon' width='1em' height='1em' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='10'></circle><line x1='15' y1='9' x2='9' y2='15'></line><line x1='9' y1='9' x2='15' y2='15'></line></svg></span>"
        };
        var $CheckInterfaceDefault = function(viewDefault) {
            return $mergeObject({
                checkbox_visible: false,
                checkbox_unchecked_icon_template: $IconTemplate.checkbox_unchecked,
                checkbox_checked_icon_template: $IconTemplate.checkbox_checked,
                checkbox_indeterminate_icon_template: $IconTemplate.checkbox_indeterminate,
                three_states_check: true,
                check_on_click: false
            }, viewDefault);
        };
        var $ExpandInterfaceDefault = function(viewDefault) {
            return $mergeObject({
                expand_icon_visible: true,
                expand_collapsed_icon_template: $IconTemplate.expand_collapsed,
                expand_expanded_icon_template: $IconTemplate.expand_expanded,
                expand_on_click: false,
                expand_on_dbl_click: false,
                accordion: false
            }, viewDefault);
        };
        var $SortDefault = function(viewDefault) {
            return $mergeObject({
                sortable: false,
                sort_mode: "single",
                multiple_sort_modifier_key: null,
                sort_orders: [ "asc", "desc", null ],
                sort_asc_icon_template: $IconTemplate.sort_asc,
                sort_desc_icon_template: $IconTemplate.sort_desc
            }, viewDefault);
        };
        var $ColumnMinimizeDefault = function(viewDefault) {
            return $mergeObject({
                minimize_icon_template: $CommonIconTemplate.minus,
                minimize_width: 20,
                minimize_label: "..."
            }, viewDefault);
        };
        var $ContentUtil = {
            getContentInfo: function(content) {
                if (content) {
                    var _type, _content;
                    if ($isString(content)) {
                        if (content.startsWith("url:")) {
                            _type = "url";
                            _content = content.substr(4);
                        } else if (content.startsWith("element:")) {
                            _type = "element";
                            _content = content.substr(8);
                        } else {
                            _type = "string";
                            _content = content;
                        }
                    } else if ($DomType.isElement(content)) {
                        _type = "element";
                        _content = content;
                    } else if ($isObject(content)) {
                        _type = content.type;
                        _content = content.content;
                    }
                    return {
                        type: _type,
                        content: _content
                    };
                }
                return null;
            },
            getContentElement: function(content) {
                var contentInfo = $ContentUtil.getContentInfo(content);
                if (contentInfo && contentInfo.type === "element") {
                    var _content = contentInfo.content;
                    if (_content) {
                        return $domQueryElement(_content);
                    }
                }
                return null;
            },
            getLabelContent: function(props) {
                if ($isObject(props)) {
                    return props;
                }
                return {
                    content: props == null ? "" : props + ""
                };
            },
            getContentObject: function(content) {
                var contentInfo = $ContentUtil.getContentInfo(content);
                if (contentInfo) {
                    var _type = contentInfo.type, _content = contentInfo.content, _contentEle, _contentReleaseConfig;
                    if (_content) {
                        if (_type === "string") {
                            _contentEle = $domCreate("div", "text-content");
                            _contentEle.innerHTML = _content;
                        } else if (_type === "element") {
                            _contentEle = $domQueryElement(_content);
                            if (_contentEle) {
                                var parentNode = _contentEle._z_$_init_parentNode || _contentEle.parentNode;
                                _contentEle._z_$_init_parentNode = parentNode;
                                _contentReleaseConfig = {
                                    parent: parentNode,
                                    display: $domGetStyle(_contentEle, "display")
                                };
                            }
                        } else if (_type === "url") {
                            _contentEle = $ContentUtil.createContentIFrame(_content);
                        }
                        if (_contentEle) {
                            return {
                                type: _type,
                                contentEle: _contentEle,
                                contentReleaseConfig: _contentReleaseConfig
                            };
                        }
                    }
                }
                return null;
            },
            createContentIFrame: function(url) {
                var _if = $domCreate("iframe");
                _if.src = url;
                return _if;
            },
            releaseContent: function(contentObj) {
                if (contentObj) {
                    var contentReleaseConfig = contentObj.contentReleaseConfig;
                    var contentEle = contentObj.contentEle;
                    $domRemove(contentEle);
                    if (contentReleaseConfig) {
                        var oldParent = contentReleaseConfig.parent;
                        if (oldParent) {
                            oldParent.appendChild(contentEle);
                        }
                        delete contentEle._z_$_init_parentNode;
                        $domSetStyle(contentEle, "display", contentReleaseConfig.display);
                    }
                }
            },
            showContent: function(contentObj) {
                if (contentObj) {
                    contentObj.vislbe = true;
                    var type = contentObj.type;
                    var contentEle = contentObj.contentEle;
                    if (type === "string" || type === "element") {
                        $domSetStyle(contentEle, "display", "block");
                    } else if (type === "url") {
                        $domRemoveStyle(contentEle, "visibility");
                        $domRemoveStyle(contentEle, "opacity");
                        $domRemoveStyle(contentEle, "width");
                        $domRemoveStyle(contentEle, "height");
                    }
                }
            },
            hideContent: function(contentObj) {
                if (contentObj) {
                    contentObj.vislbe = false;
                    var type = contentObj.type;
                    var contentEle = contentObj.contentEle;
                    if (type === "string" || type === "element") {
                        $domSetStyle(contentEle, "display", "none");
                    } else if (type === "url") {
                        $domSetStyle(contentEle, "visibility", "hidden");
                        $domSetStyle(contentEle, "opacity", 0);
                        $domSetStyle(contentEle, "width", 0);
                        $domSetStyle(contentEle, "height", 0);
                    }
                }
            }
        };
        var $WViewUtil = {
            addWidgetClass: function(viewRoot) {
                $domAddClass(viewRoot, "z-widget");
                viewRoot.setAttribute("tabindex", -1);
            },
            isEvtInRendererNode: function(evt) {
                var target = evt.target;
                while (target && target !== document) {
                    if (target.getAttribute("role") === "node") {
                        return true;
                    }
                    target = target.parentNode;
                }
                return false;
            },
            preventDefault: function(evt) {
                evt.preventDefault();
            },
            findNextUsableDataByDom: function(view, currentEle) {
                var data;
                var renderEleArray = $domQueryAll("[__z_did_]", view.getRendererRootContainer());
                if (renderEleArray.length > 0) {
                    if (currentEle) {
                        var siblingEleArray = $filterArray(renderEleArray, function(item) {
                            return item.parentNode === currentEle.parentNode;
                        });
                        data = $WViewUtil._findNextUsableDataByArray(view, siblingEleArray, currentEle);
                        if (data) {
                            return data;
                        }
                    }
                    data = $WViewUtil._findNextUsableDataByArray(view, renderEleArray, currentEle);
                }
                return data;
            },
            _findNextUsableDataByArray: function(view, eleArray, currentEle) {
                var data;
                var count = eleArray.length;
                if (count > 0) {
                    var index = -1;
                    if (currentEle) {
                        index = eleArray.indexOf(currentEle);
                    } else {
                        index = -1;
                    }
                    for (var n = index + 1; n < count; n++) {
                        data = $WViewUtil._isRenderDataUsable(view, eleArray[n]);
                        if (data) {
                            return data;
                        }
                    }
                    for (var p = index - 1; p >= 0; p--) {
                        data = $WViewUtil._isRenderDataUsable(view, eleArray[p]);
                        if (data) {
                            return data;
                        }
                    }
                }
            },
            _isRenderDataUsable: function(view, renderEle) {
                var did = renderEle.getAttribute("__z_did_");
                var itemData = $findArray(view.getDataArray(false), function(data) {
                    return data.id() === did;
                });
                if (itemData) {
                    if (view.isVisible(itemData) && !view._isDisabled(itemData) && view.isSelectable(itemData)) {
                        return itemData;
                    }
                }
            }
        };
        var $ListViewRenderUtil = {
            initAllDataRenderer: function(view) {
                view._getSortDataArray(view.getDataArray(false)).forEach(function(data) {
                    var renderer = view.createDataRenderer(data);
                    if (renderer) {
                        view._rendererArrayMap.add(data.id(), renderer);
                        var rendererEle = renderer.getRenderer();
                        if (rendererEle) {
                            view.getRendererContainer(data).appendChild(rendererEle);
                        }
                    }
                });
            },
            reorderAllDataRenderer: function(view) {
                view._getSortDataArray(view.getDataArray(false)).forEach(function(data) {
                    var renderer = view.getDataRenderer(data);
                    if (renderer) {
                        var rendererEle = renderer.getRenderer();
                        if (rendererEle) {
                            view.getRendererContainer(data).appendChild(rendererEle);
                        }
                    }
                });
            },
            insertElementRenderer: function(view, data, renderer) {
                var dataArray = view._getSortDataArray(view.getDataArray(false));
                var index = dataArray.indexOf(data);
                var dataCount = dataArray.length;
                var nextDataRender, nextRendererEle;
                for (var i = index + 1; i < dataCount; i++) {
                    nextDataRender = view.getDataRenderer(dataArray[i]);
                    if (nextDataRender) {
                        nextRendererEle = nextDataRender.getRenderer();
                        if (nextRendererEle) {
                            nextRendererEle.parentNode.insertBefore(renderer.getRenderer(), nextRendererEle);
                            return;
                        }
                    }
                }
                view.getRendererContainer(data).appendChild(renderer.getRenderer());
            }
        };
        var $LevelViewRenderUtil = {
            initAllDataRenderer: function(view) {
                view._getSortDataArray(view.getProvider().toRootArray(false)).forEach(function(data) {
                    $LevelViewRenderUtil.appendDataRenderer(view, data);
                });
            },
            appendDataRenderer: function(view, data) {
                var renderer = view.createDataRenderer(data);
                if (renderer) {
                    view._rendererArrayMap.add(data.id(), renderer);
                    var rendererEle = renderer.getRenderer();
                    if (rendererEle) {
                        view.getRendererContainer(data).appendChild(rendererEle);
                        $LevelViewRenderUtil.appendDataChildrenRenderer(view, data);
                    }
                }
            },
            appendDataChildrenRenderer: function(view, data) {
                var children = $filterArray(data.getChildren(false), view.containsData, view);
                if (children.length > 0) {
                    children = view._getSortDataArray(children);
                    children.forEach(function(child) {
                        $LevelViewRenderUtil.appendDataRenderer(view, child);
                    });
                }
            },
            reorderAllDataRenderer: function(view) {
                view._getSortDataArray(view.getProvider().toRootArray(false)).forEach(function(data) {
                    $LevelViewRenderUtil.reAppendDataRenderer(view, data);
                });
            },
            reAppendDataRenderer: function(view, data) {
                var renderer = view.getDataRenderer(data);
                if (renderer) {
                    var rendererEle = renderer.getRenderer();
                    if (rendererEle) {
                        view.getRendererContainer(data).appendChild(rendererEle);
                        $LevelViewRenderUtil.reAppendDataChildrenRenderer(view, data);
                    }
                }
            },
            reAppendDataChildrenRenderer: function(view, data) {
                var children = $filterArray(data.getChildren(false), view.containsData, view);
                if (children.length > 0) {
                    children = view._getSortDataArray(children);
                    children.forEach(function(child) {
                        $LevelViewRenderUtil.reAppendDataRenderer(view, child);
                    });
                }
            },
            insertElementRenderer: function(view, data, renderer, isNewAdd) {
                var siblingArray = view._getSortDataArray($DataLevelUtil.getAddedSiblingArray(view.getProvider(), data));
                var dataIndex = siblingArray.indexOf(data);
                var nextData = siblingArray[dataIndex + 1];
                if (nextData) {
                    var nextDataRenderer = view.getDataRenderer(nextData);
                    var nextDataRendererEle = nextDataRenderer.getRenderer();
                    nextDataRendererEle.parentNode.insertBefore(renderer.getRenderer(), nextDataRendererEle);
                } else {
                    view.getRendererContainer(data).appendChild(renderer.getRenderer());
                }
                if (isNewAdd === true) {
                    $LevelViewRenderUtil.appendDataChildrenRenderer(view, data);
                }
            },
            removeDataRenderer: function(view, data) {
                if (view.getDataRenderer(data)) {
                    view._removeDataRenderer(data);
                    $LevelViewRenderUtil.removeDataChildrenRenderer(view, data);
                }
            },
            removeDataChildrenRenderer: function(view, data) {
                var children = $filterArray(data.getChildren(false), view.containsData, view);
                if (children.length > 0) {
                    children.forEach(function(child) {
                        $LevelViewRenderUtil.removeDataRenderer(view, child);
                    });
                }
            }
        };
        var $LevelListViewRenderUtil = {
            appendDataChildrenRenderer: function(view, data) {
                var children = $DataLevelUtil.getAddedChildren(view.getProvider(), data);
                if (children.length > 0) {
                    children = view._getSortDataArray(children);
                    children.forEach(function(child) {
                        var renderer = view.createDataRenderer(child);
                        if (renderer) {
                            view._rendererArrayMap.add(child.id(), renderer);
                            var rendererEle = renderer.getRenderer();
                            if (rendererEle) {
                                $LevelListViewRenderUtil.insertElementRenderer(view, child, renderer, true);
                            }
                        }
                    });
                }
            },
            insertElementRenderer: function(view, data, renderer, isNewAdd) {
                var nextData = $LevelListViewRenderUtil._getNextData(view, data);
                if (nextData) {
                    var nextDataRenderer = view.getDataRenderer(nextData);
                    var nextDataRendererEle = nextDataRenderer.getRenderer();
                    nextDataRendererEle.parentNode.insertBefore(renderer.getRenderer(), nextDataRendererEle);
                } else {
                    view.getRendererContainer(data).appendChild(renderer.getRenderer());
                }
                if (isNewAdd === true) {
                    $LevelListViewRenderUtil.appendDataChildrenRenderer(view, data);
                }
            },
            _getNextData: function(view, data, checkChildren) {
                if (checkChildren !== false) {
                    var children = $DataLevelUtil.getAddedChildren(view.getProvider(), data);
                    if (children.length > 0) {
                        return view._getSortDataArray(children)[0];
                    }
                }
                var siblingArray = view._getSortDataArray($DataLevelUtil.getAddedSiblingArray(view.getProvider(), data));
                var nextData = siblingArray[siblingArray.indexOf(data) + 1];
                if (nextData) {
                    return nextData;
                }
                data = data.getProperty("parent");
                if (data) {
                    return $LevelListViewRenderUtil._getNextData(view, data, false);
                }
            },
            updateDataRenderer: function(view, data) {
                var renderer = view.getDataRenderer(data);
                if (renderer) {
                    var rendererEle = renderer.getRenderer();
                    if (rendererEle) {
                        $LevelListViewRenderUtil.insertElementRenderer(view, data, renderer);
                        var children = $DataLevelUtil.getAddedChildren(view.getProvider(), data);
                        if (children.length > 0) {
                            children = view._getSortDataArray(children);
                            children.forEach(function(child) {
                                $LevelListViewRenderUtil.updateDataRenderer(view, child);
                            });
                        }
                    }
                }
            }
        };
        var $LevelViewVisibleUtil = {
            getVisibleChildren: function(view, data) {
                return $filterArray(data.getChildren(false), function(child) {
                    return view.containsData(child) && view._isLevelVisible(child);
                });
            },
            hasChildrenVisible: function(view, data) {
                return $LevelViewVisibleUtil.getVisibleChildren(view, data).length > 0;
            }
        };
        var $RenderNodeUtil = {
            initRenderNode: function(renderer) {
                renderer._nodeWrapper = $domCreate("a", "node");
                renderer._nodeWrapper.setAttribute("role", "node");
                renderer._inWrapper = $domCreate("div", "in");
                renderer._nodeWrapper.appendChild(renderer._inWrapper);
                renderer.getRenderer().appendChild(renderer._nodeWrapper);
            },
            updateRenderCheckConfig: function(renderer, view, data, renderConfig) {
                if (view.getDataViewProperty(data, "checkbox_visible") === true) {
                    renderConfig["checkbox_visible"] = true;
                    renderConfig["checked"] = view.isChecked(data);
                    renderConfig["checkable"] = view.isCheckable(data);
                }
            },
            updateRenderLevelCheckConfig: function(renderer, view, data, renderConfig) {
                if (renderer.getRenderConfig("checkbox_visible") === true) {
                    if (renderer.getRenderConfig("checked") !== true && view._isTreeStatesCheck()) {
                        renderConfig["indeterminate_checked"] = view._hasChildrenChecked(data);
                    }
                }
            },
            updateRenderRemoveConfig: function(renderer, view, data, renderConfig) {
                renderConfig["remove_icon_visible"] = view.getDataViewProperty(data, "remove_icon_visible") === true;
            },
            updateRenderExpandConfig: function(renderer, view, data, renderConfig) {
                var hasChildren = view.hasChildrenVisible(data);
                renderConfig["has_children"] = hasChildren;
                if (hasChildren) {
                    renderConfig["expanded"] = view.isExpanded(data);
                    renderConfig["expand_icon_visible"] = view.getDataViewProperty(data, "expand_icon_visible") !== false;
                    renderConfig["expandable"] = view.isExpandable(data);
                }
            },
            updateRendererCheck: function(renderer, view, data, renderConfig) {
                if (renderer.getRenderConfig("checkbox_visible") === true) {
                    var checkEle = $RenderNodeUtil._getCheckboxWrapper(renderer);
                    checkEle.innerHTML = $RenderNodeUtil._getCheckboxTemplate(renderer);
                    renderer.insertToNodeWrapperFirst(checkEle);
                } else {
                    if (renderer._checkBoxWrapper) {
                        $domRemove(renderer._checkBoxWrapper);
                    }
                }
            },
            _getCheckboxTemplate: function(renderer) {
                if (renderer.getRenderConfig("checked") === true) {
                    return renderer.getViewRenderConfig("checkbox_checked_icon_template");
                } else {
                    if (renderer.getRenderConfig("indeterminate_checked") === true) {
                        return renderer.getViewRenderConfig("checkbox_indeterminate_icon_template");
                    }
                    return renderer.getViewRenderConfig("checkbox_unchecked_icon_template");
                }
            },
            _getCheckboxClass: function(renderer) {
                var clsArray = [ "checkbox" ];
                if (renderer.getRenderConfig("checked") === true) {
                    clsArray.push("checked");
                } else {
                    if (renderer.getRenderConfig("indeterminate_checked") === true) {
                        clsArray.push("indeterminate");
                    } else {
                        clsArray.push("unchecked");
                    }
                }
                if (renderer.getRenderConfig("checkable") === true) {
                    clsArray.push("checkable");
                } else {
                    clsArray.push("uncheckable");
                }
                return clsArray.join(" ");
            },
            _getCheckboxWrapper: function(renderer) {
                if (!renderer._checkBoxWrapper) {
                    renderer._checkBoxWrapper = $domCreate("span", "checkbox");
                    renderer._checkBoxWrapper.setAttribute("__z_dop_", "check");
                }
                return renderer._checkBoxWrapper;
            },
            updateRendererRemove: function(renderer, view, data, renderConfig) {
                if (renderer.getRenderConfig("remove_icon_visible") === true) {
                    var removeEle = $RenderNodeUtil._getRemoveWrapper(renderer);
                    renderer.appendToNodeWrapper(removeEle);
                } else {
                    if (renderer._removeWrapper) {
                        $domRemove(renderer._removeWrapper);
                    }
                }
            },
            _getRemoveWrapper: function(renderer) {
                if (!renderer._removeWrapper) {
                    renderer._removeWrapper = $domCreate("span", "remove");
                    renderer._removeWrapper.innerHTML = renderer.getViewRenderConfig("remove_icon_template");
                    renderer._removeWrapper.setAttribute("__z_dop_", "remove");
                }
                return renderer._removeWrapper;
            },
            updateRendererExpand: function(renderer, view, data, renderConfig) {
                if (renderer.getRenderConfig("expand_icon_visible") === true) {
                    var expandWrapper = $RenderNodeUtil._getExpandWrapper(renderer);
                    expandWrapper.innerHTML = renderer._getExpandTemplate();
                    $domSetClass(expandWrapper, $RenderNodeUtil._getExpandClass(renderer));
                    renderer.insertToNodeWrapperFirst(expandWrapper);
                } else {
                    if (renderer._expandWrapper) {
                        $domRemove(renderer._expandWrapper);
                    }
                }
            },
            _getExpandTemplate: function(renderer) {
                if (renderer.getRenderConfig("expanded") === true) {
                    return renderer.getViewRenderConfig("expand_expanded_icon_template");
                } else {
                    return renderer.getViewRenderConfig("expand_collapsed_icon_template");
                }
            },
            _getExpandClass: function(renderer) {
                var clsArray = [ "expand" ];
                if (renderer.getRenderConfig("expanded") === true) {
                    clsArray.push("expanded");
                } else {
                    clsArray.push("collapsed");
                }
                if (renderer.getRenderConfig("expandable") === true) {
                    clsArray.push("expandable");
                } else {
                    clsArray.push("unexpandable");
                }
                return clsArray.join(" ");
            },
            _getExpandWrapper: function(renderer) {
                if (!renderer._expandWrapper) {
                    renderer._expandWrapper = $domCreate("span");
                    renderer._expandWrapper.setAttribute("__z_dop_", "expand");
                }
                return renderer._expandWrapper;
            },
            updateRenderIn: function(renderer, view, data, renderConfig) {
                var inWrapper = renderer._inWrapper;
                $domEmpty(inWrapper);
                var renderFunc = view.render;
                if ($isFunction(renderFunc)) {
                    if (renderFunc.apply(view, [ data, inWrapper, renderer._renderer ]) === false) {
                        return;
                    }
                } else {
                    var template = renderer.getRenderConfig("template");
                    if (template) {
                        inWrapper.innerHTML = $renderTemplate(template, data.getProperties(false));
                        return;
                    }
                }
                var icon = renderer.getRenderConfig("icon");
                if (icon) {
                    var iconIMG = $domCreate("img");
                    iconIMG.setAttribute("src", icon);
                    inWrapper.appendChild(iconIMG);
                }
                if (renderer.getRenderConfig("label_visible") === true) {
                    var labelSpan = $domCreate("span", "label");
                    labelSpan.innerHTML = renderer.getRenderConfig("label");
                    inWrapper.appendChild(labelSpan);
                }
            },
            updateRenderAttributes: function(renderer, view, data, renderConfig) {
                if (renderer._nodeAttributes) {
                    $eachObject(renderer._nodeAttributes, function(attr, value) {
                        $RenderNodeUtil._removeNodeWrapperAttribute(renderer, attr, value);
                    });
                }
                renderer._nodeAttributes = renderer.getRenderConfig("attributes");
                if (renderer._nodeAttributes) {
                    $eachObject(renderer._nodeAttributes, function(attr, value) {
                        $RenderNodeUtil._setNodeWrapperAttribute(renderer, attr, value);
                    });
                }
            },
            _removeNodeWrapperAttribute: function(renderer, attr, value) {
                var _renderer = renderer.getRenderer();
                if (attr === "class") {
                    $domRemoveClass(_renderer, value);
                } else {
                    _renderer.removeAttribute(attr, value);
                }
            },
            _setNodeWrapperAttribute: function(renderer, attr, value) {
                var _renderer = renderer.getRenderer();
                if (attr === "class") {
                    $domAddClass(_renderer, value);
                } else {
                    _renderer.setAttribute(attr, value);
                }
            }
        };
        var $WAnimationUtil = {
            startAnimation: function(ele, animationCls, endCallBack, context) {
                if (!ele) {
                    return;
                }
                if (animationCls && ele) {
                    var _animationComplete = function() {
                        if (endCallBack) {
                            endCallBack.apply(context);
                        }
                        $domOff(ele, "animationend", _animationComplete);
                        delete ele._animationendListener_$;
                        $domRemoveClass(ele, animationCls);
                    };
                    $domOn(ele, "animationend", _animationComplete);
                    ele._animationendListener_$ = _animationComplete;
                    $domAddClass(ele, animationCls);
                } else {
                    if (endCallBack) {
                        endCallBack.apply(context);
                    }
                }
            },
            completeAnimation: function(ele) {
                if (!ele) {
                    return;
                }
                var animationComplete = ele._animationendListener_$;
                if (animationComplete) {
                    animationComplete();
                    delete ele._animationendListener_$;
                }
            }
        };
        var $HTMLWidgetParser = {
            VIEW_ATTR_TYPE_MAP: {
                label_visible: "boolean",
                expand_icon_visible: "boolean",
                checkbox_visible: "boolean",
                remove_icon_visible: "boolean",
                selectable: "boolean",
                checkable: "boolean",
                expandable: "boolean",
                select_on_hover: "boolean",
                expand_on_click: "boolean",
                expand_on_dbl_click: "boolean",
                make_visible_on_select: "boolean",
                accordion: "boolean",
                auto_select: "boolean",
                three_states_check: "boolean",
                check_on_click: "boolean",
                sortable: "boolean"
            },
            VIEW_ATTR_METHOD_MAP: {
                on_data_click: "onDataClick",
                on_data_dblclick: "onDataDblClick",
                on_expand: "onExpand",
                on_collapse: "onCollapse"
            },
            VIEW_ATTR_INIT_METHOD_MAP: {
                init_expand_all: "expandAll"
            },
            DATA_ATTR_TYPE_MAP: {
                visible: "boolean",
                label_visible: "boolean",
                expand_icon_visible: "boolean",
                checkbox_visible: "boolean",
                remove: "boolean",
                selectable: "boolean",
                checkable: "boolean",
                expandable: "boolean",
                remove_icon_visible: "boolean",
                disabled: "boolean"
            },
            VIEWS: {
                "zw-pagination": {
                    level: false,
                    view: "Pagination"
                },
                "zw-grid": {
                    level: false,
                    view: "Grid",
                    parse: function(view, viewItem, attrConverter) {
                        var thArray = $domQueryAll("tr>th", viewItem);
                        var dataArray = [];
                        if (thArray.length > 0) {
                            var thTrArray = [];
                            thArray.forEach(function(th) {
                                var tr = th.parentNode;
                                if (thTrArray.indexOf(tr) < 0) {
                                    thTrArray.push(tr);
                                }
                            });
                            var columnArray = [];
                            thTrArray.forEach(function(tr) {
                                columnArray = $mergeArray(columnArray, $HTMLDataParser.parseToObjectArray(tr, true, attrConverter));
                            });
                            var columnCount = columnArray.length;
                            var tdArray = $domQueryAll("tr>td", viewItem);
                            var dataObj;
                            tdArray.forEach(function(td, index) {
                                if (index % columnCount === 0) {
                                    dataObj = {};
                                    $HTMLDataParser.parseAttributes(td.parentNode, dataObj);
                                    dataArray.push(dataObj);
                                }
                                var column = columnArray[index % columnCount];
                                dataObj[column.field] = td.innerHTML;
                            });
                            if ($isFunction(attrConverter)) {
                                dataArray.forEach(function(item) {
                                    $HTMLDataParser._convertItemAttr(item, attrConverter);
                                });
                            }
                            view.setColumns(columnArray);
                        }
                        return dataArray;
                    }
                },
                "zw-listview": {
                    level: false,
                    view: "ListView"
                },
                "zw-tree": {
                    level: true,
                    view: "Tree"
                },
                "zw-collapse": {
                    level: false,
                    view: "Collapse"
                },
                "zw-carousel": {
                    level: false,
                    view: "Carousel"
                },
                "zw-tabs": {
                    level: false,
                    view: "Tabs"
                }
            },
            parse: function(app, root) {
                app = app || {};
                $eachObject($HTMLWidgetParser.VIEWS, function(tagName, viewConfig) {
                    var viewArray = z.dom.queryAll(tagName, root);
                    if (viewArray.length === 0) {
                        return;
                    }
                    $eachArray(viewArray, function(viewItem) {
                        $HTMLWidgetParser.parseView(tagName, viewItem, app);
                    });
                });
            },
            parseView: function(viewType, viewElement, app) {
                app = app || {};
                var viewConfig = $HTMLWidgetParser.VIEWS[viewType];
                var viewAttrTypeMap = $HTMLWidgetParser.VIEW_ATTR_TYPE_MAP;
                var viewAttrConverter = function(attrName, attrValue) {
                    return $HTMLWidgetParser._convertAttrValue(attrName, attrValue, viewAttrTypeMap, app);
                };
                var dataAttrTypeMap = $HTMLWidgetParser.DATA_ATTR_TYPE_MAP;
                var dataAttrConverter = function(attrName, attrValue) {
                    return $HTMLWidgetParser._convertAttrValue(attrName, attrValue, dataAttrTypeMap, app);
                };
                var viewMethodAttrMap = $HTMLWidgetParser.VIEW_ATTR_METHOD_MAP;
                var viewInitMethodAttrMap = $HTMLWidgetParser.VIEW_ATTR_INIT_METHOD_MAP;
                var viewProps = $HTMLWidgetParser.parseViewArgs(viewElement, viewAttrConverter);
                var var_name, viewData;
                if (viewProps.hasOwnProperty("var_name")) {
                    var_name = viewProps.var_name;
                    delete viewProps.var_name;
                }
                if (viewProps.hasOwnProperty("data")) {
                    viewData = app[viewProps.data];
                    delete viewProps.data;
                }
                var view = $ClassUtil.createInstance(viewConfig.view, [ viewProps ]);
                if (!view) {
                    return;
                }
                if (var_name) {
                    app[var_name] = view;
                }
                var data;
                if ($isFunction(viewConfig.parse)) {
                    data = viewConfig.parse(view, viewElement, dataAttrConverter);
                } else {
                    data = $HTMLDataParser.parseToObjectArray(viewElement, viewConfig.level === true, dataAttrConverter);
                }
                data = $mergeArray(data, viewData);
                if (view.addData) {
                    var dataArray = $JSONDataParser.parse(data, app.data_keyword_mapping);
                    var selectedDataArray = [], checkedDataArray = [], expandedDataArray = [];
                    dataArray.forEach(function(data) {
                        $HTMLWidgetParser.filterDataAttach(data, "selected", selectedDataArray);
                        $HTMLWidgetParser.filterDataAttach(data, "checked", checkedDataArray);
                        $HTMLWidgetParser.filterDataAttach(data, "expanded", expandedDataArray);
                    });
                    view.addData(dataArray);
                    $HTMLWidgetParser.setViewAttachData(view, view.addSelect, selectedDataArray);
                    $HTMLWidgetParser.setViewAttachData(view, view.addCheck, checkedDataArray);
                    $HTMLWidgetParser.setViewAttachData(view, view.expand, expandedDataArray);
                }
                $HTMLWidgetParser.callViewInitMethod(view, viewProps, viewInitMethodAttrMap);
                $HTMLWidgetParser.setViewCallBackMethod(view, viewProps, app, viewMethodAttrMap);
                viewElement.parentNode.insertBefore(view.getRoot(), viewElement.nextSibling);
                view.update();
                $domRemove(viewElement);
                return view;
            },
            parseViewArgs: function(viewElement, attrConverter) {
                var props = {};
                $HTMLDataParser.parseAttributes(viewElement, props);
                $HTMLDataParser.parseTemplate(viewElement, props);
                if ($isFunction(attrConverter)) {
                    $eachObject(props, function(prop, value) {
                        props[prop] = attrConverter(prop, value);
                    });
                }
                return props;
            },
            callViewInitMethod: function(view, props, viewInitMethodAttrMap) {
                $eachObject(props, function(prop, value) {
                    if (viewInitMethodAttrMap.hasOwnProperty(prop)) {
                        var viewFunc = view[viewInitMethodAttrMap[prop]];
                        if ($isFunction(viewFunc)) {
                            view.removeProperty(prop);
                            viewFunc.apply(view, []);
                        }
                    }
                });
            },
            setViewCallBackMethod: function(view, props, app, viewMethodAttrMap) {
                $eachObject(props, function(prop, value) {
                    if (viewMethodAttrMap.hasOwnProperty(prop)) {
                        var func = app[value];
                        if (func) {
                            view.setCallBack(viewMethodAttrMap[prop], func, app);
                        }
                        view.removeProperty(prop);
                    }
                });
                return props;
            },
            filterDataAttach: function(data, attach, attachedDataArray) {
                if (data.getProperty(attach) === "true") {
                    attachedDataArray.push(data);
                    data.removeProperty(attach);
                }
                return attachedDataArray;
            },
            setViewAttachData: function(view, viewMethod, attachedDataArray) {
                if (attachedDataArray.length > 0 && viewMethod) {
                    viewMethod.apply(view, [ attachedDataArray ]);
                }
            },
            _convertAttrValue: function(attrName, attrValue, typeMap, app) {
                if (typeMap.hasOwnProperty(attrName)) {
                    var valueType = typeMap[attrName];
                    if (valueType === "boolean") {
                        return attrValue === "true";
                    }
                    if (valueType === "app_value") {
                        attrValue = app[attrValue];
                    }
                }
                return attrValue;
            }
        };
        var $ContentInterface = function(clazz) {
            return {
                setCurrentContent: function(contentObject, release) {
                    if (release === true) {
                        $ContentUtil.releaseContent(this._currentContentObj);
                    }
                    this._currentContentObj = contentObject;
                    if (this._currentContentObj) {
                        this.appendContent(this._currentContentObj);
                        this._showContent(this._currentContentObj);
                    }
                },
                appendContent: function(contentObject, hidden) {
                    if (contentObject) {
                        if (hidden === true) {
                            $ContentUtil.hideContent(contentObject);
                        }
                        var contentEle = contentObject.contentEle;
                        var container = this.getContentContainer();
                        if (contentEle.parentNode !== container) {
                            container.appendChild(contentEle);
                        }
                    }
                },
                _showContent: function(contentObj) {
                    if (!contentObj) {
                        return;
                    }
                    if (this.beforeShowContent(contentObj) === false) {
                        return;
                    }
                    $ContentUtil.showContent(contentObj);
                },
                beforeShowContent: function(contentObj) {},
                _hideContent: function(contentObj) {
                    if (!contentObj) {
                        return;
                    }
                    if (this.beforeHideContent(contentObj) === false) {
                        return;
                    }
                    $ContentUtil.hideContent(contentObj);
                },
                beforeHideContent: function(contentObj) {}
            };
        };
        var $DataContentInterface = function(clazz) {
            return $mergeObject({
                _getDataContentArrayMap: function() {
                    if (!this._dataContentArrayMap) {
                        this._dataContentArrayMap = new $ArrayMap();
                    }
                    return this._dataContentArrayMap;
                },
                isDataContentAdded: function(data) {
                    return this._getDataContentArrayMap().hasOwnProperty(data.id());
                },
                setCurrentDataContent: function(data) {
                    var did = data.id();
                    this._getDataContentArrayMap().eachObject(function(id, contentObj) {
                        if (id !== did) {
                            this._hideContent(contentObj);
                        }
                    }, this);
                    var contentObj;
                    if (!this._getDataContentArrayMap().has(did)) {
                        this.addDataContent(data);
                    }
                    contentObj = this._getDataContentArrayMap().get(did);
                    this.setCurrentContent(contentObj);
                },
                addDataContent: function(data) {
                    var contentObj = $ContentUtil.getContentObject(data.getProperty("content"));
                    var id = data.id();
                    if (contentObj) {
                        contentObj._id = id;
                    }
                    this._getDataContentArrayMap().add(id, contentObj);
                    this.appendContent(contentObj, true);
                    return contentObj;
                },
                removeDataContent: function(data) {
                    var did = data.id();
                    var content = this._getDataContentArrayMap().get(did);
                    this._getDataContentArrayMap().remove(did);
                    $ContentUtil.releaseContent(content);
                    if (content === this._currentContentObj) {
                        this._currentContentObj = null;
                    }
                },
                clearDataContent: function() {
                    this._currentContentObj = null;
                    this._getDataContentArrayMap().eachArray($ContentUtil.releaseContent);
                    this._getDataContentArrayMap().clear();
                },
                getDataContent: function(data) {
                    return this._getDataContentArrayMap()[data.id()];
                }
            }, $ContentInterface(clazz));
        };
        var $LevelCheckInterface = function(clazz) {
            return $mergeObject({
                _isTreeStatesCheck: function() {
                    return this.getProperty("three_states_check") !== false;
                },
                _isCheckedByDefault: function(data) {
                    return this._checkProvider.contains.apply(this._checkProvider, arguments);
                },
                _onCheckAddByDefault: function(data) {
                    this._addCheckNeedUpdateData(data);
                    this._callOn("onCheckAdd", "on.check.add", data, [ data ]);
                },
                _onCheckRemoveByDefault: function(data) {
                    this._addCheckNeedUpdateData(data);
                    this._callOn("onCheckRemove", "on.check.remove", data, [ data ]);
                },
                _onCheckSetByDefault: function(dataArray) {
                    dataArray.forEach(this._addCheckNeedUpdateData, this);
                    this._callOn("onCheckSet", "on.check.set", dataArray, [ dataArray ]);
                },
                _isAllChildrenOrDataChecked: function(data) {
                    var children = $DataLevelUtil.getAddedChildren(this.getProvider(), data);
                    if (children.length === 0) {
                        return this._isCheckedByDefault(data);
                    }
                    var allChecked = true;
                    $eachArray(children, function(child) {
                        if (!this._isAllChildrenOrDataChecked(child)) {
                            allChecked = false;
                            return false;
                        }
                    }, this);
                    return allChecked;
                },
                _hasChildrenChecked: function(data) {
                    var children = $DataLevelUtil.getAddedChildren(this.getProvider(), data);
                    var hasChecked = false;
                    $eachArray(children, function(child) {
                        if (this._hasChildrenCheckedImpl(child) === true) {
                            hasChecked = true;
                            return false;
                        }
                    }, this);
                    return hasChecked;
                },
                _hasChildrenCheckedImpl: function(data) {
                    var children = $DataLevelUtil.getAddedChildren(this.getProvider(), data);
                    if (children.length === 0) {
                        return this._isCheckedByDefault(data);
                    }
                    var hasChecked = false;
                    $eachArray(children, function(cChild) {
                        if (this._hasChildrenCheckedImpl(cChild) === true) {
                            hasChecked = true;
                            return false;
                        }
                    }, this);
                    return hasChecked;
                },
                _addDescendantCheck: function(data) {
                    var descendantArray = $DataLevelUtil.getAddedDescendantArray(this.getProvider(), data);
                    if (descendantArray.length === 0) {
                        return;
                    }
                    this._isUpdatingRelatedDataCheck = true;
                    descendantArray.forEach(function(descendant) {
                        if (!this._isCheckedByDefault(descendant)) {
                            this.addCheck(descendant);
                        }
                    }, this);
                    this._isUpdatingRelatedDataCheck = false;
                },
                _addAncestorCheck: function(data) {
                    this._isUpdatingRelatedDataCheck = true;
                    $eachArray($DataLevelUtil.getAncestorArray(data), function(ancestor) {
                        if (this._isCheckedByDefault(ancestor) || !this._isAllChildrenOrDataChecked(ancestor)) {
                            return false;
                        } else {
                            this.addCheck(ancestor);
                        }
                    }, this);
                    this._isUpdatingRelatedDataCheck = false;
                },
                _removeAncestorCheck: function(data) {
                    this._isUpdatingRelatedDataCheck = true;
                    $eachArray($DataLevelUtil.getAncestorArray(data), function(ancestor) {
                        if (!this._isCheckedByDefault(ancestor)) {
                            return false;
                        } else {
                            this.removeCheck(ancestor);
                        }
                    }, this);
                    this._isUpdatingRelatedDataCheck = false;
                },
                _removeDescendantCheck: function(data) {
                    var descendantArray = $DataLevelUtil.getAddedDescendantArray(this.getProvider(), data);
                    if (descendantArray.length === 0) {
                        return;
                    }
                    this._isUpdatingRelatedDataCheck = true;
                    descendantArray.forEach(function(descendant) {
                        if (this._isCheckedByDefault(descendant)) {
                            this.removeCheck(descendant);
                        }
                    }, this);
                    this._isUpdatingRelatedDataCheck = false;
                },
                _onDataAdd: function(data) {
                    clazz.superClass._onDataAdd.apply(this, arguments);
                    if (this._isTreeStatesCheck()) {
                        this._updateParentCheck(data.getProperty("parent"));
                    }
                },
                _onDataRemove: function(data) {
                    clazz.superClass._onDataRemove.apply(this, arguments);
                    if (this._isTreeStatesCheck()) {
                        this._updateParentCheck(data.getProperty("parent"));
                    }
                },
                _onDataChange: function(data, evt) {
                    clazz.superClass._onDataChange.apply(this, arguments);
                    if (this._isTreeStatesCheck() && evt.property === "parent") {
                        var oldParent = evt.old_value;
                        var newParent = evt.new_value;
                        this._updateParentCheck(oldParent);
                        this._updateParentCheck(newParent);
                    }
                },
                _updateParentCheck: function(parent) {
                    if (parent) {
                        if (this._isCheckedByDefault(parent)) {
                            if (!this._isAllChildrenOrDataChecked(parent)) {
                                this.removeCheck(parent);
                            }
                        } else {
                            if (this._isAllChildrenOrDataChecked(parent)) {
                                this.addCheck(parent);
                            }
                        }
                    }
                }
            }, $CheckInterface(clazz), {
                isChecked: function(data) {
                    if (this._isTreeStatesCheck()) {
                        return this._isAllChildrenOrDataChecked(data);
                    }
                    return this._isCheckedByDefault(data);
                },
                _onCheckAdd: function(data) {
                    if (this._isTreeStatesCheck()) {
                        if (this._isUpdatingRelatedDataCheck !== true) {
                            this._addAncestorCheck(data);
                            this._addDescendantCheck(data);
                        }
                    }
                    this._onCheckAddByDefault(data);
                },
                _onCheckRemove: function(data) {
                    if (this._isTreeStatesCheck()) {
                        if (this._isUpdatingRelatedDataCheck !== true) {
                            this._removeAncestorCheck(data);
                            this._removeDescendantCheck(data);
                        }
                    }
                    this._onCheckRemoveByDefault(data);
                },
                _onCheckSet: function(dataArray) {
                    if (this._isTreeStatesCheck()) {
                        if (this._isUpdatingRelatedDataCheck !== true) {
                            dataArray.forEach(this._addAncestorCheck, this);
                            dataArray.forEach(this._addDescendantCheck, this);
                        }
                    }
                    this._onCheckSetByDefault(dataArray);
                }
            });
        };
        var $ListViewInterface = function(clazz) {
            return {
                _initAllDataRenderer: function() {
                    return $ListViewRenderUtil.initAllDataRenderer(this);
                },
                _reorderAllDataRenderer: function() {
                    return $ListViewRenderUtil.reorderAllDataRenderer(this);
                },
                _addDataRendererImpl: function(data, renderer) {
                    return $ListViewRenderUtil.insertElementRenderer(this, data, renderer);
                },
                _updateDataRendererImpl: function(data, renderer, reorder) {
                    if (this.getProperty("sort_compare")) {
                        return $ListViewRenderUtil.insertElementRenderer(this, data, renderer);
                    }
                }
            };
        };
        var $LevelViewInterface = function(clazz) {
            return {
                getRendererContainer: function(data) {
                    var parent = data.getProperty("parent");
                    if (parent) {
                        var parentRenderer = this.getDataRenderer(parent);
                        return parentRenderer.getChildrenRendererContainer(data);
                    } else {
                        return clazz.superClass.getRendererContainer.apply(this, arguments);
                    }
                },
                _initAllDataRenderer: function() {
                    return $LevelViewRenderUtil.initAllDataRenderer(this);
                },
                _reorderAllDataRenderer: function() {
                    return $LevelViewRenderUtil.reorderAllDataRenderer(this);
                },
                _addDataRenderer: function(data) {
                    if ($DataLevelUtil.isAncestorAdded(this.getProvider(), data)) {
                        return clazz.superClass._addDataRenderer.apply(this, arguments);
                    }
                },
                _addDataRendererImpl: function(data, renderer) {
                    return $LevelViewRenderUtil.insertElementRenderer(this, data, renderer, true);
                },
                _updateDataRenderer: function(data) {
                    if ($DataLevelUtil.isAncestorAdded(this.getProvider(), data)) {
                        if (!this.getDataRenderer(data)) {
                            var renderer = this.createDataRenderer(data);
                            if (renderer) {
                                this._rendererArrayMap.add(data.id(), renderer);
                                $LevelViewRenderUtil.insertElementRenderer(this, data, renderer, true);
                            }
                        } else {
                            return clazz.superClass._updateDataRenderer.apply(this, arguments);
                        }
                    } else {
                        $LevelViewRenderUtil.removeDataRenderer(data);
                    }
                },
                _updateDataRendererImpl: function(data, renderer, reorder) {
                    if (reorder === true || this.getProperty("sort_compare")) {
                        return $LevelViewRenderUtil.insertElementRenderer(this, data, renderer);
                    }
                },
                expandAll: function(onlyVisible) {
                    var expandArray = this.getDataArray(false);
                    if (onlyVisible !== false) {
                        expandArray = $filterArray(expandArray, this._isLevelVisible, this);
                    }
                    return this._expandProvider.set(this._filterExpandableData(expandArray));
                },
                _getDataLevel: function(data) {
                    var rootData = this.getProperty("root_data");
                    var level = 0;
                    var p = data.getProperty("parent");
                    if (rootData) {
                        level++;
                        while (p && p !== rootData) {
                            level++;
                            p = p.getProperty("parent");
                        }
                        if (p !== rootData) {
                            return -1;
                        }
                    } else {
                        while (p) {
                            level++;
                            p = p.getProperty("parent");
                        }
                    }
                    return level;
                },
                hasChildrenVisible: function(data) {
                    return $LevelViewVisibleUtil.hasChildrenVisible(this, data);
                },
                _isLevelVisible: function(data) {
                    if (this.isVisible(data) === false) {
                        return false;
                    }
                    if (this._isFilterVisible(data) === false) {
                        return this._hasDescendantVisible(data);
                    }
                    return true;
                },
                _hasDescendantVisible: function(data) {
                    var addedDescendantArray = $DataLevelUtil.getAddedDescendantArray(this.getProvider(), data);
                    var has = false;
                    $eachArray(addedDescendantArray, function(child) {
                        if (this._isLevelVisible(child)) {
                            has = true;
                            return false;
                        }
                    }, this);
                    return has;
                },
                _isVisible: function(data) {
                    if (this._isLevelVisible(data) === false) {
                        return false;
                    }
                    if (this._isExpand_ === true) {
                        if (!this._isDataAncestorExpanded(data)) {
                            return false;
                        }
                    }
                    return true;
                },
                _getDataRelatedDataArray: function(data, ancestorRelated, descendantRelated) {
                    var ancestorArr;
                    if (ancestorRelated) {
                        ancestorArr = $DataLevelUtil.getAncestorArray(data);
                    } else {
                        ancestorArr = [];
                    }
                    var descendantArr;
                    if (descendantRelated) {
                        descendantArr = $DataLevelUtil.getAddedDescendantArray(this.getProvider(), data);
                    } else {
                        descendantArr = [];
                    }
                    return $mergeArray(descendantArr, ancestorArr);
                },
                _isVisibleByRootData: function(data) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        if (rootData === data) {
                            return true;
                        }
                        if ($DataLevelUtil.getAncestorArray(rootData).indexOf(data) >= 0) {
                            return true;
                        }
                        if ($DataLevelUtil.getAddedDescendantArray(this.getProvider(), rootData).indexOf(data) >= 0) {
                            return true;
                        }
                        return false;
                    }
                    return true;
                },
                _isBodyVisibleByRootData: function(data) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        if ($DataLevelUtil.getAncestorArray(rootData).indexOf(data) >= 0) {
                            return false;
                        }
                    }
                    return true;
                },
                _isRootData: function(data) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        return rootData === data;
                    }
                    return false;
                }
            };
        };
        var $LevelListViewInterface = function(clazz) {
            var lvi = $LevelViewInterface(clazz);
            delete lvi.getRendererContainer;
            return $mergeObject(lvi, {
                _addDataRendererImpl: function(data, renderer) {
                    return $LevelListViewRenderUtil.insertElementRenderer(this, data, renderer, true);
                },
                _updateDataRenderer: function(data) {
                    if ($DataLevelUtil.isAncestorAdded(this.getProvider(), data)) {
                        if (!this.getDataRenderer(data)) {
                            var renderer = this.createDataRenderer(data);
                            if (renderer) {
                                this._rendererArrayMap.add(data.id(), renderer);
                                $LevelListViewRenderUtil.insertElementRenderer(this, data, renderer, true);
                            }
                        } else {
                            return clazz.superClass._updateDataRenderer.apply(this, arguments);
                        }
                    } else {
                        $LevelViewRenderUtil.removeDataRenderer(data);
                    }
                },
                _updateDataRendererImpl: function(data, renderer, reorder) {
                    if (reorder === true || this.getProperty("sort_compare")) {
                        $LevelListViewRenderUtil.updateDataRenderer(this, data, renderer);
                    }
                },
                _isVisibleByRootData: function(data) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        if (rootData === data) {
                            return true;
                        }
                        if ($DataLevelUtil.getAddedDescendantArray(this.getProvider(), rootData).indexOf(data) >= 0) {
                            return true;
                        }
                        return false;
                    }
                    return true;
                }
            });
        };
        var $IDataWidgetView = function() {
            $IDataWidgetView.superClass.constructor.apply(this, arguments);
            $WViewUtil.addWidgetClass(this.getRoot());
            this.addController(new $DefaultController());
            this.addController(new $HoverController());
        };
        $extendClass($IDataWidgetView, $IDataElementRendererView, $mergeObject({
            ___zdefaults_: {
                template: null,
                remove_icon_visible: false,
                remove_icon_template: $IconTemplate.remove,
                auto_select: false,
                select_on_hover: false,
                hoverable: false
            },
            _onViewChange: function(key, value, old) {
                $IDataWidgetView.superClass._onViewChange.apply(this, arguments);
                if (key === "auto_select" && this._selectProvider) {
                    this._doViewAutoSelectUpdate();
                }
            },
            _doViewAutoSelectUpdate: function() {
                if (this._needAutoSelect()) {
                    var selectData = $WViewUtil.findNextUsableDataByDom(this);
                    if (selectData) {
                        this.setSelect(selectData);
                    }
                }
            },
            beforeRemove: function(data) {},
            _onDataAdd: function(data) {
                $IDataWidgetView.superClass._onDataAdd.apply(this, arguments);
                if (this._needAutoSelect() && this._isDataAutoSelectable(data)) {
                    this.setSelect(data);
                }
            },
            _needAutoSelect: function(currentSelect) {
                var auto_select = this.getProperty("auto_select");
                if (auto_select !== true) {
                    return false;
                }
                if (arguments.length > 0) {
                    return this.getLastSelected() === currentSelect;
                }
                return !this.getLastSelected();
            },
            _isDataAutoSelectable: function(data) {
                return data != null && this.isVisible(data) && !this._isDisabled(data) && this.isSelectable(data);
            }
        }, $HoverInterface($IDataWidgetView), {
            _onDataRemove: function(data) {
                var selectData;
                if (this._needAutoSelect(data)) {
                    var renderer = this.getDataRenderer(data);
                    var renderEle;
                    if (renderer) {
                        renderEle = renderer.getRenderer();
                    }
                    selectData = $WViewUtil.findNextUsableDataByDom(this, renderEle);
                }
                $IDataWidgetView.superClass._onDataRemove.apply(this, arguments);
                if (selectData) {
                    this.setSelect(selectData);
                }
                this._removeHover(data, false);
            },
            _onModelChange: function(type) {
                $IDataWidgetView.superClass._onModelChange.apply(this, arguments);
                if (type === "set_provider") {
                    if (this._needAutoSelect()) {
                        var selectData = $WViewUtil.findNextUsableDataByDom(this);
                        if (selectData) {
                            this.setSelect(selectData);
                        }
                    }
                    this._clearHover(false);
                }
            }
        }));
        var $IDataWidgetRenderer = function() {
            $IDataWidgetRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($IDataWidgetRenderer, $IDataElementRenderer, {
            getChildrenRendererContainer: function(child) {
                return this._childrenRendererContainer;
            },
            updateRenderConfig: function(view, data, renderConfig) {
                $IDataWidgetRenderer.superClass.updateRenderConfig.apply(this, arguments);
                renderConfig["template"] = view.getDataViewProperty(data, "template");
                renderConfig["selectable"] = view.isSelectable(data);
                renderConfig["hover"] = view.isHover(data);
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $IDataWidgetRenderer.superClass.updateRendererStatus.apply(this, arguments);
                $domToggleClass(this._renderer, "unselectable", this.getRenderConfig("selectable") !== true);
                $domToggleClass(this._renderer, "hover", this.getRenderConfig("hover") === true);
            }
        });
        var $DefaultController = function() {
            $DefaultController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($DefaultController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "click", "dblclick" ];
            },
            handle_click: function(evt, view) {
                var data = view.getDataAt(evt);
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    if (this.isHitRemove(evt)) {
                        this.handleRemove(data, evt);
                        return;
                    }
                    if (this.isHitCheckBox(evt)) {
                        this.handleCheck(data, evt);
                        return;
                    }
                    if (this.isHitExpand(evt)) {
                        this.handleExpand(data, evt);
                        return;
                    }
                    this._handleClickAction(data, evt);
                    view._onDataClick(data, evt);
                }
            },
            _handleClickAction: function(data, evt) {
                var view = this.getView();
                if (view._isExpandable && view._isExpandable(data) && view.getProperty("expand_on_click") === true) {
                    if (this.handleExpand(data, evt) === true) {
                        return true;
                    }
                }
                if (view.isCheckable && (view.getDataViewProperty(data, "checkbox_visible") === true || view.hasCheckColumn && view.hasCheckColumn() === true)) {
                    if (view.isCheckable(data) && view.getProperty("check_on_click") === true) {
                        if (this.handleCheck(data, evt) === true) {
                            return true;
                        }
                    }
                }
                this.handleSelect(data, evt);
            },
            handleRemove: function(data, evt) {
                var view = this.getView();
                var beforeRemove = view.beforeRemove(data);
                if ($isFunction(beforeRemove)) {
                    beforeRemove(function() {
                        view.removeData(data);
                    });
                    return;
                }
                if (beforeRemove !== false) {
                    view.removeData(data);
                }
            },
            handleSelect: function(data, evt) {
                var view = this.getView();
                if (view.isSelectable(data)) {
                    if (!view.isSelected(data)) {
                        view.setSelect(data);
                    }
                    return true;
                }
                return false;
            },
            handleCheck: function(data, evt) {
                var view = this.getView();
                if (view.toggleCheck && view.isCheckable(data)) {
                    view.toggleCheck(data);
                    return true;
                }
                return false;
            },
            handleExpand: function(data, evt) {
                var view = this.getView();
                if (view.toggleExpand && view.isExpandable(data)) {
                    view.toggleExpand(data);
                    return true;
                }
                return false;
            },
            handle_dblclick: function(evt, view) {
                evt.stopPropagation();
                var data = view.getDataAt(evt);
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    if (!this._isHitOPTarget(evt)) {
                        if (view.getProperty("expand_on_click") !== true && view.getProperty("expand_on_dbl_click") === true) {
                            this.handleExpand(data, evt);
                        }
                    }
                    view._onDataDblClick(data, evt);
                }
            },
            isHitCheckBox: function(evt) {
                return this._isHitOPTypeTarget(evt, "check");
            },
            isHitRemove: function(evt) {
                return this._isHitOPTypeTarget(evt, "remove");
            },
            isHitExpand: function(evt) {
                return this._isHitOPTypeTarget(evt, "expand");
            },
            _isHitOPTarget: function(evt) {
                var opTarget = $DomEventUtil.getEventTarget(evt, "[__z_dop_]");
                return opTarget != null;
            },
            _isHitOPTypeTarget: function(evt, op) {
                var opTarget = $DomEventUtil.getEventTarget(evt, "[__z_dop_]");
                if (opTarget) {
                    return opTarget.getAttribute("__z_dop_") === op;
                }
                return false;
            }
        });
        var $HoverController = function() {
            $HoverController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($HoverController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "mouseover", "mouseleave" ];
            },
            handle_mouseover: function(evt, view) {
                if (view.getProperty("hoverable") !== true) {
                    return;
                }
                var data = view.getDataAt(evt);
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    if (view._isHoverable(data)) {
                        view._setHoverData(data, true, evt);
                        if (view.getProperty("select_on_hover") === true) {
                            if (view.isSelectable(data)) {
                                if (!view.isSelected(data)) {
                                    view.setSelect(data);
                                }
                            }
                        }
                    }
                } else {
                    var dataTarget = $DomEventUtil.getEventTarget(evt, "[__z_did_]");
                    if (dataTarget && view.getRoot().contains(dataTarget)) {
                        return;
                    }
                    view._setHoverData(null, true, evt);
                }
            },
            handle_mouseleave: function(evt, view) {
                if (view.getProperty("hoverable") !== true) {
                    return;
                }
                view._setHoverData(null, true, evt);
            }
        });
        var $IDataULView = function() {
            this._rootUL = $domCreate("ul", "items");
            $IDataULView.superClass.constructor.apply(this, arguments);
            this.getRoot().appendChild(this._rootUL);
        };
        $extendClass($IDataULView, $IDataWidgetView, {
            getRendererRootContainer: function() {
                return this._rootUL;
            },
            getRendererContainer: function(data) {
                return this._rootUL;
            },
            getDataRendererClass: function(data) {
                return $IDataULRenderer;
            }
        });
        var $IDataULListView = function() {
            $IDataULListView.superClass.constructor.apply(this, arguments);
        };
        $extendClass($IDataULListView, $IDataULView, $mergeObject({
            ___zdefaults_: $CheckInterfaceDefault()
        }, $ListViewInterface($IDataULListView), $CheckInterface($IDataULListView)));
        var $IDataULLevelView = function() {
            $IDataULLevelView.superClass.constructor.apply(this, arguments);
        };
        $extendClass($IDataULLevelView, $IDataULView, $mergeObject({
            ___zdefaults_: $mergeObject($CheckInterfaceDefault(), $ExpandInterfaceDefault()),
            _onViewChange: function(key, value, old) {
                $IDataULLevelView.superClass._onViewChange.apply(this, arguments);
                this._doViewThreeStatesCheckUpdate(key);
            },
            _doViewThreeStatesCheckUpdate: function(key) {
                if (key === "three_states_check") {
                    if (this._checkProvider) this.clearCheck();
                }
            },
            getDataRendererClass: function(data) {
                return $IDataULLevelRenderer;
            },
            getDataAt: function(evt) {
                if (!$WViewUtil.isEvtInRendererNode(evt)) {
                    return null;
                }
                return $IDataULLevelView.superClass.getDataAt.apply(this, arguments);
            },
            makeVisible: function(data) {
                if (data) {
                    var ancestorArray = $DataLevelUtil.getAncestorArray(data);
                    ancestorArray.forEach(function(ancestor) {
                        this.expand(ancestor);
                    }, this);
                    $IDataULLevelView.superClass.makeVisible.apply(this, arguments);
                }
            }
        }, $LevelViewInterface($IDataULLevelView), $LevelCheckInterface($IDataULLevelView), $ExpandInterface($IDataULLevelView), {
            _isExpandable: function(data) {
                var isLeaf = false;
                if (!this.hasChildrenVisible(data)) {
                    isLeaf = true;
                }
                if (isLeaf === true) {
                    return false;
                }
                if (this.isExpandable(data) === false) {
                    return false;
                }
                return true;
            }
        }));
        var $IDataULRenderer = function() {
            this._renderer = $domCreate("li", "item");
            $RenderNodeUtil.initRenderNode(this);
            $IDataULRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($IDataULRenderer, $IDataWidgetRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $IDataULRenderer.superClass.updateRenderConfig.apply(this, arguments);
                renderConfig["attributes"] = view.getDataRenderProperty(data, "attributes");
                $RenderNodeUtil.updateRenderCheckConfig(this, view, data, renderConfig);
                $RenderNodeUtil.updateRenderRemoveConfig(this, view, data, renderConfig);
            },
            updateRenderer: function(view, data, renderConfig) {
                $IDataULRenderer.superClass.updateRenderer.apply(this, arguments);
                $RenderNodeUtil.updateRendererCheck(this, view, data, renderConfig);
                $RenderNodeUtil.updateRendererRemove(this, view, data, renderConfig);
                $RenderNodeUtil.updateRenderIn(this, view, data, renderConfig);
                $RenderNodeUtil.updateRenderAttributes(this, view, data, renderConfig);
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $IDataULRenderer.superClass.updateRendererStatus.apply(this, arguments);
                $domToggleClass(this._renderer, "checked", this.getRenderConfig("checked") === true);
                $domToggleClass(this._renderer, "uncheckable", this.getRenderConfig("checkable") === false);
            },
            insertToNodeWrapperFirst: function(ele) {
                var firstChild = this._nodeWrapper.firstElementChild;
                if (firstChild !== ele) {
                    this._nodeWrapper.insertBefore(ele, firstChild);
                }
            },
            appendToNodeWrapper: function(ele) {
                this._nodeWrapper.appendChild(ele);
            },
            getNodeWrapper: function() {
                return this._nodeWrapper;
            },
            reBuildRenderer: function() {
                this._renderer.appendChild(this._nodeWrapper);
            }
        });
        var $IDataULLevelRenderer = function() {
            this._childrenRendererContainer = $domCreate("ul", "children");
            $IDataULLevelRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($IDataULLevelRenderer, $IDataULRenderer, {
            _isRendererVisible: function(view, data) {
                var visible = $IDataULLevelRenderer.superClass._isRendererVisible.apply(this, arguments);
                if (visible === true) {
                    visible = view._isVisibleByRootData(data);
                }
                return visible;
            },
            _isRendererBodyVisible: function(view, data) {
                return view._isBodyVisibleByRootData(data);
            },
            updateRenderConfig: function(view, data, renderConfig) {
                $IDataULLevelRenderer.superClass.updateRenderConfig.apply(this, arguments);
                renderConfig["body_visible"] = this._isRendererBodyVisible(view, data);
                renderConfig["is_root_data"] = view._isRootData(data);
                $RenderNodeUtil.updateRenderLevelCheckConfig(this, view, data, renderConfig);
                $RenderNodeUtil.updateRenderExpandConfig(this, view, data, renderConfig);
            },
            updateRenderer: function(view, data, renderConfig) {
                var renderer = this._renderer;
                $domToggleClass(renderer, "body_hidden", this.getRenderConfig("body_visible") === false);
                if (this.getRenderConfig("body_visible") === false) {
                    $domSetStyle(this.getNodeWrapper(), "display", "none");
                } else {
                    $domRemoveStyle(this.getNodeWrapper(), "display");
                }
                $domToggleClass(renderer, "root_data", this.getRenderConfig("is_root_data") === true);
                $IDataULLevelRenderer.superClass.updateRenderer.apply(this, arguments);
                $domToggleClass(renderer, "leaf", this.getRenderConfig("has_children") !== true);
                $RenderNodeUtil.updateRendererExpand(this, view, data, renderConfig);
                this._updateChildrenRendererContainer();
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $IDataULLevelRenderer.superClass.updateRendererStatus.apply(this, arguments);
                var renderer = this._renderer;
                $domToggleClass(renderer, "indeterminate-checked", this.getRenderConfig("indeterminate_checked") === true);
                $domToggleClass(renderer, "expanded", this.getRenderConfig("expanded") === true);
                $domToggleClass(renderer, "unexpandable", this.getRenderConfig("expandable") === false);
            },
            _getExpandTemplate: function() {
                return $RenderNodeUtil._getExpandTemplate(this);
            },
            _updateChildrenRendererContainer: function() {
                var childrenRendererContainer = this._childrenRendererContainer;
                if (this.getRenderConfig("has_children") === true) {
                    if (!childrenRendererContainer.parentNode) {
                        this._renderer.appendChild(childrenRendererContainer);
                    }
                    if (this.getRenderConfig("expanded") === true) {
                        $domRemoveStyle(childrenRendererContainer, "display");
                    } else {
                        $domSetStyle(childrenRendererContainer, "display", "none");
                    }
                } else {
                    $domRemove(childrenRendererContainer);
                }
            }
        });
        var $IDataTableView = function() {
            this._table = $domCreate("table", "table");
            this._table.setAttribute("cellspacing", "0");
            this._tableColGroup = $domCreate("colgroup");
            this._table.appendChild(this._tableColGroup);
            $IDataTableView.superClass.constructor.apply(this, arguments);
            this.getRoot().appendChild(this._table);
        };
        $extendClass($IDataTableView, $IDataWidgetView, {
            getRendererContainer: function(data) {
                return this._table;
            },
            getColGroup: function() {
                return this._tableColGroup;
            }
        });
        var $ColumnSortUtil = {
            isAscSort: function(order) {
                return order === "asc";
            },
            getColumnNextOrder: function(view, column) {
                var orderArray = view.getDataViewProperty(column, "sort_orders");
                var sort = column.getProperty("sort");
                var order = $ColumnSortUtil.getSortOrder(sort);
                var index = orderArray.indexOf(order);
                if (index === orderArray.length - 1) {
                    return orderArray[0];
                }
                return orderArray[index + 1];
            },
            getSortOrder: function(sort) {
                if (sort) {
                    if ($isObject(sort)) {
                        return sort.order;
                    }
                    return sort;
                }
                return null;
            },
            getSortIndex: function(sort) {
                if ($isObject(sort)) {
                    return sort.index + 1;
                }
                return null;
            },
            getSortedColumnArray: function(columnProvider) {
                var array = columnProvider.filter(function(data) {
                    return data.hasProperty("sort");
                });
                array.sort($ColumnSortUtil._sortMultipleColumnArray);
                return array;
            },
            getSortCompare: function(view, columnProvider) {
                var compareArray = $ColumnSortUtil._getSortedColumnCompareArray(view, columnProvider);
                var compare;
                if (compareArray) {
                    var count = compareArray.length;
                    if (count > 0) {
                        compare = function(data1, data2) {
                            var result;
                            for (var i = 0; i < count; i++) {
                                var sortObj = compareArray[i];
                                var compareFun = sortObj.compare;
                                if ($ColumnSortUtil.isAscSort(sortObj.order)) {
                                    result = compareFun(data1, data2);
                                } else {
                                    result = -compareFun(data1, data2);
                                }
                                if (result !== 0) {
                                    return result;
                                }
                            }
                            return result;
                        };
                    }
                }
                return compare;
            },
            _getSortedColumnCompareArray: function(view, columnProvider) {
                var columnArr = $ColumnSortUtil.getSortedColumnArray(columnProvider);
                var arr = [];
                columnArr.forEach(function(columnData) {
                    var compare = columnData.compare;
                    if (!$isFunction(compare)) {
                        compare = function(data1, data2) {
                            var v1 = view._getCellValue(data1, columnData);
                            var v2 = view._getCellValue(data2, columnData);
                            if (v1 > v2) {
                                return 1;
                            }
                            if (v1 < v2) {
                                return -1;
                            }
                            return 0;
                        };
                    }
                    arr.push({
                        order: $ColumnSortUtil.getSortOrder(columnData.getProperty("sort")),
                        compare: compare
                    });
                });
                return arr;
            },
            setColumnSort: function(columnProvider, column, order, multiple) {
                if (order) {
                    if (multiple) {
                        var sortedColumns = $ColumnSortUtil.getSortedColumnArray(columnProvider);
                        var count = sortedColumns.length;
                        if (count === 0) {
                            column.set("sort", order);
                        } else if (count === 1) {
                            if (sortedColumns[0] === column) {
                                column.set("sort", order);
                            } else {
                                column.set("sort", {
                                    order: order,
                                    index: 1
                                });
                                $ColumnSortUtil.updateColumnSortIndex(columnProvider);
                            }
                        } else {
                            var index;
                            if (sortedColumns.indexOf(column) >= 0) {
                                index = column.getProperty("sort").index;
                            } else {
                                index = count;
                            }
                            column.set("sort", {
                                order: order,
                                index: index
                            });
                        }
                    } else {
                        $ColumnSortUtil._clearOtherColumnSort(columnProvider, column);
                        column.set("sort", order);
                    }
                } else {
                    if (multiple) {
                        column.removeProperty("sort");
                        $ColumnSortUtil.updateColumnSortIndex(columnProvider);
                    } else {
                        $ColumnSortUtil.clearColumnSort(columnProvider);
                    }
                }
            },
            clearColumnSort: function(columnProvider) {
                columnProvider.each(function(data) {
                    data.removeProperty("sort");
                });
            },
            _clearOtherColumnSort: function(columnProvider, column) {
                columnProvider.each(function(data) {
                    if (column !== data) {
                        data.removeProperty("sort");
                    }
                });
            },
            updateColumnSortIndex: function(columnProvider) {
                var sortedColumnArray = $ColumnSortUtil.getSortedColumnArray(columnProvider);
                var count = sortedColumnArray.length;
                if (count === 1) {
                    var column = sortedColumnArray[0];
                    var sort = column.getProperty("sort");
                    if ($isObject(sort)) {
                        column.set("sort", sort.order);
                    }
                } else if (count > 1) {
                    sortedColumnArray.forEach(function(column, index) {
                        var sort = column.getProperty("sort");
                        var sortIsObject = $isObject(sort);
                        if (sortIsObject && sort.index === index) {
                            return;
                        }
                        column.set("sort", {
                            order: sortIsObject ? sort.order : sort,
                            index: index
                        });
                    });
                }
            },
            _sortMultipleColumnArray: function(column1, column2) {
                var column1Sort = column1.getProperty("sort");
                var column2Sort = column2.getProperty("sort");
                var column1SortIsObject = $isObject(column1Sort);
                var column2SortIsObject = $isObject(column2Sort);
                if (column1SortIsObject && !column2SortIsObject) {
                    return 1;
                }
                if (!column1SortIsObject && column2SortIsObject) {
                    return -1;
                }
                if (column1SortIsObject && column2SortIsObject) {
                    var column1SortIndex = column1Sort.index;
                    var column2SortIndex = column2Sort.index;
                    if (column1SortIndex < column2SortIndex) {
                        return -1;
                    }
                    if (column1SortIndex > column2SortIndex) {
                        return 1;
                    }
                }
                return 0;
            }
        };
        var $TableHeadRenderUtil = {
            calcMaxLevel: function(provider) {
                var maxNumber = 0;
                provider.toRootArray(false).forEach(function(root) {
                    var descendantArray = $DataLevelUtil.getAddedDescendantArray(provider, root);
                    var rootLevelNumber = 1;
                    descendantArray.forEach(function(data) {
                        data = data.getProperty("parent");
                        var dataNumber = 1;
                        while (data) {
                            dataNumber++;
                            if (data === root) {
                                break;
                            }
                            data = data.getProperty("parent");
                        }
                        rootLevelNumber = $MathMax(rootLevelNumber, dataNumber);
                    });
                    maxNumber = $MathMax(maxNumber, rootLevelNumber);
                });
                return maxNumber;
            },
            calcDataRowIndex: function(data) {
                var index = 0;
                data = data.getProperty("parent");
                while (data) {
                    index++;
                    data = data.getProperty("parent");
                }
                return index;
            },
            calcColSpan: function(view, data) {
                var span = 0;
                $DataLevelUtil.getAddedDescendantArray(view.getProvider(), data).forEach(function(descData) {
                    if (view._isVisible(descData) && !view.hasChildrenVisible(descData)) {
                        span++;
                    }
                });
                return $MathMax(1, span);
            },
            calcRowSpan: function(view, data) {
                if (view.hasChildrenVisible(data)) {
                    return 1;
                }
                var rowNumber = $TableHeadRenderUtil.calcMaxLevel(view.getProvider());
                var index = $TableHeadRenderUtil.calcDataRowIndex(data);
                return rowNumber - index;
            },
            appendAllDataRenderer: function(view) {
                view._getSortDataArray(view.getProvider().toRootArray(false)).forEach(function(data) {
                    $TableHeadRenderUtil._appendDataRenderer(view, data);
                });
            },
            _appendDataRenderer: function(view, data) {
                var renderer = view.getDataRenderer(data);
                if (renderer) {
                    view.getRendererContainer(data).appendChild(renderer.getRenderer());
                    $TableHeadRenderUtil.appendDataChildrenRenderer(view, data);
                }
            },
            appendDataChildrenRenderer: function(view, data) {
                var children = $filterArray(data.getChildren(false), view.containsData, view);
                if (children.length > 0) {
                    children = view._getSortDataArray(children);
                    children.forEach(function(child) {
                        $TableHeadRenderUtil._appendDataRenderer(view, child);
                    });
                }
            }
        };
        var $TableHeadView = function() {
            this._tableHead = $domCreate("thead");
            this._rowTRArray = [];
            $TableHeadView.superClass.constructor.apply(this, arguments);
            this._table.appendChild(this._tableHead);
            this.setControllers([ new $HeadController() ]);
            $domAddClass(this.getRoot(), "z-thead");
        };
        $extendClass($TableHeadView, $IDataTableView, $mergeObject({
            ___zdefaults_: $mergeObject({
                model_select: true,
                model_check: true,
                template: null
            }, $CheckInterfaceDefault({
                checkbox_visible: false
            }), $SortDefault(), $ColumnMinimizeDefault()),
            getRendererRootContainer: function() {
                return this._tableHead;
            },
            getDataRendererClass: function(data) {
                return $TableHeadRenderer;
            },
            isCheckColumn: function(data) {
                return this.getProvider()._checkColumn === data;
            },
            hasCheckColumn: function(data) {
                return this.getProvider()._checkColumn != null;
            },
            isTreeColumn: function(data) {
                return this.getProvider()._treeColumn === data;
            },
            _onModelChange: function(type, evt) {
                $TableHeadRenderUtil.appendAllDataRenderer(this);
                $TableHeadView.superClass._onModelChange.apply(this, arguments);
            },
            _clearDataRendererImpl: function() {
                $TableHeadView.superClass._clearDataRendererImpl.apply(this, arguments);
                this._updateHeadTR();
            },
            _beforeModelChange: function(type, evt) {
                if (type !== "data" || evt.property === "parent") {
                    this._updateHeadTR();
                }
                $TableHeadView.superClass._beforeModelChange.apply(this, arguments);
            },
            _updateHeadTR: function() {
                var rowNumber = $TableHeadRenderUtil.calcMaxLevel(this.getProvider());
                this._rowTRArray = [];
                $domEmpty(this._tableHead);
                for (var i = 0; i < rowNumber; i++) {
                    var tr = $domCreate("tr");
                    this._rowTRArray[i] = tr;
                    this._tableHead.appendChild(tr);
                }
            },
            getRowTRArray: function() {
                return this._rowTRArray;
            },
            _onViewUpdate: function() {
                this._updateColGroup();
                $TableHeadView.superClass._onViewUpdate.apply(this, arguments);
            },
            _updateColGroup: function() {
                $domEmpty(this._tableColGroup);
                var provider = this.getProvider();
                this._colGroupWidth = 0;
                if (provider) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        if (!this.hasChildrenVisible(rootData)) {
                            this._appendColGroupItem(rootData);
                        } else {
                            provider.hEachByData(rootData, this._appendColGroupItem, this);
                        }
                    } else {
                        provider.hEach(this._appendColGroupItem, this);
                    }
                }
                this.onColGroupChange(this._tableColGroup);
            },
            onColGroupChange: function() {},
            _getColGroupWidth: function() {
                return this._colGroupWidth;
            },
            _isColNeedAdded: function(data) {
                if (this.isVisible(data) === false) {
                    return false;
                }
                if (this._isAllChildrenHidden(data)) {
                    return false;
                }
                if (!this.hasChildrenVisible(data)) {
                    var visible = this._isVisible(data);
                    if (!visible && !data.getProperty("parent")) {
                        return false;
                    }
                    return {
                        visible: visible
                    };
                }
                return false;
            },
            _isAllChildrenHidden: function(data) {
                if (data.hasChildren()) {
                    return !this.hasChildrenVisible(data);
                }
                return false;
            },
            _appendColGroupItem: function(data) {
                var needAdd = this._isColNeedAdded(data);
                if (needAdd === false) {
                    return;
                }
                var width = 0;
                var col = $domCreate("col");
                if (needAdd.visible === true) {
                    if (this.isColumnMinimized(data)) {
                        width = this.getProperty("minimize_width") | 0;
                    } else {
                        width = parseFloat(data.getProperty("width"));
                    }
                }
                width = $MathMax(0, width);
                this._colGroupWidth += width;
                col._width = width;
                $domSetStyle(col, "width", width + "px");
                this._tableColGroup.appendChild(col);
            },
            hEachColumn: function(callBack, context) {
                var provider = this.getProvider();
                if (provider) {
                    var rootData = this.getProperty("root_data");
                    if (rootData) {
                        provider.hEachByData(rootData, function(columnData) {
                            var needAdd = this._isColNeedAdded(columnData);
                            if (needAdd === false) {
                                return;
                            }
                            callBack.apply(context, [ columnData, needAdd.visible ]);
                        }, this);
                    } else {
                        provider.hEach(function(columnData) {
                            if (!this.hasChildrenVisible(columnData)) {
                                var needAdd = this._isColNeedAdded(columnData);
                                if (needAdd === false) {
                                    return;
                                }
                                callBack.apply(context, [ columnData, needAdd.visible ]);
                            }
                        }, this);
                    }
                }
            },
            setColumnMinimize: function(col, minimize) {
                if (minimize === true) {
                    col.set("minimized", true);
                } else {
                    col.remove("minimized");
                }
            },
            isColumnMinimized: function(col) {
                return col.get("minimized") === true;
            }
        }, $LevelViewInterface($TableHeadView), $LevelCheckInterface($TableHeadView), {
            getRendererContainer: function(data) {
                var index = $TableHeadRenderUtil.calcDataRowIndex(data);
                return this._rowTRArray[index];
            }
        }));
        var $HeadController = function() {
            $HeadController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($HeadController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "click" ];
            },
            handle_click: function(evt, view) {
                var data = view.getDataAt(evt);
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    if (view.isColumnMinimized(data)) {
                        view.setColumnMinimize(data, false);
                        return;
                    }
                    if (this.isCheckBox(evt)) {
                        this.handleCheck(data, evt);
                        return;
                    }
                    if (this.isMinimize(evt)) {
                        view.setColumnMinimize(data, true);
                        return;
                    }
                    if (this._isSortable(data)) {
                        var nextOrder = $ColumnSortUtil.getColumnNextOrder(view, data);
                        var multipleSort = view.getDataViewProperty(data, "sort_mode") === "multiple";
                        if (multipleSort) {
                            var key = view.getProperty("multiple_sort_modifier_key");
                            if (key == null) {
                                if (!evt.ctrlKey && !evt.metaKey) {
                                    multipleSort = false;
                                }
                            } else {
                                if (!evt[key.toLowerCase() + "Key"]) {
                                    multipleSort = false;
                                }
                            }
                        }
                        $ColumnSortUtil.setColumnSort(view.getProvider(), data, nextOrder, multipleSort);
                    }
                    view._onDataClick(data, evt);
                }
            },
            isCheckBox: function(evt) {
                return this._isOPTypeTarget(evt, "check");
            },
            isRemove: function(evt) {
                return this._isOPTypeTarget(evt, "remove");
            },
            isExpand: function(evt) {
                return this._isOPTypeTarget(evt, "expand");
            },
            isMinimize: function(evt) {
                return this._isOPTypeTarget(evt, "minimize");
            },
            _isOPTarget: function(evt) {
                var opTarget = $DomEventUtil.getEventTarget(evt, "[__z_dop_]");
                return opTarget != null;
            },
            _isOPTypeTarget: function(evt, op) {
                var opTarget = $DomEventUtil.getEventTarget(evt, "[__z_dop_]");
                if (opTarget) {
                    return opTarget.getAttribute("__z_dop_") === op;
                }
                return false;
            },
            handleCheck: function(data, evt) {
                var view = this.getView();
                if (view.toggleCheck && view.isCheckable(data)) {
                    view.toggleCheck(data);
                    return true;
                }
                return false;
            },
            _isSortable: function(data) {
                var view = this.getView();
                if (view.hasChildrenVisible(data)) {
                    return false;
                }
                return view.getDataViewProperty(data, "sortable") === true;
            }
        });
        var $TableHeadRenderer = function() {
            this._renderer = $domCreate("th");
            $RenderNodeUtil.initRenderNode(this);
            $TableHeadRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($TableHeadRenderer, $IDataWidgetRenderer, {
            _isRendererVisible: function(view, data) {
                var visible = $TableHeadRenderer.superClass._isRendererVisible.apply(this, arguments);
                if (visible === true) {
                    visible = view._isVisibleByRootData(data);
                }
                if (visible === true) {
                    visible = view._isBodyVisibleByRootData(data);
                }
                if (visible === true) {
                    visible = !view._isAllChildrenHidden(data);
                }
                return visible;
            },
            updateRenderConfig: function(view, data, renderConfig) {
                $TableHeadRenderer.superClass.updateRenderConfig.apply(this, arguments);
                renderConfig["template"] = view.getDataViewProperty(data, "head_template");
                renderConfig["is_root_data"] = view._isRootData(data);
                renderConfig["colspan"] = $TableHeadRenderUtil.calcColSpan(view, data);
                renderConfig["rowspan"] = $TableHeadRenderUtil.calcRowSpan(view, data);
                renderConfig["tree_column"] = view.isTreeColumn(data);
                renderConfig["has_children"] = view.hasChildrenVisible(data);
                var attributes = view.getDataRenderProperty(data, "attributes");
                this.updateRenderMinimizeConfig(view, data, renderConfig);
                if (this.getRenderConfig("minimized") !== true) {
                    this.updateRenderCheckConfig(view, data, renderConfig);
                    $RenderNodeUtil.updateRenderLevelCheckConfig(this, view, data, renderConfig);
                    this.updateRenderSortConfig(view, data, renderConfig);
                } else {
                    var label = this.getRenderConfig("label");
                    if (label) {
                        if (attributes == null) {
                            attributes = {
                                title: label
                            };
                        } else if ($isObject(attributes)) {
                            if (!attributes.hasOwnProperty("title")) {
                                attributes.title = label;
                            }
                        }
                    }
                }
                renderConfig["attributes"] = attributes;
            },
            updateRenderCheckConfig: function(view, data, renderConfig) {
                if (view.isCheckColumn(data)) {
                    renderConfig["check_column"] = true;
                    renderConfig["checkbox_visible"] = true;
                    renderConfig["checked"] = view.isChecked(data);
                    renderConfig["checkable"] = view.isCheckable(data);
                } else {
                    $RenderNodeUtil.updateRenderCheckConfig(this, view, data, renderConfig);
                }
            },
            updateRenderer: function(view, data, renderConfig) {
                $TableHeadRenderer.superClass.updateRenderer.apply(this, arguments);
                $domToggleClass(this._renderer, "root_data", this.getRenderConfig("is_root_data") === true);
                $domToggleClass(this._renderer, "leaf", this.getRenderConfig("has_children") !== true);
                this._renderer.setAttribute("colspan", this.getRenderConfig("colspan"));
                this._renderer.setAttribute("rowspan", this.getRenderConfig("rowspan"));
                var minimized = this.getRenderConfig("minimized") === true;
                $domToggleClass(this._renderer, "minimized", minimized);
                $RenderNodeUtil.updateRenderAttributes(this, view, data, renderConfig);
                if (!minimized) {
                    $RenderNodeUtil.updateRendererCheck(this, view, data, renderConfig);
                    $RenderNodeUtil.updateRenderIn(this, view, data, renderConfig);
                    this.updateRendererSort(view, data, renderConfig);
                    this.updateRendererMinimize(view, data, renderConfig);
                } else {
                    if (this._checkBoxWrapper) {
                        $domRemove(this._checkBoxWrapper);
                    }
                    if (this._sortWrapper) {
                        $domRemove(this._sortWrapper);
                    }
                    if (this._minimizeWrapper) {
                        $domRemove(this._minimizeWrapper);
                    }
                    var inWrapper = this._inWrapper;
                    inWrapper.innerHTML = this.getRenderConfig("minimize_label");
                }
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $TableHeadRenderer.superClass.updateRendererStatus.apply(this, arguments);
                $domToggleClass(this._renderer, "tree-column", this.getRenderConfig("tree_column") === true);
                $domToggleClass(this._renderer, "check-column", this.getRenderConfig("check_column") === true);
                $domToggleClass(this._renderer, "checked", this.getRenderConfig("checked") === true);
                $domToggleClass(this._renderer, "uncheckable", this.getRenderConfig("checkable") === false);
                $domToggleClass(this._renderer, "indeterminate-checked", this.getRenderConfig("indeterminate_checked") === true);
            },
            updateRenderSortConfig: function(view, data, renderConfig) {
                if (this.getRenderConfig("has_children") !== true) {
                    renderConfig["sortable"] = view.getDataViewProperty(data, "sortable") === true;
                    renderConfig["sort"] = view.getDataRenderProperty(data, "sort");
                } else {
                    renderConfig["sortable"] = false;
                }
            },
            updateRendererSort: function(view, data, renderConfig) {
                $domToggleClass(this._renderer, "sortable", this.getRenderConfig("sortable") === true);
                var sort = this.getRenderConfig("sort");
                if (this.getRenderConfig("has_children") !== true && sort != null) {
                    var sortWrapper = this._getSortWrapper();
                    var sortHTML = this._getSortTemplate();
                    var sortIndex = $ColumnSortUtil.getSortIndex(sort);
                    if (sortIndex > 0) {
                        sortHTML += "<span class='index'>" + sortIndex + "</span>";
                    }
                    sortWrapper.innerHTML = sortHTML;
                    $domSetClass(sortWrapper, this._getSortClass());
                    this.appendToNodeWrapper(sortWrapper);
                } else {
                    if (this._sortWrapper) {
                        $domRemove(this._sortWrapper);
                    }
                }
            },
            _getSortClass: function() {
                var clsArray = [ "sort" ];
                var sort = this.getRenderConfig("sort");
                if (sort != null) {
                    clsArray.push("sorted");
                    clsArray.push($ColumnSortUtil.getSortOrder(sort));
                }
                if (this.getRenderConfig("sortable") === true) {
                    clsArray.push("sortable");
                } else {
                    clsArray.push("unsortable");
                }
                return clsArray.join(" ");
            },
            _getSortWrapper: function() {
                if (!this._sortWrapper) {
                    this._sortWrapper = $domCreate("span");
                    this._sortWrapper.setAttribute("__z_dop_", "sort");
                }
                return this._sortWrapper;
            },
            _getSortTemplate: function() {
                if ($ColumnSortUtil.isAscSort($ColumnSortUtil.getSortOrder(this.getRenderConfig("sort")))) {
                    return this.getViewRenderConfig("sort_asc_icon_template");
                } else {
                    return this.getViewRenderConfig("sort_desc_icon_template");
                }
            },
            updateRenderMinimizeConfig: function(view, data, renderConfig) {
                if (this.getRenderConfig("has_children") !== true) {
                    var minimizable = view.getDataViewProperty(data, "minimizable") === true;
                    renderConfig["minimizable"] = minimizable;
                    if (minimizable) {
                        var minimized = view.isColumnMinimized(data);
                        renderConfig["minimized"] = minimized;
                        if (minimized) {
                            renderConfig["minimize_width"] = this.getViewRenderConfig("minimize_width");
                            renderConfig["minimize_label"] = this.getViewRenderConfig("minimize_label");
                        } else {
                            renderConfig["minimize_icon_template"] = this.getViewRenderConfig("minimize_icon_template");
                        }
                    }
                } else {
                    renderConfig["minimizable"] = false;
                }
            },
            updateRendererMinimize: function(view, data, renderConfig) {
                var minimizable = this.getRenderConfig("minimizable");
                $domToggleClass(this._renderer, "minimizable", minimizable);
                if (minimizable) {
                    var minimized = this.getRenderConfig("minimized");
                    $domToggleClass(this._renderer, "minimized", minimized);
                    if (!minimized) {
                        this.appendToNodeWrapper(this._getMinimizeWrapper());
                    }
                } else if (this._minimizeWrapper) {
                    $domRemove(this._minimizeWrapper);
                }
            },
            _getMinimizeWrapper: function() {
                if (!this._minimizeWrapper) {
                    this._minimizeWrapper = $domCreate("span", "minimize");
                    this._minimizeWrapper.setAttribute("__z_dop_", "minimize");
                    this._minimizeWrapper.innerHTML = this.getViewRenderConfig("minimize_icon_template");
                }
                return this._minimizeWrapper;
            },
            insertToNodeWrapperFirst: function(ele) {
                var firstChild = this._nodeWrapper.firstElementChild;
                if (firstChild !== ele) {
                    this._nodeWrapper.insertBefore(ele, firstChild);
                }
            },
            appendToNodeWrapper: function(ele) {
                this._nodeWrapper.appendChild(ele);
            },
            getNodeWrapper: function() {
                return this._nodeWrapper;
            },
            reBuildRenderer: function() {
                this._renderer.appendChild(this._nodeWrapper);
            }
        });
        var $TableBodyRenderUtil = {
            getCellValue: function(data, column) {
                var field = column.getProperty("field");
                var value;
                if (field) {
                    value = $getObjectDeepValue(data.getProperties(false), field);
                }
                if (value == null) {
                    var defaultValue = column.getProperty("default");
                    if (defaultValue != null) {
                        value = defaultValue;
                    } else {
                        value = "";
                    }
                }
                return value;
            }
        };
        var $TableBodyView = function() {
            this._tableBody = $domCreate("tbody");
            $TableBodyView.superClass.constructor.apply(this, arguments);
            this._table.appendChild(this._tableBody);
            $domAddClass(this.getRoot(), "z-tbody");
        };
        $extendClass($TableBodyView, $IDataTableView, $mergeObject({
            ___zdefaults_: $mergeObject({
                model_select: true,
                model_expand: true,
                model_check: true
            }, $CheckInterfaceDefault()),
            makeVisible: function(data) {},
            setTableHead: function(tableHead) {
                this._tableHead = tableHead;
            },
            getRendererRootContainer: function() {
                return this._tableBody;
            },
            getRendererContainer: function(data) {
                return this._tableBody;
            },
            hEachColumn: function(callBack, context) {
                if (this._tableHead) {
                    this._tableHead.hEachColumn(callBack, context);
                }
            },
            isColumnMinimized: function(col) {
                if (this._tableHead) {
                    return this._tableHead.isColumnMinimized(col);
                }
                return false;
            },
            hasCheckColumn: function() {
                return false;
            },
            isCheckColumn: function(column) {
                return false;
            },
            _getCellValue: function(data, column) {
                return this.getCellValue(data, column);
            },
            getCellValue: function(data, column) {
                return $TableBodyRenderUtil.getCellValue(data, column);
            },
            getDataRendererClass: function(data) {
                return $TableBodyRenderer;
            }
        }, $ListViewInterface($TableBodyView), $CheckInterface($TableBodyView)));
        var $TableBodyRenderer = function() {
            this._renderer = $domCreate("tr", "item");
            $TableBodyRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($TableBodyRenderer, $IDataElementRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $TableBodyRenderer.superClass.updateRenderConfig.apply(this, arguments);
                this._renderConfig["row_template"] = view.getDataViewProperty(data, "row_template");
                this._renderConfig["selectable"] = view.isSelectable(data);
                this._renderConfig["hover"] = view.isHover(data);
                if (view.hasCheckColumn()) {
                    renderConfig["checkbox_visible"] = true;
                    renderConfig["checked"] = view.isChecked(data);
                    renderConfig["checkable"] = view.isCheckable(data);
                }
            },
            updateRenderer: function(view, data, renderConfig) {
                $TableBodyRenderer.superClass.updateRenderer.apply(this, arguments);
                $domEmpty(this._renderer);
                var row_template = this.getRenderConfig("row_template");
                if (row_template) {
                    this._renderer.innerHTML = $renderTemplate(row_template, data.getProperties(false));
                } else {
                    view.hEachColumn(this._renderColumn, this);
                }
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $TableBodyRenderer.superClass.updateRendererStatus.apply(this, arguments);
                $domToggleClass(this._renderer, "unselectable", this.getRenderConfig("selectable") === false);
                $domToggleClass(this._renderer, "hover", this.getRenderConfig("hover") === true);
                $domToggleClass(this._renderer, "checked", this.getRenderConfig("checked") === true);
                $domToggleClass(this._renderer, "uncheckable", this.getRenderConfig("checkable") === false);
            },
            _renderColumn: function(column, columnVisible) {
                var view = this._view;
                var td = $domCreate("td", {
                    className: column.get("className") || column.get("class"),
                    style: column.get("style"),
                    attributes: column.get("attributes")
                });
                this._renderer.appendChild(td);
                if (columnVisible === true) {
                    if (!view.isColumnMinimized(column)) {
                        this._renderCommonColumn(td, column);
                        if (view.isCheckColumn(column)) {
                            this._renderCheckColumn(td, column);
                        }
                    }
                }
                return td;
            },
            _renderCommonColumn: function(td, column) {
                var view = this._view;
                var data = this._data;
                var render = column.render;
                if ($isFunction(render)) {
                    render.apply(view, [ td, data, column, view, this._renderer ]);
                } else {
                    var template = column.getProperty("template");
                    var innerHTML;
                    if (template) {
                        innerHTML = $renderTemplate(template, data.getProperties(false));
                    } else {
                        innerHTML = view._getCellValue(data, column);
                    }
                    td.innerHTML = innerHTML;
                }
            },
            _renderCheckColumn: function(td, column) {
                $domAddClass(td, "check-column");
                var checkEle = $RenderNodeUtil._getCheckboxWrapper(this);
                checkEle.innerHTML = $RenderNodeUtil._getCheckboxTemplate(this);
                td.insertBefore(checkEle, td.firstChild);
            }
        });
        var $TreeTableBodyView = function() {
            this._tableBody = $domCreate("tbody");
            $TreeTableBodyView.superClass.constructor.apply(this, arguments);
            this._table.appendChild(this._tableBody);
            $domAddClass(this.getRoot(), "z-tbody");
        };
        $extendClass($TreeTableBodyView, $IDataTableView, $mergeObject({
            ___zdefaults_: $mergeObject({
                model_select: true,
                model_expand: true,
                model_check: true
            }, $CheckInterfaceDefault(), $ExpandInterfaceDefault()),
            _onViewChange: function(key, value, old) {
                $TreeTableBodyView.superClass._onViewChange.apply(this, arguments);
                this._doViewThreeStatesCheckUpdate(key);
            },
            _doViewThreeStatesCheckUpdate: function(key) {
                if (key === "three_states_check") {
                    if (this._checkProvider) this.clearCheck();
                }
            },
            makeVisible: function(data) {},
            setTableHead: function(tableHead) {
                this._tableHead = tableHead;
            },
            getRendererRootContainer: function() {
                return this._tableBody;
            },
            getRendererContainer: function(data) {
                return this._tableBody;
            },
            hEachColumn: function(callBack, context) {
                if (this._tableHead) {
                    this._tableHead.hEachColumn(callBack, context);
                }
            },
            isColumnMinimized: function(col) {
                if (this._tableHead) {
                    return this._tableHead.isColumnMinimized(col);
                }
                return false;
            },
            hasCheckColumn: function() {
                return this._tableHead.hasCheckColumn();
            },
            isCheckColumn: function(column) {
                return this._tableHead.isCheckColumn(column);
            },
            isTreeColumn: function(column) {
                return column.getProperty("tree") === true;
            },
            _getCellValue: function(data, column) {
                return this.getCellValue(data, column);
            },
            getCellValue: function(data, column) {
                return $TableBodyRenderUtil.getCellValue(data, column);
            },
            getDataRendererClass: function(data) {
                return $TreeTableBodyRenderer;
            }
        }, $LevelListViewInterface($TreeTableBodyView), $LevelCheckInterface($TreeTableBodyView), $ExpandInterface($TreeTableBodyView), {
            _isExpandable: function(data) {
                var isLeaf = false;
                if (!this.hasChildrenVisible(data)) {
                    isLeaf = true;
                }
                if (isLeaf === true) {
                    return false;
                }
                if (this.isExpandable(data) === false) {
                    return false;
                }
                return true;
            }
        }));
        var $TreeTableBodyRenderer = function() {
            $TreeTableBodyRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($TreeTableBodyRenderer, $TableBodyRenderer, {
            _isRendererVisible: function(view, data) {
                var visible = $TreeTableBodyRenderer.superClass._isRendererVisible.apply(this, arguments);
                if (visible === true) {
                    visible = view._isVisibleByRootData(data);
                }
                return visible;
            },
            updateRenderConfig: function(view, data, renderConfig) {
                $TreeTableBodyRenderer.superClass.updateRenderConfig.apply(this, arguments);
                this._renderConfig["is_root_data"] = view._isRootData(data);
                $RenderNodeUtil.updateRenderLevelCheckConfig(this, view, data, renderConfig);
                $RenderNodeUtil.updateRenderExpandConfig(this, view, data, renderConfig);
                this._renderConfig["data_level"] = view._getDataLevel(data);
            },
            updateRenderer: function(view, data, renderConfig) {
                $domToggleClass(this._renderer, "root_data", this.getRenderConfig("is_root_data") === true);
                $TreeTableBodyRenderer.superClass.updateRenderer.apply(this, arguments);
                $domToggleClass(this._renderer, "leaf", this.getRenderConfig("has_children") !== true);
            },
            updateRendererStatus: function(view, data, renderConfig) {
                $TreeTableBodyRenderer.superClass.updateRendererStatus.apply(this, arguments);
                $domToggleClass(this._renderer, "unexpandable", this.getRenderConfig("expandable") === false);
                $domToggleClass(this._renderer, "indeterminate-checked", this.getRenderConfig("indeterminate_checked") === true);
            },
            _renderColumn: function(column, columnVisible) {
                var view = this._view;
                var td = $TreeTableBodyRenderer.superClass._renderColumn.apply(this, arguments);
                if (columnVisible === true) {
                    if (!view.isColumnMinimized(column)) {
                        if (view.isTreeColumn(column)) {
                            this._renderTreeColumn(td, column);
                        }
                    }
                }
            },
            _renderTreeColumn: function(td, column) {
                $domAddClass(td, "tree-column");
                if (this.getRenderConfig("has_children") === true) {
                    if (this.getRenderConfig("expand_icon_visible") !== false) {
                        var expandWrapper = $RenderNodeUtil._getExpandWrapper(this);
                        expandWrapper.innerHTML = $RenderNodeUtil._getExpandTemplate(this);
                        $domSetClass(expandWrapper, $RenderNodeUtil._getExpandClass(this));
                        td.insertBefore(expandWrapper, td.firstChild);
                    }
                }
                var level = this.getRenderConfig("data_level");
                for (var i = 0; i < level; i++) {
                    td.insertBefore($domCreate("span", "indent"), td.firstChild);
                }
            }
        });
        var $ListView = function() {
            if (!(this instanceof $ListView)) {
                return $ClassUtil.createInstance($ListView, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-listview", arg0);
            }
            $ListView.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-listview");
        };
        $extendClass($ListView, $IDataULListView, {
            __className_: "ListView"
        });
        var $TabsScrollController = function() {
            $TabsScrollController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($TabsScrollController, $IViewController, {
            add: function(view) {
                $TabsScrollController.superClass.add.apply(this, arguments);
                var prevEle = view._prevEle;
                $domOn(prevEle, "mousedown", this.toPrev, this);
                $domOn(prevEle, "mouseup", this.stopScroll, this);
                $domOn(prevEle, "mouseleave", this.stopScroll, this);
                var nextEle = view._nextEle;
                $domOn(nextEle, "mousedown", this.toNext, this);
                $domOn(nextEle, "mouseup", this.stopScroll, this);
                $domOn(nextEle, "mouseleave", this.stopScroll, this);
                $DomWheelEventUtil.addWheelListener(view._tabsView, this.handleTabsWheel, this);
            },
            remove: function() {
                var prevEle = this._view._prevEle;
                $domOff(prevEle, "mousedown", this.toPrev, this);
                $domOff(prevEle, "mouseup", this.stopScroll, this);
                $domOff(prevEle, "mouseleave", this.stopScroll, this);
                var nextEle = this._view._nextEle;
                $domOff(nextEle, "mousedown", this.toNext, this);
                $domOff(nextEle, "mouseup", this.stopScroll, this);
                $domOff(nextEle, "mouseleave", this.stopScroll, this);
                $DomWheelEventUtil.removeWheelListener(this._view._tabsView, this.handleTabsWheel, this);
                $TabsScrollController.superClass.remove.apply(this, arguments);
            },
            handleTabsWheel: function(evt) {
                var isDown = evt.wheelDelta < 0 || evt.deltaY > 0 || evt.detail > 0;
                var scrollOffset = isDown ? 10 : -10;
                var tabPosition = this._view.getProperty("tab_position");
                var scrollDirection = tabPosition === "top" || tabPosition === "bottom" ? "scrollLeft" : "scrollTop";
                var current = this._view._rootUL[scrollDirection];
                this._view._rootUL[scrollDirection] += scrollOffset;
                if (current !== this._view._rootUL[scrollDirection]) {
                    evt.preventDefault();
                }
            },
            stopScroll: function() {
                this._scrollStop = true;
            },
            toPrev: function() {
                this.startScroll(-6);
            },
            toNext: function() {
                this.startScroll(6);
            },
            startScroll: function(offset) {
                this._scrollStop = false;
                this._scrollOffset = offset;
                var tabPosition = this._view.getProperty("tab_position");
                this._scrollDirection = tabPosition === "top" || tabPosition === "bottom" ? "scrollLeft" : "scrollTop";
                $TimerUtil.cancelCallRAFInterval(this.scroll, this);
                $callRAFInterval(this.scroll, this);
            },
            scroll: function() {
                if (this._scrollStop === true) {
                    return false;
                }
                var current = this._view._rootUL[this._scrollDirection];
                this._view._rootUL[this._scrollDirection] += this._scrollOffset;
                if (current === this._view._rootUL[this._scrollDirection]) {
                    this.stopScroll();
                }
            }
        });
        var $Tabs = function() {
            if (!(this instanceof $Tabs)) {
                return $ClassUtil.createInstance($Tabs, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-tabs", arg0);
            }
            this._contentContainer = $domCreate("div", "contents");
            this._prevEle = $domCreate("span", "to_prev");
            this._nextEle = $domCreate("span", "to_next");
            this._tabsView = $domCreate("div", "tabs");
            $Tabs.superClass.constructor.apply(this, arguments);
            var root = this.getRoot();
            $domAddClass(root, "z-tabs");
            this._tabsView.appendChild(this._rootUL);
            this._tabsView.appendChild(this._prevEle);
            this._tabsView.appendChild(this._nextEle);
            root.appendChild(this._tabsView);
            this._doTabPositionUpdate();
            this._doTabContentVisibleUpdate();
            this._doUpdateTabScrollAndSize();
            this.addController(new $TabsScrollController());
        };
        $extendClass($Tabs, $IDataULListView, $mergeObject({
            __className_: "Tabs",
            ___zdefaults_: {
                onresize: true,
                content_visible: true,
                content_lazy_load: false,
                content_auto_resize: true,
                content_container: null,
                tab_position: "top",
                auto_select: true,
                scroll_to_left_arrow_icon_template: $IconTemplate.tabs_scroll_to_left_arrow,
                scroll_to_right_arrow_icon_template: $IconTemplate.tabs_scroll_to_right_arrow,
                scroll_to_up_arrow_icon_template: $IconTemplate.tabs_scroll_to_up_arrow,
                scroll_to_down_arrow_icon_template: $IconTemplate.tabs_scroll_to_down_arrow
            },
            _getPrevEle: function() {
                return this._prevEle;
            },
            _getNextEle: function() {
                return this._nextEle;
            },
            _onViewUpdate: function() {
                $Tabs.superClass._onViewUpdate.apply(this, arguments);
                this._doUpdateTabScrollAndSize();
            },
            _onViewChange: function(key, value, old) {
                $Tabs.superClass._onViewChange.apply(this, arguments);
                if (key === "tab_position") {
                    this._doTabPositionUpdate();
                } else if (key === "content_visible") {
                    this._doTabContentVisibleUpdate();
                } else if (key === "content_lazy_load") {
                    this._doTabContentLazyLoadUpdate();
                } else if (key === "content_container") {
                    this._doTabContentContainerUpdate();
                }
            },
            _doTabPositionUpdate: function() {
                var root = this.getRoot();
                $domRemoveClass(root, "top bottom left right");
                $domAddClass(root, this.getProperty("tab_position"));
                if (this._isContentVisible() && this._isUseDefaultContentContainer()) {
                    this._insertContentContainerByOrder();
                }
                this._doTabScrollArrowUpdate();
            },
            _doTabScrollArrowUpdate: function() {
                var tabPosition = this.getProperty("tab_position");
                if (tabPosition === "left" || tabPosition === "right") {
                    this._prevEle.innerHTML = this.getProperty("scroll_to_up_arrow_icon_template");
                    this._nextEle.innerHTML = this.getProperty("scroll_to_down_arrow_icon_template");
                } else {
                    this._prevEle.innerHTML = this.getProperty("scroll_to_left_arrow_icon_template");
                    this._nextEle.innerHTML = this.getProperty("scroll_to_right_arrow_icon_template");
                }
            },
            _insertContentContainerByOrder: function() {
                var root = this.getRoot();
                if (this.getProperty("tab_position") === "bottom") {
                    root.insertBefore(this._contentContainer, root.firstElementChild);
                } else {
                    root.appendChild(this._contentContainer);
                }
            },
            _doTabContentVisibleUpdate: function() {
                if (this._isContentVisible()) {
                    if (this._isUseDefaultContentContainer()) {
                        this._insertContentContainerByOrder();
                    }
                    this._doTabContentLazyLoadUpdate();
                    var lastSelect = this.getLastSelected();
                    if (lastSelect) {
                        this.setCurrentDataContent(lastSelect);
                    }
                } else {
                    this.clearDataContent();
                    if (this._isUseDefaultContentContainer()) {
                        $domRemove(this._contentContainer);
                    }
                }
            },
            _doTabContentLazyLoadUpdate: function() {
                if (!this._isContentLazyLoad()) {
                    this.eachData(function(data) {
                        if (!this.isDataContentAdded(data)) {
                            this.addDataContent(data);
                        }
                    }, this);
                }
            },
            _doTabContentContainerUpdate: function() {
                if (!this._isUseDefaultContentContainer()) {
                    $domRemove(this._contentContainer);
                } else {
                    if (this._isContentVisible()) {
                        this._insertContentContainerByOrder();
                    }
                }
            },
            getContentContainer: function() {
                var cc = this.getProperty("content_container");
                if (cc) {
                    return $domQueryElement(cc);
                }
                return this._contentContainer;
            },
            _isUseDefaultContentContainer: function() {
                return this.getProperty("content_container") == null;
            },
            _onDataAdd: function(data) {
                $Tabs.superClass._onDataAdd.apply(this, arguments);
                if (this._isContentVisible() && !this._isContentLazyLoad()) {
                    this.addDataContent(data);
                }
            },
            _onDataRemove: function(data) {
                $Tabs.superClass._onDataRemove.apply(this, arguments);
                if (this._isContentVisible()) {
                    this.removeDataContent(data);
                }
            },
            _onDataClear: function() {
                $Tabs.superClass._onDataClear.apply(this, arguments);
                if (this._isContentVisible()) {
                    this.clearDataContent();
                }
            },
            _onDataChange: function(data, evt) {
                $Tabs.superClass._onDataChange.apply(this, arguments);
                if (this._isContentVisible()) {
                    if (evt.property === "content") {
                        this.removeDataContent(data);
                        if (this.getLastSelected() === data) {
                            this.setCurrentDataContent(data);
                        } else if (!this._isContentLazyLoad()) {
                            this.addDataContent(data);
                        }
                    }
                }
            },
            _onModelChange: function(type) {
                $Tabs.superClass._onModelChange.apply(this, arguments);
                if (type === "set_provider") {
                    this._doTabContentLazyLoadUpdate();
                }
            },
            _onSelectBatchChange: function() {
                $Tabs.superClass._onSelectBatchChange.apply(this, arguments);
                if (this._isContentVisible()) {
                    var lastSelect = this.getLastSelected();
                    if (lastSelect) {
                        this.setCurrentDataContent(lastSelect);
                    }
                }
            },
            _getScrollView: function() {
                return this._rootUL;
            },
            _isContentVisible: function() {
                return this.getProperty("content_visible") !== false;
            },
            _isContentLazyLoad: function() {
                return this.getProperty("content_lazy_load") === true;
            },
            _doResizeUpdate: function() {
                $Tabs.superClass._doResizeUpdate.apply(this, arguments);
                this._doUpdateTabScrollAndSize();
            },
            _doUpdateTabScrollAndSize: function(resize) {
                this._doUpdateTabScroll();
                this._doUpdateTabSize();
            },
            _doUpdateTabScroll: function() {
                var position = this.getProperty("tab_position");
                $domRemoveStyle(this._tabsView, "padding-top");
                $domRemoveStyle(this._tabsView, "padding-bottom");
                $domRemoveStyle(this._tabsView, "padding-left");
                $domRemoveStyle(this._tabsView, "padding-right");
                if (position === "top" || position === "bottom") {
                    var tabWidth = this._rootUL.scrollWidth;
                    var tabViewPortWidth = this._tabsView.clientWidth;
                    if (tabWidth > tabViewPortWidth) {
                        if ($domGetStyle(this._prevEle, "display") === "none") {
                            $domRemoveStyle(this._prevEle, "display");
                            $domRemoveStyle(this._nextEle, "display");
                        }
                        $domSetStyle(this._tabsView, "padding-left", this._prevEle.offsetWidth + "px");
                        $domSetStyle(this._tabsView, "padding-right", this._nextEle.offsetWidth + "px");
                    } else {
                        $domSetStyle(this._prevEle, "display", "none");
                        $domSetStyle(this._nextEle, "display", "none");
                    }
                } else {
                    var tabHeight = this._rootUL.scrollHeight;
                    var tabViewPortHeight = this._tabsView.clientHeight;
                    if (tabHeight > tabViewPortHeight) {
                        if ($domGetStyle(this._prevEle, "display") === "none") {
                            $domRemoveStyle(this._prevEle, "display");
                            $domRemoveStyle(this._nextEle, "display");
                        }
                        $domSetStyle(this._tabsView, "padding-top", this._prevEle.offsetHeight + "px");
                        $domSetStyle(this._tabsView, "padding-bottom", this._nextEle.offsetHeight + "px");
                    } else {
                        $domSetStyle(this._prevEle, "display", "none");
                        $domSetStyle(this._nextEle, "display", "none");
                    }
                }
            },
            _doUpdateTabSize: function() {
                if (this._isContentVisible() && this._isUseDefaultContentContainer()) {
                    if (this.getProperty("content_auto_resize") !== false) {
                        var rootParent = this.getRoot().parentNode;
                        if (rootParent && $domGetStyle(rootParent, "height")) {
                            var position = this.getProperty("tab_position");
                            if (position === "top" || position === "bottom") {
                                var size = this.getRootSize();
                                var tabHeight = this._rootUL.offsetHeight;
                                $domSetStyle(this._contentContainer, "height", size.height - tabHeight - 1 + "px");
                                return;
                            }
                        }
                    }
                    $domRemoveStyle(this._contentContainer, "height");
                }
            }
        }, $DataContentInterface($Tabs)));
        var $Tree = function() {
            if (!(this instanceof $Tree)) {
                return $ClassUtil.createInstance($Tree, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-tree", arg0);
            }
            $Tree.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-tree");
        };
        $extendClass($Tree, $IDataULLevelView, {
            __className_: "Tree"
        });
        var $CollapseRenderer = function() {
            this._contentContainer = $domCreate("div", "content");
            $CollapseRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($CollapseRenderer, $IDataULRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $CollapseRenderer.superClass.updateRenderConfig.apply(this, arguments);
                this._renderConfig["expanded"] = view.isExpanded(data);
                var expandVisible = view.getDataViewProperty(data, "expand_icon_visible") !== false;
                this._renderConfig["expand_icon_visible"] = expandVisible;
                if (expandVisible === true) {
                    this._renderConfig["expandable"] = view.isExpandable(data);
                }
                this._renderConfig["content"] = view.getDataRenderProperty(data, "content");
            },
            updateRenderer: function(view, data, renderConfig) {
                $CollapseRenderer.superClass.updateRenderer.apply(this, arguments);
                $domToggleClass(this._renderer, "expanded", this.getRenderConfig("expanded") === true);
                $domToggleClass(this._renderer, "unexpandable", this.getRenderConfig("expandable") !== true);
                this._updateRendererExpand();
                this._updateRendererContent();
            },
            _updateRendererExpand: function() {
                if (this.getRenderConfig("expand_icon_visible") !== false) {
                    var expandWrapper = this._getExpandWrapper();
                    expandWrapper.innerHTML = this._getExpandTemplate();
                    $domSetClass(expandWrapper, this._getExpandClass());
                    this.insertToNodeWrapperFirst(expandWrapper);
                } else {
                    if (this._expandWrapper) {
                        $domRemove(this._expandWrapper);
                    }
                }
            },
            _getExpandTemplate: function() {
                if (this.getRenderConfig("expanded") === true) {
                    return this.getViewRenderConfig("expand_expanded_icon_template");
                } else {
                    return this.getViewRenderConfig("expand_collapsed_icon_template");
                }
            },
            _getExpandClass: function() {
                var clsArray = [ "expand" ];
                if (this.getRenderConfig("expanded") === true) {
                    clsArray.push("expanded");
                } else {
                    clsArray.push("collapsed");
                }
                if (this.getRenderConfig("expandable") === true) {
                    clsArray.push("expandable");
                } else {
                    clsArray.push("unexpandable");
                }
                return clsArray.join(" ");
            },
            _getExpandWrapper: function() {
                if (!this._expandWrapper) {
                    this._expandWrapper = $domCreate("span");
                    this._expandWrapper.setAttribute("__z_dop_", "expand");
                }
                return this._expandWrapper;
            },
            _updateRendererContent: function() {
                var dataContent = this.getRenderConfig("content");
                if (this._currentContent !== dataContent) {
                    $ContentUtil.releaseContent(this._currentContentObj);
                    this._currentContent = dataContent;
                    this._currentContentObj = $ContentUtil.getContentObject(dataContent);
                    if (this._currentContentObj) {
                        var contentEle = this._currentContentObj.contentEle;
                        if (contentEle) {
                            this._contentContainer.appendChild(contentEle);
                        }
                        $ContentUtil.showContent(this._currentContentObj);
                    }
                }
                if (!this._contentContainer.parentNode) {
                    this._renderer.appendChild(this._contentContainer);
                }
                if (this.getRenderConfig("expanded") === true) {
                    $ContentUtil.showContent(this._currentContentObj);
                    if (this._currentContentObj && this._currentContentObj.contentEle) {
                        $domRemoveStyle(this._contentContainer, "display");
                    } else {
                        $domSetStyle(this._contentContainer, "display", "none");
                    }
                } else {
                    $ContentUtil.hideContent(this._currentContentObj);
                    $domSetStyle(this._contentContainer, "display", "none");
                }
            },
            dispose: function() {
                $CollapseRenderer.superClass.dispose.apply(this, arguments);
                if (this._currentContentObj) {
                    $ContentUtil.releaseContent(this._currentContentObj);
                }
            }
        });
        var $Collapse = function() {
            if (!(this instanceof $Collapse)) {
                return $ClassUtil.createInstance($Collapse, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-collapse", arg0);
            }
            $Collapse.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-collapse");
        };
        $extendClass($Collapse, $IDataULListView, $mergeObject({
            __className_: "Collapse",
            ___zdefaults_: $mergeObject({
                make_visible_on_select: false
            }, $ExpandInterfaceDefault({
                expand_on_click: true
            })),
            getDataRendererClass: function(data) {
                return $CollapseRenderer;
            },
            getDataAt: function(evt) {
                if (!$WViewUtil.isEvtInRendererNode(evt)) {
                    return null;
                }
                return $Collapse.superClass.getDataAt.apply(this, arguments);
            }
        }, $ExpandInterface($Collapse)));
        var $Carousel = function() {
            if (!(this instanceof $Carousel)) {
                return $ClassUtil.createInstance($Carousel, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-carousel", arg0);
            }
            this._contentContainer = $domCreate("div", "contents");
            this._initDataContentInterface(true);
            this._indicatorView = $domCreate("div", "indicators");
            $Carousel.superClass.constructor.apply(this, arguments);
            this._initIndicatorView();
            $domAddClass(this.getRoot(), "z-carousel");
        };
        $extendClass($Carousel, $IDataULListView, $mergeObject({
            __className_: "Carousel",
            ___zdefaults_: {
                auto_select: true,
                indicator_visible: true,
                scroll_arrow_visible: true,
                auto_play: true,
                interval: 3e3,
                hover_pause: true,
                scroll_to_prev_arrow_template: "<a class='fz-icon fz-angle-left'></a>",
                scroll_to_next_arrow_template: "<a class='fz-icon fz-angle-right'></a>"
            },
            _initIndicatorView: function() {
                this._prevEle = $domCreate("span", "to_prev");
                this._prevEle.innerHTML = this._getCommonProperty("scroll_to_prev_arrow_template");
                this._nextEle = $domCreate("span", "to_next");
                this._nextEle.innerHTML = this._getCommonProperty("scroll_to_next_arrow_template");
                this._indicatorView.appendChild(this._rootUL);
                this.getRoot().appendChild(this._contentContainer);
                this.getRoot().appendChild(this._prevEle);
                this.getRoot().appendChild(this._nextEle);
                this.getRoot().appendChild(this._indicatorView);
            },
            _getPrevEle: function() {
                return this._prevEle;
            },
            _getNextEle: function() {
                return this._nextEle;
            },
            _getContentContainer: function() {
                return this._contentContainer;
            },
            _onDataAdd: function(data) {
                $Carousel.superClass._onDataAdd.apply(this, arguments);
                this.addDataContent(data);
            },
            _onDataRemove: function(data) {
                $Carousel.superClass._onDataRemove.apply(this, arguments);
                this.removeDataContent(data);
            },
            _onDataClear: function() {
                $Carousel.superClass._onDataClear.apply(this, arguments);
                this.clearDataContent();
            },
            _onDataChange: function(data, evt) {
                $Carousel.superClass._onDataChange.apply(this, arguments);
                if (evt.property === "content") {
                    this.removeDataContent(data);
                    if (this.getLastSelect() === data) {
                        this.setCurrentDataContent(data);
                    } else {
                        this.addDataContent(data);
                    }
                }
            },
            _onSelectBatchChange: function() {
                $Carousel.superClass._onSelectBatchChange.apply(this, arguments);
                var lastSelect = this.getLastSelect();
                if (lastSelect) {
                    this.setCurrentDataContent(lastSelect);
                }
                $TimeUtil.cancelCallLater(this.toNext, 3e3, this);
                if (this._getCommonProperty("auto_play") === true) {
                    $callLater(this.toNext, 1e3, this);
                }
            },
            toNext: function() {
                var nextData = this._getNextData();
                if (nextData) {
                    this.setSelect(nextData);
                }
            },
            _getPrevData: function() {
                var dataArray = this._getSortDataArray(this.getProvider().toRootArray(false));
                var currentIndex = -1;
                var startIndex = 0;
                var lastSelect = this.getLastSelect();
                if (lastSelect) {
                    currentIndex = dataArray.indexOf(lastSelect);
                    startIndex = 1;
                }
                var count = dataArray.length;
                if (currentIndex >= 0) {
                    var nextArray = dataArray.splice(currentIndex);
                    nextArray.shift();
                    dataArray.unshift.apply(dataArray, nextArray);
                }
                for (var i = count - 1; i >= startIndex; i--) {
                    var data = dataArray[i];
                    if (this.isVisible(data) && !this.isDisabled(data) && this.isSelectable(data)) {
                        return data;
                    }
                }
            },
            _getNextData: function() {
                var dataArray = this._getSortDataArray(this.getProvider().toRootArray(false));
                var lastSelect = this.getLastSelect();
                if (lastSelect) {
                    var prevArray = dataArray.splice(0, dataArray.indexOf(lastSelect));
                    dataArray.shift();
                    dataArray.push.apply(dataArray, prevArray);
                }
                var count = dataArray.length;
                for (var i = 0; i < count; i++) {
                    var data = dataArray[i];
                    if (this.isVisible(data) && !this.isDisabled(data) && this.isSelectable(data)) {
                        return data;
                    }
                }
            }
        }, $ContentInterface($Carousel), {
            beforeHideContent: function(content) {
                this._lastContent = content;
                var last = this.getLastSelect();
                if (last) {
                    var nextContent = this.getDataContent(last);
                    var lastID = this._lastContent._id;
                    var nextID = nextContent._id;
                }
            }
        }));
        var $PagerUtil = {
            getPagerDataInfo: function(data, dataIndex, pageNumber, pageIndex, pagerCount) {
                if (dataIndex === 0) {
                    return "to_prev";
                }
                dataIndex -= 1;
                pageNumber = $MathMax(1, pageNumber);
                if (pageNumber <= pagerCount) {
                    if (dataIndex <= pageNumber - 1) {
                        return dataIndex;
                    }
                    if (dataIndex === pageNumber) {
                        return "to_next";
                    }
                } else {
                    if (pageIndex <= pagerCount / 2) {
                        if (dataIndex === pagerCount - 1) {
                            return "to_next_more";
                        } else if (dataIndex === pagerCount) {
                            return pageNumber - 1;
                        } else if (dataIndex === pagerCount + 1) {
                            return "to_next";
                        } else if (dataIndex < pagerCount - 1) {
                            return dataIndex;
                        }
                    } else if (pageIndex > pageNumber - pagerCount / 2 - 1) {
                        if (dataIndex === 0) {
                            return 0;
                        } else if (dataIndex === 1) {
                            return "to_prev_more";
                        } else if (dataIndex === pagerCount + 1) {
                            return "to_next";
                        } else if (dataIndex <= pagerCount) {
                            return pageNumber + dataIndex - pagerCount - 1;
                        }
                    } else {
                        if (dataIndex === 0) {
                            return 0;
                        } else if (dataIndex === 1) {
                            return "to_prev_more";
                        } else if (dataIndex === pagerCount + 2) {
                            return "to_next";
                        } else if (dataIndex === pagerCount + 1) {
                            return pageNumber - 1;
                        } else if (dataIndex === pagerCount) {
                            return "to_next_more";
                        } else if (dataIndex < pagerCount) {
                            return pageIndex - ((pagerCount - 2) / 2 | 0) + (dataIndex - 2);
                        }
                    }
                }
            }
        };
        var $PagerULView = function(pager) {
            this._pager = pager;
            $PagerULView.superClass.constructor.apply(this, []);
        };
        $extendClass($PagerULView, $IDataULListView, {
            _getPagerCommonProperty: function(key) {
                return this._pager.getProperty(key);
            },
            _getPagerPageIndex: function() {
                return this._pager._getPageIndex() - 1;
            },
            _setPagerPageIndex: function(pageIndex) {
                this._pager.set("page_index", pageIndex + 1);
            },
            _getPagerPageNumber: function() {
                return this._pager._getPageNumber();
            },
            _getPagerPagerCount: function() {
                return this._pager._getPagerCount();
            },
            isVisible: function(data) {
                return data.getProperty("role") != null;
            },
            getLabel: function(data) {
                var role = data.getProperty("role");
                if (role != null) {
                    if (role === "to_prev") {
                        return this._getPagerCommonProperty("to_prev_icon_template");
                    } else if (role === "to_next") {
                        return this._getPagerCommonProperty("to_next_icon_template");
                    } else if (role === "to_prev_more") {
                        return this._getPagerCommonProperty("to_prev_more_icon_template");
                    } else if (role === "to_next_more") {
                        return this._getPagerCommonProperty("to_next_more_icon_template");
                    }
                    return role + 1;
                }
                return role;
            },
            isDisabled: function(data) {
                var role = data.getProperty("role");
                if (role == null) {
                    return true;
                }
                var pageIndex = this._getPagerPageIndex();
                if (role === "to_prev") {
                    return pageIndex <= 0;
                }
                if (role === "to_next") {
                    return pageIndex >= this._getPagerPageNumber() - 1;
                }
                return false;
            },
            _onDataClick: function(data) {
                var role = data.getProperty("role");
                if (role == null) {
                    return;
                }
                if ($isNumber(role)) {
                    this._setPagerPageIndex(role);
                    return;
                }
                var pageIndex = this._getPagerPageIndex();
                if (role === "to_prev") {
                    if (pageIndex > 0) {
                        this._setPagerPageIndex(pageIndex - 1);
                    }
                } else if (role === "to_next") {
                    if (pageIndex < this._getPagerPageNumber() - 1) {
                        this._setPagerPageIndex(pageIndex + 1);
                    }
                } else if (role === "to_prev_more") {
                    this._setPagerPageIndex($MathMax(0, pageIndex - (this._getPagerPagerCount() - 2)));
                } else if (role === "to_next_more") {
                    this._setPagerPageIndex($MathMin(this._getPagerPageNumber() - 1, pageIndex + (this._getPagerPagerCount() - 2)));
                }
            },
            updatePagerData: function() {
                this._updatePagerDataCount();
                this._updatePagerDataRole();
            },
            _updatePagerDataCount: function() {
                var count = this._getPagerPagerCount() + 4;
                var dataCount = this.getDataSize();
                if (dataCount === count) {
                    return;
                }
                if (dataCount < count) {
                    for (var i = dataCount; i < count; i++) {
                        this.addData(new $Data());
                    }
                } else {
                    var dataArray = this.getDataArray();
                    for (var j = count; j < dataCount; j++) {
                        this.removeData(dataArray[j]);
                    }
                }
            },
            _updatePagerDataRole: function() {
                var pageNumber = this._getPagerPageNumber();
                var pageIndex = this._getPagerPageIndex();
                var pagerCount = this._getPagerPagerCount();
                this.clearSelect();
                this.eachData(function(data, index) {
                    var role = $PagerUtil.getPagerDataInfo(data, index, pageNumber, pageIndex, pagerCount);
                    data.set("role", role);
                    if (role === pageIndex) {
                        this.setSelect(data);
                    }
                }, this);
                this.update();
            },
            getDataRendererClass: function(data) {
                return $PagerULRenderer;
            }
        });
        var $PagerULRenderer = function() {
            $PagerULRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($PagerULRenderer, $IDataULRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $PagerULRenderer.superClass.updateRenderConfig.apply(this, arguments);
                this._renderConfig["role"] = data.getProperty("role");
            },
            updateRenderer: function(view, data, renderConfig) {
                $PagerULRenderer.superClass.updateRenderer.apply(this, arguments);
                $domToggleClass(this._renderer, "to_prev", this.getRenderConfig("role") === "to_prev");
                $domToggleClass(this._renderer, "to_next", this.getRenderConfig("role") === "to_next");
                $domToggleClass(this._renderer, "to_prev_more", this.getRenderConfig("role") === "to_prev_more");
                $domToggleClass(this._renderer, "to_next_more", this.getRenderConfig("role") === "to_next_more");
            }
        });
        var $PaginationController = function() {
            $PaginationController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($PaginationController, $IViewController, {
            add: function(view) {
                $PaginationController.superClass.add.apply(this, arguments);
                $domOn(view._gerRefreshWrapper(), "click", this.handleRefresh, this);
                $domOn(view._gerSizeSelect(), "change", this.handleSizeChange, this);
            },
            remove: function(view) {
                $domOff(this._view._gerRefreshWrapper(), "click", this.handleRefresh, this);
                $domOff(this._view._gerSizeSelect(), "change", this.handleSizeChange, this);
                $PaginationController.superClass.remove.apply(this, arguments);
            },
            handleRefresh: function() {
                this._view._onRefresh(this._view.getPageConfig());
            },
            handleSizeChange: function() {
                var value = this._view._gerSizeSelect().value | 0;
                this._view.set("page_size", value);
            }
        });
        var $Pagination = function() {
            if (!(this instanceof $Pagination)) {
                return $ClassUtil.createInstance($Pagination, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-pagination", arg0);
            }
            $Pagination.superClass.constructor.apply(this, arguments);
            this._initPageView();
            $WViewUtil.addWidgetClass(this.getRoot());
            $domAddClass(this.getRoot(), "z-pagination");
            this.addController(new $PaginationController());
        };
        $extendClass($Pagination, $IView, {
            __className_: "Pagination",
            ___zdefaults_: {
                layout: $getDefault("WIDGET_PAGINATION_LAYOUT"),
                page_sizes: $getDefault("WIDGET_PAGINATION_PAGE_SIZES"),
                page_size: $getDefault("WIDGET_PAGINATION_PAGE_SIZE"),
                total_template: $getDefault("WIDGET_PAGINATION_TOTAL_TEMPLATE"),
                refresh_icon_template: $IconTemplate.refresh,
                page_index: 1,
                total: 0,
                pager_count: $getDefault("WIDGET_PAGINATION_PAGER_COUNT"),
                to_prev_icon_template: $IconTemplate.pagination_to_prev,
                to_next_icon_template: $IconTemplate.pagination_to_next,
                to_prev_more_icon_template: $IconTemplate.pagination_to_prev_more,
                to_next_more_icon_template: $IconTemplate.pagination_to_next_more
            },
            _initPageView: function() {
                this._pagerULView = new $PagerULView(this);
                var pagerRoot = this._pagerULView.getRoot();
                $domAddClass(pagerRoot, "pager");
                this.getRoot().appendChild(pagerRoot);
                this._updatePageSizeSelect();
                this._handlePageChange();
                this._doViewLayoutUpdate();
            },
            _onViewChange: function(key, value, old) {
                $Pagination.superClass._onViewChange.apply(this, arguments);
                switch (key) {
                    case "page_index":
                        this._doViewPageIndexUpdate();
                        break;

                    case "page_size":
                        this._doViewPageSizeUpdate();
                        break;

                    case "total":
                        this._doViewTotalUpdate();
                        break;

                    case "page_sizes":
                        this._doViewPageSizesUpdate();
                        break;

                    case "pager_count":
                        this._doViewPagerCountUpdate();
                        break;

                    case "layout":
                        this._doViewLayoutUpdate();
                        break;

                    case "total_template":
                        this._updateTotalInfo();
                        break;

                    case "to_prev_icon_template":
                        this._updatePagerULView();
                        break;

                    case "to_next_icon_template":
                        this._updatePagerULView();
                        break;

                    case "to_prev_more_icon_template":
                        this._updatePagerULView();
                        break;

                    case "to_next_more_icon_template":
                        this._updatePagerULView();
                        break;

                    case "refresh_icon_template":
                        this._doViewRefreshIconUpdate();
                        break;
                }
            },
            _doViewPageIndexUpdate: function() {
                this._handlePageChange();
            },
            _doViewPageSizeUpdate: function() {
                this._updatePageSizeSelect(true);
                this._updatePageIndex();
                this._handlePageChange();
            },
            _doViewTotalUpdate: function() {
                this._updatePageIndex();
                this._handlePageChange();
            },
            _doViewPageSizesUpdate: function() {
                this._updatePageSizeSelect();
                var pageSizes = this.getProperty("page_sizes");
                var pageSize = this._getPageSize();
                if (pageSizes.indexOf(pageSize) < 0) {
                    this.set("page_size", pageSizes[0]);
                }
            },
            _updatePageSizeSelect: function(onlySizeChange) {
                var pageSizes = this.getProperty("page_sizes");
                var sizeSelect = this._gerSizeSelect();
                if (onlySizeChange === true) {
                    sizeSelect.value = this._getPageSize();
                } else {
                    if (pageSizes.length > 1) {
                        $domEmpty(sizeSelect);
                        pageSizes.forEach(function(size) {
                            var op = $domCreate("option");
                            op.setAttribute("value", size);
                            op.innerHTML = size;
                            sizeSelect.appendChild(op);
                        });
                        sizeSelect.value = this._getPageSize();
                    } else {
                        $domRemove(sizeSelect);
                    }
                }
            },
            _doViewPagerCountUpdate: function() {
                this._updatePagerULView();
            },
            _doViewLayoutUpdate: function() {
                var root = this.getRoot();
                $domEmpty(root);
                this.getProperty("layout").split(",").forEach(function(item) {
                    var ele;
                    switch (item) {
                        case "sizes":
                            ele = this._gerSizeSelect();
                            break;

                        case "pager":
                            if (this._pagerULView) {
                                ele = this._pagerULView.getRoot();
                            }
                            break;

                        case "total":
                            ele = this._gerTotalWrapper();
                            break;

                        case "refresh":
                            ele = this._gerRefreshWrapper();
                            break;
                    }
                    if (ele) {
                        root.appendChild(ele);
                    }
                }, this);
            },
            _gerSizeSelect: function() {
                if (!this._sizeSelect) {
                    this._sizeSelect = $domCreate("select", "sizes");
                    this._sizeSelect.setAttribute("__z_dop_", "size_select");
                }
                return this._sizeSelect;
            },
            _gerTotalWrapper: function() {
                if (!this._totalWrapper) {
                    this._totalWrapper = $domCreate("span", "total");
                }
                return this._totalWrapper;
            },
            _gerRefreshWrapper: function() {
                if (!this._refreshWrapper) {
                    this._refreshWrapper = $domCreate("span", "refresh");
                    this._refreshWrapper.setAttribute("__z_dop_", "refresh");
                    this._refreshWrapper.innerHTML = this.getProperty("refresh_icon_template");
                }
                return this._refreshWrapper;
            },
            _updatePagerULView: function() {
                if (!this._pagerULView) {
                    return;
                }
                this._pagerULView.update();
            },
            _updateTotalInfo: function() {
                this._gerTotalWrapper().innerHTML = $renderTemplate(this.getProperty("total_template"), this.getPageConfig());
            },
            _doViewRefreshIconUpdate: function() {
                this._gerRefreshWrapper().innerHTML = this.getProperty("refresh_icon_template");
            },
            _updatePageIndex: function() {
                var pageNumber = $MathMax(1, this._getPageNumber());
                var pageIndex = this._getPageIndex();
                if (pageIndex > pageNumber) {
                    pageIndex = $MathMax(1, pageNumber - 1);
                    this.set("page_index", pageIndex);
                    return true;
                }
                return false;
            },
            _handlePageChange: function() {
                if (!this._pagerULView) {
                    return;
                }
                this._pagerULView.updatePagerData();
                this._callBatch(this._onPageChange, "page_change_cb_");
            },
            _onPageChange: function() {
                var config = this.getPageConfig();
                this._updateTotalInfo();
                if (this._currentPagerConfig) {
                    if (this._currentPagerConfig.index === config.index && this._currentPagerConfig.size === config.size) {
                        return;
                    }
                    config.changed = true;
                }
                this._currentPagerConfig = $mergeObject({}, config);
                this._callOn("onPageChange", "on.page.change", config, [ config ]);
            },
            _getPageNumber: function() {
                return $MathCeil(this._getTotal() / this._getPageSize());
            },
            _getPageSize: function() {
                return this.getProperty("page_size");
            },
            _getTotal: function() {
                return this.getProperty("total");
            },
            _getPagerCount: function() {
                return this.getProperty("pager_count");
            },
            _getPageIndex: function() {
                return this.getProperty("page_index");
            },
            getPageConfig: function() {
                var pageIndex = this._getPageIndex();
                var _pageIndex = pageIndex - 1;
                var pageSize = this._getPageSize();
                var skip = _pageIndex * pageSize;
                var total = this._getTotal();
                var start = 0, end = 0;
                if (total > 0) {
                    start = _pageIndex * pageSize + 1;
                    end = $MathMin(total, (_pageIndex + 1) * pageSize);
                }
                return {
                    index: pageIndex,
                    size: pageSize,
                    skip: skip,
                    limit: pageSize,
                    offset: skip,
                    number: this._getPageNumber(),
                    start: start,
                    end: end,
                    total: total
                };
            },
            onPageChange: function(listener, context) {
                this.addListener("on.page.change", listener, context);
            },
            _onRefresh: function(config) {
                this._callOn("onRefresh", "on.page.refresh", config, [ config ]);
            },
            onRefresh: function(listener, context) {
                this.addListener("on.page.refresh", listener, context);
            }
        });
        var $GridHeadShareProperties = {
            sortable: function(grid, headView) {
                var sortable = grid.getProperty("sortable");
                headView.set("sortable", sortable === true || sortable === "custom");
            },
            sort_mode: "sort_mode",
            multiple_sort_modifier_key: "multiple_sort_modifier_key",
            sort_orders: "sort_orders",
            sort_asc_icon_template: "sort_asc_icon_template",
            sort_desc_icon_template: "sort_desc_icon_template",
            minimize_icon_template: "minimize_icon_template",
            minimize_width: "minimize_width",
            minimize_label: "minimize_label"
        };
        var $GridBodyShareProperties = {
            selectable: "selectable",
            auto_select: "auto_select",
            row_template: "row_template",
            expand_icon_visible: "expand_icon_visible",
            expand_collapsed_icon_template: "expand_collapsed_icon_template",
            expand_expanded_icon_template: "expand_expanded_icon_template",
            expand_on_click: "expand_on_click",
            expand_on_dbl_click: "expand_on_dbl_click",
            accordion: "accordion",
            checkbox_unchecked_icon_template: "checkbox_unchecked_icon_template",
            checkbox_checked_icon_template: "checkbox_checked_icon_template",
            checkbox_indeterminate_icon_template: "checkbox_indeterminate_icon_template",
            check_on_click: "check_on_click",
            three_states_check: "three_states_check",
            root_data: "root_data"
        };
        var $GridViewUtil = {
            getOffsetHeight: function(ele) {
                return $DomGeom.getElementWindowBounds(ele).height;
            },
            createFixedHeadView: function(grid) {
                var headView = $GridViewUtil._createHeadView(grid, function(column) {
                    if (column.getProperty("visible") === false) {
                        return false;
                    }
                    var rootColumn = $DataLevelUtil.getDataRoot(column);
                    var fixed = rootColumn.getProperty("fixed");
                    return fixed === true || fixed === "left";
                });
                $GridViewUtil.initHeadViewShareProperty(grid, headView);
                return headView;
            },
            createFixedRightHeadView: function(grid) {
                var headView = $GridViewUtil._createHeadView(grid, function(column) {
                    if (column.getProperty("visible") === false) {
                        return false;
                    }
                    var rootColumn = $DataLevelUtil.getDataRoot(column);
                    return rootColumn.getProperty("fixed") === "right";
                });
                $GridViewUtil.initHeadViewShareProperty(grid, headView);
                return headView;
            },
            createCenterHeadView: function(grid) {
                return $GridViewUtil._createHeadView(grid, function(column) {
                    if (column.getProperty("visible") === false) {
                        return false;
                    }
                    var rootColumn = $DataLevelUtil.getDataRoot(column);
                    var fixed = rootColumn.getProperty("fixed");
                    return fixed !== true && fixed !== "left" && fixed !== "right";
                });
            },
            _createHeadView: function(grid, isVisible) {
                var headView = new $TableHeadView({
                    isVisible: isVisible,
                    _hasChildrenChecked: function(data) {
                        if (this.isCheckColumn(data)) {
                            return $GridViewSyncUtil._hasDataChecked(grid);
                        } else {
                            return $TableHeadView.prototype._hasChildrenChecked.apply(this, arguments);
                        }
                    }
                });
                headView.onViewUpdate(grid._onColumnUpdate, grid);
                return headView;
            },
            initHeadViewShareProperty: function(grid, headView) {
                $eachObject($GridHeadShareProperties, function(gridProp, headProp) {
                    if ($isFunction(headProp)) {
                        headProp(grid, headView);
                    } else {
                        headView.set(headProp, grid.getProperty(gridProp));
                    }
                }, grid);
            },
            createBodyView: function(grid, headView, initBodyShareProperty) {
                var bodyView = new $TableBodyView($GridViewUtil.getBodyOverridingMethods(grid));
                $GridViewUtil._onBodyViewChange(grid, bodyView);
                if (initBodyShareProperty !== false) {
                    $GridViewUtil.initBodyViewShareProperty(grid, bodyView);
                }
                bodyView.setTableHead(headView);
                return bodyView;
            },
            getBodyOverridingMethods: function(grid) {
                return {
                    isHover: function(data) {
                        return grid.isHover(data);
                    },
                    _getCellValue: function(data, column) {
                        return grid._getCellValue(data, column);
                    },
                    _isFilterVisible: function(data) {
                        return grid._isFilterVisible(data);
                    },
                    isVisible: function(data) {
                        return grid.isVisible(data);
                    },
                    isCheckColumn: function(column) {
                        return grid._isCheckColumn(column);
                    },
                    hasCheckColumn: function() {
                        return grid._hasCheckColumn();
                    },
                    isCheckable: function(data) {
                        return grid.isCheckable(data);
                    },
                    isSelectable: function(data) {
                        return grid.isSelectable(data);
                    }
                };
            },
            _onBodyViewChange: function(grid, bodyView) {
                bodyView.onDataClick(function(evt) {
                    grid._onDataClick.apply(grid, [ evt.data, evt.event ]);
                });
                bodyView.onDataDblClick(function(evt) {
                    grid._onDataDblClick.apply(grid, [ evt.data, evt.event ]);
                });
                bodyView.onViewUpdate(function() {
                    grid._onBodyUpdate();
                });
            },
            initBodyViewShareProperty: function(grid, bodyView) {
                $eachObject($GridBodyShareProperties, function(gridProp, bodyProp) {
                    if ($isFunction(bodyProp)) {
                        bodyProp(grid, bodyView);
                    } else {
                        bodyView.set(bodyProp, grid.getProperty(gridProp));
                    }
                }, grid);
            }
        };
        var $GridViewSyncUtil = {
            bubblingBodyEventToGrid: function(grid) {
                var bodyCenterTable = grid._bodyCenterTable;
                bodyCenterTable.onCheckChange(function(evt) {
                    grid._onCheckChange(evt);
                }, grid);
                bodyCenterTable.onSelectChange(function(evt) {
                    grid._onSelectChange(evt);
                });
                bodyCenterTable.onSelectBatchChange(function(selected) {
                    grid._onSelectBatchChange(selected);
                });
            },
            syncHeadViewProperty: function(grid, key, value, old) {
                if ($GridHeadShareProperties.hasOwnProperty(key)) {
                    var headKey = $GridHeadShareProperties[key];
                    if ($isFunction(headKey)) {
                        if (grid._headCenterTable) {
                            headKey(grid, grid._headCenterTable);
                        }
                        if (grid._headLeftTable) {
                            headKey(grid, grid._headLeftTable);
                        }
                        if (grid._headRightTable) {
                            headKey(grid, grid._headRightTable);
                        }
                    } else {
                        if (grid._headCenterTable) {
                            grid._headCenterTable.set(headKey, value);
                        }
                        if (grid._headLeftTable) {
                            grid._headLeftTable.set(headKey, value);
                        }
                        if (grid._headRightTable) {
                            grid._headRightTable.set(headKey, value);
                        }
                    }
                }
            },
            syncBodyViewProperty: function(grid, key, value, old) {
                if ($GridBodyShareProperties.hasOwnProperty(key)) {
                    var bodyKey = $GridBodyShareProperties[key];
                    if ($isFunction(bodyKey)) {
                        if (grid._bodyCenterTable) {
                            bodyKey(grid, grid._bodyCenterTable);
                        }
                        if (grid._bodyLeftTable) {
                            bodyKey(grid, grid._bodyLeftTable);
                        }
                        if (grid._bodyRightTable) {
                            bodyKey(grid, grid._bodyRightTable);
                        }
                    } else {
                        if (grid._bodyCenterTable) {
                            grid._bodyCenterTable.set(bodyKey, value);
                        }
                        if (grid._bodyLeftTable) {
                            grid._bodyLeftTable.set(bodyKey, value);
                        }
                        if (grid._bodyRightTable) {
                            grid._bodyRightTable.set(bodyKey, value);
                        }
                    }
                }
            },
            syncBodyHeadCheck: function(grid) {
                grid._headCenterTable.onCheckChange(function(evt) {
                    $GridViewSyncUtil._syncBodyCheckFromHead(grid);
                });
                grid._bodyCenterTable.onCheckChange(function(evt) {
                    grid._callBatch(function() {
                        $GridViewSyncUtil._syncHeadCheckFromBody(grid);
                    }, "sync_head_check_from_body__cb_");
                });
                grid._bodyCenterTable.onModelChange(function(evt) {
                    var type = evt.type;
                    if (type === "set_provider" || type === "provider") {
                        grid._callBatch(function() {
                            $GridViewSyncUtil._syncHeadCheckFromBody(grid);
                        }, "sync_head_check_from_body__cb_");
                    }
                });
            },
            _syncHeadCheckFromBody: function(grid) {
                if (grid._$is_sync_body_head_check_columning === true) {
                    return;
                }
                grid._$is_sync_body_head_check_columning = true;
                var columnProvider = grid._columnProvider;
                if (columnProvider) {
                    var checkColumn = columnProvider._checkColumn;
                    if (checkColumn) {
                        var allChecked = $GridViewSyncUtil._isAllDataChecked(grid);
                        var checkTable = $GridViewSyncUtil._getCheckColumnTable(grid);
                        var columnChecked = checkTable.isChecked(checkColumn);
                        var needUpdate = true;
                        if (allChecked) {
                            if (!columnChecked) {
                                checkTable.addCheck(checkColumn);
                                needUpdate = false;
                            }
                        } else {
                            if (columnChecked) {
                                checkTable.removeCheck(checkColumn);
                                needUpdate = false;
                            }
                        }
                        if (needUpdate) {
                            checkTable._updateData(checkColumn);
                        }
                    }
                }
                delete grid._$is_sync_body_head_check_columning;
            },
            _syncBodyCheckFromHead: function(grid) {
                if (grid._$is_sync_body_head_check_columning === true) {
                    return;
                }
                grid._$is_sync_body_head_check_columning = true;
                var columnProvider = grid._columnProvider;
                if (columnProvider) {
                    var checkColumn = columnProvider._checkColumn;
                    if (checkColumn) {
                        var checkTable = grid._headCenterTable;
                        if (checkTable.isChecked(checkColumn)) {
                            grid._bodyCenterTable.checkAll();
                            var allChecked = $GridViewSyncUtil._isAllDataChecked(grid);
                            if (!allChecked) {
                                checkTable.removeCheck(checkColumn);
                            }
                        } else {
                            grid._bodyCenterTable.clearCheck();
                        }
                    }
                }
                delete grid._$is_sync_body_head_check_columning;
            },
            _isAllDataChecked: function(grid) {
                var count = grid._bodyCenterTable.getDataArray(false).length;
                return count > 0 && grid._bodyCenterTable.getChecked(false).length === count;
            },
            _hasDataChecked: function(grid) {
                return grid._bodyCenterTable.getChecked(false).length > 0;
            },
            _getCheckColumnTable: function(grid) {
                var columnProvider = grid._columnProvider;
                if (columnProvider) {
                    var checkColumn = columnProvider._checkColumn;
                    if (checkColumn) {
                        var checkTable;
                        if (grid._hasColumnFixed) {
                            if (grid._headLeftTable.isVisible(checkColumn)) {
                                checkTable = grid._headLeftTable;
                            }
                        }
                        if (!checkTable) {
                            if (grid._hasColumnFixedRight) {
                                if (grid._headRightTable.isVisible(checkColumn)) {
                                    checkTable = grid._headRightTable;
                                }
                            }
                        }
                        if (!checkTable) {
                            checkTable = grid._headCenterTable;
                        }
                        return checkTable;
                    }
                }
            },
            syncColGroupUpdate: function(headTable, bodyTable) {
                headTable.setCallBack("onColGroupChange", function(colGroup) {
                    $callRAFLater(function() {
                        bodyTable._tableColGroup.innerHTML = colGroup.innerHTML;
                    });
                });
            }
        };
        var $GridColumnUtil = {
            getColumnFixedConfig: function(columnProvider) {
                var hasColumnFixed = false;
                var hasColumnFixedRight = false;
                columnProvider.toRootArray(false).forEach(function(rootColumn) {
                    var fixed = rootColumn.getProperty("fixed");
                    if (fixed === true || fixed === "left") {
                        hasColumnFixed = true;
                    } else if (fixed === "right") {
                        hasColumnFixedRight = true;
                    }
                });
                return {
                    fixed: hasColumnFixed,
                    fixed_right: hasColumnFixedRight
                };
            }
        };
        var $GridController = function() {
            $GridController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($GridController, $IViewController, {
            add: function(view) {
                $GridController.superClass.add.apply(this, arguments);
                $domOn(view._vScrollbarDiv, "scroll", this.handleVScroll, this);
                $domOn(view._hScrollbarDiv, "scroll", this.handleHScroll, this);
                $domOn(view._bodyCenterDiv, "touchstart", this.handleTouchStart, this);
                $domOn(view._bodyCenterDiv, "touchmove", this.handleTouchMove, this);
                $domOn(view._bodyCenterDiv, "touchend", this.handleTouchEnd, this);
            },
            remove: function() {
                var view = this._view;
                $domOff(view._vScrollbarDiv, "scroll", this.handleVScroll, this);
                $domOff(view._hScrollbarDiv, "scroll", this.handleHScroll, this);
                $domOff(view._bodyCenterDiv, "touchstart", this.handleTouchStart, this);
                $domOff(view._bodyCenterDiv, "touchmove", this.handleTouchMove, this);
                $domOff(view._bodyCenterDiv, "touchend", this.handleTouchEnd, this);
                $GridController.superClass.remove.apply(this, arguments);
            },
            getViewDefaultTypes: function() {
                return [ "keydown", "wheel" ];
            },
            handle_keydown: function(evt, view) {
                var keyCode = evt.keyCode;
                var vScrollbarDiv = view._vScrollbarDiv;
                var offset = 20;
                if (vScrollbarDiv.parentNode) {
                    var scrollTop = vScrollbarDiv.scrollTop;
                    if (keyCode === 38) {
                        vScrollbarDiv.scrollTop -= offset;
                    } else if (keyCode === 40) {
                        vScrollbarDiv.scrollTop += offset;
                    } else if (keyCode === 33) {
                        vScrollbarDiv.scrollTop -= view._bodyDiv.clientHeight - 3;
                    } else if (keyCode === 34) {
                        vScrollbarDiv.scrollTop += view._bodyDiv.clientHeight - 3;
                    }
                    if (keyCode === 38 || keyCode === 40 || keyCode === 33 || keyCode === 34) {
                        if (vScrollbarDiv.scrollTop !== scrollTop) {
                            evt.preventDefault();
                        }
                    }
                }
                var hScrollbarDiv = view._hScrollbarDiv;
                if (hScrollbarDiv.parentNode) {
                    var scrollLeft = hScrollbarDiv.scrollLeft;
                    if (keyCode === 37) {
                        hScrollbarDiv.scrollLeft -= offset;
                    } else if (keyCode === 39) {
                        hScrollbarDiv.scrollLeft += offset;
                    }
                    if (keyCode === 37 || keyCode === 39) {
                        if (hScrollbarDiv.scrollLeft !== scrollLeft) {
                            evt.preventDefault();
                        }
                    }
                }
            },
            handle_wheel: function(evt, view) {
                var isDown = evt.wheelDelta < 0 || evt.deltaY > 0 || evt.detail > 0;
                var vScrollbarDiv = view._vScrollbarDiv;
                var hScrollbarDiv = view._hScrollbarDiv;
                var target = evt.target;
                var scroll = "v";
                if (hScrollbarDiv.contains(target)) {
                    scroll = "h";
                }
                if (scroll === "v") {
                    if (!vScrollbarDiv.parentNode) {
                        scroll = null;
                    }
                } else {
                    if (!hScrollbarDiv.parentNode) {
                        scroll = null;
                    }
                }
                if (scroll === "v") {
                    var top = vScrollbarDiv.scrollTop;
                    if (isDown) {
                        vScrollbarDiv.scrollTop += 30;
                    } else {
                        vScrollbarDiv.scrollTop -= 30;
                    }
                    if (vScrollbarDiv.scrollTop !== top) {
                        evt.preventDefault();
                    }
                } else if (scroll === "h") {
                    var left = hScrollbarDiv.scrollLeft;
                    if (isDown) {
                        hScrollbarDiv.scrollLeft += 20;
                    } else {
                        hScrollbarDiv.scrollLeft -= 20;
                    }
                    if (hScrollbarDiv.scrollLeft !== left) {
                        evt.preventDefault();
                        this._view._syncBodyHScroll();
                    }
                }
            },
            handleTouchStart: function(evt) {
                if (this._view._hScrollbarDiv.parentNode || this._view._vScrollbarDiv.parentNode) {
                    this._touchPoint = this._getTouchPoint(evt);
                }
            },
            handleTouchMove: function(evt) {
                if (this._touchPoint) {
                    evt.preventDefault();
                    var point = this._getTouchPoint(evt);
                    var offsetX = point.x - this._touchPoint.x;
                    var offsetY = point.y - this._touchPoint.y;
                    if ($MathAbs(offsetX) > $MathAbs(offsetY)) {
                        if (this._view._hScrollbarDiv.parentNode) {
                            this._view._hScrollbarDiv.scrollLeft -= offsetX;
                        }
                    } else {
                        if (this._view._vScrollbarDiv.parentNode) {
                            this._view._vScrollbarDiv.scrollTop -= offsetY;
                        }
                    }
                    this._touchPoint = point;
                }
            },
            handleTouchEnd: function(evt) {
                this._touchPoint = null;
            },
            _getTouchPoint: function(evt) {
                var touches = evt.touches;
                var touch1 = touches[0];
                return {
                    x: touch1.clientX,
                    y: touch1.clientY
                };
            },
            handleVScroll: function() {
                this._view._syncBodyVScroll();
            },
            handleHScroll: function() {
                this._view._syncBodyHScroll();
            }
        });
        var $Grid = function() {
            if (!(this instanceof $Grid)) {
                return $ClassUtil.createInstance($Grid, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-grid", arg0);
            }
            this._initGridView();
            var columns = $getSingleObjectArg(arguments, "columns");
            $Grid.superClass.constructor.apply(this, arguments);
            this._initCenterTables();
            this._initDefaultColumns();
            var rootDiv = this.getRoot();
            $WViewUtil.addWidgetClass(rootDiv);
            $domAddClass(rootDiv, "z-grid");
            rootDiv.appendChild(this._headDiv);
            rootDiv.appendChild(this._bodyDiv);
            rootDiv.appendChild(this._pagerDiv);
            this._doViewOverflowUpdate();
            this._updateLayout();
            this.addController(new $GridController());
            this.addController(new $HoverController());
            if (columns) {
                this.setColumns(columns);
            }
        };
        $extendClass($Grid, $IDataView, $mergeObject({
            __className_: "Grid",
            ___zdefaults_: $mergeObject({
                onresize: true,
                overflow: "hidden",
                pageable: false,
                hoverable: false,
                selectable: false,
                make_visible_on_select: true
            }, $CheckInterfaceDefault(), $SortDefault(), $ColumnMinimizeDefault()),
            _onViewChange: function(key, value, old) {
                $Grid.superClass._onViewChange.apply(this, arguments);
                if (key === "pageable") {
                    this._doViewPagerUpdate(key, value, old);
                    return;
                } else if (key === "overflow") {
                    this._doViewOverflowUpdate();
                } else if (key === "sortable") {
                    this._sortBodyData();
                }
                $GridViewSyncUtil.syncHeadViewProperty(this, key, value, old);
                $GridViewSyncUtil.syncBodyViewProperty(this, key, value, old);
                this.update();
            },
            _doViewOverflowUpdate: function() {
                $domToggleClass(this.getRoot(), "overflow-scroll", this.getProperty("overflow") === "scroll");
            },
            makeVisible: function(data) {
                if (data) {
                    var renderEle = this._bodyCenterTable.getDataRendererElement(data);
                    if (renderEle) {
                        $callRAFLater(function() {
                            $DomUtil.scrollIntoView(renderEle, this._getScrollView());
                            this._syncVScrollByBody();
                        }, this);
                    }
                }
            },
            _getScrollView: function() {
                return this._bodyDiv;
            }
        }, {
            _initGridView: function() {
                this._headDiv = $domCreate("div", "head");
                this._headLeftDiv = $domCreate("div", "left");
                this._headCenterDiv = $domCreate("div", "center");
                this._headRightDiv = $domCreate("div", "right");
                this._headDiv.appendChild(this._headCenterDiv);
                this._headDiv.appendChild(this._headLeftDiv);
                this._headDiv.appendChild(this._headRightDiv);
                this._bodyDiv = $domCreate("div", "body");
                this._bodyLeftDiv = $domCreate("div", "left");
                this._bodyCenterDiv = $domCreate("div", "center");
                this._bodyRightDiv = $domCreate("div", "right");
                this._bodyDiv.appendChild(this._bodyCenterDiv);
                this._bodyDiv.appendChild(this._bodyLeftDiv);
                this._bodyDiv.appendChild(this._bodyRightDiv);
                this._pagerDiv = $domCreate("div", "pager");
                this._vScrollbarHeightDiv = $domCreate("div");
                this._vScrollbarDiv = $domCreate("div", "v-scrollbar");
                this._vScrollbarDiv.appendChild(this._vScrollbarHeightDiv);
                this._hScrollbarHeightDiv = $domCreate("div", "scroll");
                this._hScrollbarDiv = $domCreate("div", "h-scrollbar");
                this._hScrollbarDiv.appendChild(this._hScrollbarHeightDiv);
                this._headCenterTable = $GridViewUtil.createCenterHeadView(this);
                this._headCenterTableRoot = this._headCenterTable.getRoot();
                this._headCenterDiv.appendChild(this._headCenterTableRoot);
                this._bodyCenterTable = this._createBodyView(this._headCenterTable, false);
                this._bodyCenterTableRoot = this._bodyCenterTable.getRoot();
                this._bodyCenterDiv.appendChild(this._bodyCenterTableRoot);
                $GridViewSyncUtil.syncBodyHeadCheck(this);
            },
            _initCenterTables: function() {
                $GridViewUtil.initHeadViewShareProperty(this, this._headCenterTable);
                $GridViewUtil.initBodyViewShareProperty(this, this._bodyCenterTable);
                $GridViewSyncUtil.syncColGroupUpdate(this._headCenterTable, this._bodyCenterTable);
                $GridViewSyncUtil.bubblingBodyEventToGrid(this);
            }
        }, {
            _onProviderChange: function() {
                $Grid.superClass._onProviderChange.apply(this, arguments);
                this._bodyCenterTable.setProvider(this.getProvider());
                if (this._hasColumnFixed) {
                    this._bodyLeftTable.setProvider(this.getProvider());
                }
                if (this._hasColumnFixedRight) {
                    this._bodyRightTable.setProvider(this.getProvider());
                }
            },
            _updateBodyData: function(data) {
                if (data) {
                    if (this._bodyCenterTable) {
                        this._bodyCenterTable._updateData(data);
                    }
                    if (this._bodyLeftTable) {
                        this._bodyLeftTable._updateData(data);
                    }
                    if (this._bodyRightTable) {
                        this._bodyRightTable._updateData(data);
                    }
                }
            },
            _updateBodyAllData: function() {
                if (this._bodyCenterTable) {
                    this._bodyCenterTable._updateAllData();
                }
                if (this._bodyLeftTable) {
                    this._bodyLeftTable._updateAllData();
                }
                if (this._bodyRightTable) {
                    this._bodyRightTable._updateAllData();
                }
            },
            _updateHeadColumn: function(columnData) {
                if (columnData) {
                    if (this._headCenterTable) {
                        this._headCenterTable._updateData(columnData);
                    }
                    if (this._headLeftTable) {
                        this._headLeftTable._updateData(columnData);
                    }
                    if (this._headRightTable) {
                        this._headRightTable._updateData(columnData);
                    }
                }
            },
            update: function(batch, onlyBody) {
                if (onlyBody === true) {
                    this._updateBody(batch);
                    return;
                }
                $Grid.superClass.update.apply(this, arguments);
                this._updateBody(batch);
                if (this._headCenterTable) {
                    this._headCenterTable.update(batch);
                }
                if (this._headLeftTable) {
                    this._headLeftTable.update(batch);
                }
                if (this._headRightTable) {
                    this._headRightTable.update(batch);
                }
            },
            _updateBody: function(batch) {
                if (this._bodyCenterTable) {
                    this._bodyCenterTable.update(batch);
                }
                if (this._bodyLeftTable) {
                    this._bodyLeftTable.update(batch);
                }
                if (this._bodyRightTable) {
                    this._bodyRightTable.update(batch);
                }
            }
        }, {
            _initDefaultColumns: function() {
                this._columnProvider = new $Provider();
                this._headCenterTable.setProvider(this._columnProvider);
                this._addColumnProviderListener();
            },
            setColumns: function(columns, dataBind) {
                if (!$isArray(columns)) {
                    columns = [ columns ];
                }
                var columnArray = $JSONDataParser.parse(columns);
                if (dataBind === true) {
                    columnArray.forEach(function(cd) {
                        cd._bind(cd.get("_$z_data"));
                    });
                }
                var provider = new $Provider();
                provider.add(columnArray);
                $ColumnSortUtil.updateColumnSortIndex(provider);
                this._setColumnProvider(provider);
            },
            findColumn: function(prop, value) {
                return this._columnProvider.find.apply(this._columnProvider, arguments);
            },
            getColumnArray: function(copy) {
                return this._columnProvider.toArray.apply(this._columnProvider, arguments);
            },
            _beforeSetColumnProvider: function(columnProvider) {
                columnProvider._checkColumn = columnProvider.find(function(column) {
                    return column.getProperty("type") === "check" && !column.hasChildren() && !column.getProperty("parent");
                });
            },
            _setColumnProvider: function(columnProvider) {
                this._beforeSetColumnProvider(columnProvider);
                this._removeColumnProviderListener();
                this._columnProvider = columnProvider;
                this._updateFixedColumns();
                this._headCenterTable.setProvider(columnProvider);
                if (this._hasColumnFixed) {
                    this._headLeftTable.setProvider(columnProvider);
                }
                if (this._hasColumnFixedRight) {
                    this._headRightTable.setProvider(columnProvider);
                }
                this._addColumnProviderListener();
                this._onColumnChange("set_provider");
                this._sortBodyData();
            },
            _isCheckColumn: function(column) {
                if (column) {
                    return this._columnProvider._checkColumn === column;
                }
                return false;
            },
            _hasCheckColumn: function() {
                return this._columnProvider._checkColumn != null;
            },
            _addColumnProviderListener: function() {
                this._columnProvider.addProviderChangeListener(this._handleColumnProviderChange, this);
                this._columnProvider.addDataChangeListener(this._handleColumnChange, this);
                this._columnProvider.removeIndexChangeListener(this._handleColumnIndexChange, this);
            },
            _removeColumnProviderListener: function() {
                if (this._columnProvider) {
                    this._columnProvider.removeProviderChangeListener(this._handleColumnProviderChange, this);
                    this._columnProvider.removeDataChangeListener(this._handleColumnChange, this);
                    this._columnProvider.removeIndexChangeListener(this._handleColumnIndexChange, this);
                }
            },
            _handleColumnProviderChange: function(evt) {
                this._updateFixedColumns();
                $ColumnSortUtil.updateColumnSortIndex(this._columnProvider);
                this._onColumnChange("provider", evt);
            },
            _handleColumnChange: function(evt) {
                var property = evt.property;
                if (property === "fixed") {
                    this._updateFixedColumns();
                } else if (property === "sort") {
                    this._onSortChange();
                }
                this._onColumnChange("data", evt);
            },
            _handleColumnIndexChange: function(evt) {
                this._onModelChange("index", evt);
            },
            _onColumnChange: function(type, evt) {
                this._callOn("onColumnChange", "on.column.change", {
                    type: type,
                    event: evt
                }, [ type, evt ]);
            },
            onColumnChange: function(listener, context) {
                this.addListener("on.column.change", listener, context);
            },
            _updateFixedColumns: function() {
                var columnProvider = this._columnProvider;
                var fixedConfig = $GridColumnUtil.getColumnFixedConfig(columnProvider);
                if (this._hasColumnFixed === fixedConfig.fixed && this._hasColumnFixedRight === fixedConfig.fixed_right) {
                    return;
                }
                this._hasColumnFixed = fixedConfig.fixed;
                this._hasColumnFixedRight = fixedConfig.fixed_right;
                if (this._hasColumnFixed) {
                    this._createLeftTables();
                } else {
                    this._removeFixedTable(this._headLeftTable, this._bodyLeftTable);
                }
                if (this._hasColumnFixedRight) {
                    this._createRightTables();
                } else {
                    this._removeFixedTable(this._headRightTable, this._bodyRightTable);
                }
            },
            _createLeftTables: function() {
                if (!this._headLeftTable) {
                    this._headLeftTable = $GridViewUtil.createFixedHeadView(this);
                }
                if (!this._bodyLeftTable) {
                    this._bodyLeftTable = this._createBodyView(this._headLeftTable);
                    $GridViewSyncUtil.syncColGroupUpdate(this._headLeftTable, this._bodyLeftTable);
                }
                var headLeftTableRoot = this._headLeftTable.getRoot();
                if (!headLeftTableRoot.parentNode) {
                    this._headLeftDiv.appendChild(headLeftTableRoot);
                    this._headLeftTable.setProvider(this._columnProvider);
                }
                var bodyLeftTableRoot = this._bodyLeftTable.getRoot();
                if (!bodyLeftTableRoot.parentNode) {
                    this._bodyLeftDiv.appendChild(bodyLeftTableRoot);
                    this._bodyLeftTable.setProvider(this.getProvider());
                }
                this._bodyLeftTable.set("sort_compare", this._getSortCompare());
            },
            _createRightTables: function() {
                if (!this._headRightTable) {
                    this._headRightTable = $GridViewUtil.createFixedRightHeadView(this);
                }
                if (!this._bodyRightTable) {
                    this._bodyRightTable = this._createBodyView(this._headRightTable);
                    $GridViewSyncUtil.syncColGroupUpdate(this._headRightTable, this._bodyRightTable);
                }
                var headRightTableRoot = this._headRightTable.getRoot();
                if (!headRightTableRoot.parentNode) {
                    this._headRightDiv.appendChild(headRightTableRoot);
                    this._headRightTable.setProvider(this._columnProvider);
                }
                var bodyRightTableRoot = this._bodyRightTable.getRoot();
                if (!bodyRightTableRoot.parentNode) {
                    this._bodyRightDiv.appendChild(bodyRightTableRoot);
                    this._bodyRightTable.setProvider(this.getProvider());
                }
                this._bodyRightTable.set("sort_compare", this._getSortCompare());
            },
            _removeFixedTable: function(headTable, bodyTable) {
                if (bodyTable) {
                    $domRemove(bodyTable.getRoot());
                    bodyTable.setProvider(new $Provider());
                }
                if (headTable) {
                    $domRemove(headTable.getRoot());
                    headTable.setProvider(new $Provider());
                }
            },
            _createBodyView: function(headTable, syncProperty) {
                return $GridViewUtil.createBodyView(this, headTable, syncProperty);
            }
        }, {
            _onSortChange: function() {
                this._callBatch(this._onSortBatchChange, "sort_batch_change__cb_");
            },
            _onSortBatchChange: function() {
                var sortConfig = this.getSortConfig();
                this._sortBodyData();
                this._callOn("onSortChange", "on.column.sort.change", sortConfig, [ sortConfig ]);
            },
            _sortBodyData: function() {
                var compare;
                if (this.getProperty("sortable") !== "custom") {
                    compare = this._getSortCompare();
                }
                if (this._hasColumnFixed) {
                    this._bodyLeftTable.set("sort_compare", compare);
                }
                if (this._hasColumnFixedRight) {
                    this._bodyRightTable.set("sort_compare", compare);
                }
                this._bodyCenterTable.set("sort_compare", compare);
            },
            onSortChange: function(listener, context) {
                this.addListener("on.column.sort.change", listener, context);
            },
            clearSort: function() {
                $ColumnSortUtil.clearColumnSort(this._columnProvider);
            },
            getSortConfig: function() {
                var array = $ColumnSortUtil.getSortedColumnArray(this._columnProvider);
                if (array.length > 0) {
                    if (this.getProperty("sort_mode") === "multiple") {
                        var arr = [];
                        array.forEach(function(columnData, index) {
                            arr.push({
                                field: columnData.getProperty("field"),
                                order: $ColumnSortUtil.getSortOrder(columnData.getProperty("sort")),
                                index: index
                            });
                        });
                        return arr;
                    } else {
                        var sortColumn = array[0];
                        var sort = sortColumn.getProperty("sort");
                        return {
                            field: sortColumn.getProperty("field"),
                            order: $ColumnSortUtil.getSortOrder(sortColumn.getProperty("sort"))
                        };
                    }
                }
                return null;
            },
            _getSortCompare: function() {
                if (this._columnProvider) {
                    return $ColumnSortUtil.getSortCompare(this, this._columnProvider);
                }
                return null;
            }
        }, {
            _doViewPagerUpdate: function() {
                var pageable = this.getProperty("pageable");
                if (pageable === true) {
                    this._addPager();
                } else if ($isObject(pageable)) {
                    this._addPager(pageable);
                } else {
                    this._removePager();
                }
            },
            _addPager: function(config) {
                if (!this._pager) {
                    this._pager = new $Pagination();
                    this._pagerDiv.appendChild(this._pager.getRoot());
                    this._pager.setCallBack("onPageChange", this._onPageChange, this);
                    this._pager.setCallBack("onRefresh", this._onPageRefresh, this);
                }
                if (config) {
                    this._pager.set(config);
                }
            },
            _removePager: function() {
                if (this._pager) {
                    this._pager.resetCallBack("onPageChange");
                    this._pager.resetCallBack("onRefresh");
                    $domEmpty(this._pagerDiv);
                    this._pager = null;
                }
            },
            _onPageChange: function(pageConfig) {
                this._callOn("onPageChange", "on.page.change", pageConfig, [ pageConfig ]);
            },
            onPageChange: function(listener, context) {
                this.addListener("on.page.change", listener, context);
            },
            _onPageRefresh: function(pageConfig) {
                this._callOn("onPageRefresh", "on.page.refresh", pageConfig, [ pageConfig ]);
            },
            onPageRefresh: function(listener, context) {
                this.addListener("on.page.refresh", listener, context);
            },
            getPagination: function() {
                return this._pager;
            },
            getPageConfig: function() {
                if (this._pager) {
                    return this._pager.getPageConfig();
                }
            }
        }, {
            _onColumnUpdate: function() {
                this._callBatch(this._doColumnUpdateSync, "_do_column_update_sync_cb_");
            },
            _doColumnUpdateSync: function() {
                this._syncHeadRowHeight();
                this._bodyCenterTable.update();
                if (this._hasColumnFixed) {
                    this._bodyLeftTable.update();
                }
                if (this._hasColumnFixedRight) {
                    this._bodyRightTable.update();
                }
            },
            _onBodyUpdate: function() {
                this._callBatch(this._doBodyUpdateSync, "_do_body_update_sync_cb_");
            },
            _doBodyUpdateSync: function() {
                this._updateLayout();
                this._syncBodyRowHeight();
            },
            _doResizeUpdate: function() {
                $Grid.superClass._doResizeUpdate.apply(this, arguments);
                this._syncHeadRowHeight();
                this._syncBodyRowHeight();
                this._updateLayout();
            },
            _updateLayout: function() {
                var size = this.getRootSize();
                if (size.height <= 0 || size.width <= 0) {
                    return;
                }
                this._updateFixedLayout();
                this._updateFixedRightLayout();
                this._updateScrollbar();
            },
            _updateScrollbar: function() {
                var rootDiv = this.getRoot();
                var size = this.getRootSize();
                var height = size.height;
                var headHeight = $GridViewUtil.getOffsetHeight(this._headDiv);
                var pagerHeight = $GridViewUtil.getOffsetHeight(this._pagerDiv);
                var bodyHeight = $MathFloor(height - headHeight - pagerHeight);
                var bodyWidth = size.width;
                var hScrollWidth = this._headCenterDiv.scrollWidth;
                var isHVisible = hScrollWidth - bodyWidth > 1;
                if (isHVisible) {
                    if (!this._hScrollbarDiv.parentNode) {
                        rootDiv.insertBefore(this._hScrollbarDiv, this._pagerDiv);
                    }
                    bodyHeight -= $GridViewUtil.getOffsetHeight(this._hScrollbarDiv);
                }
                $domSetStyle(this._bodyDiv, "margin-top", headHeight + "px");
                var isVVisible = false;
                if (this.getProperty("overflow") === "scroll") {
                    if ($MathAbs(bodyHeight - $GridViewUtil.getOffsetHeight(this._bodyDiv)) > 1) {
                        $domSetStyle(this._bodyDiv, "height", bodyHeight + "px");
                    }
                    isVVisible = $GridViewUtil.getOffsetHeight(this._bodyCenterDiv) > bodyHeight;
                }
                if (isVVisible) {
                    if (!this._vScrollbarDiv.parentNode) {
                        rootDiv.appendChild(this._vScrollbarDiv);
                    }
                    bodyWidth -= this._vScrollbarDiv.offsetWidth - 1;
                    $domSetStyle(this._vScrollbarDiv, "height", bodyHeight + headHeight + "px");
                    $domSetStyle(this._vScrollbarHeightDiv, "height", this._bodyDiv.scrollHeight + headHeight + "px");
                    $domSetStyle(this._headDiv, "width", bodyWidth + "px");
                    $domSetStyle(this._bodyDiv, "width", bodyWidth + "px");
                    this._syncVScrollByBody();
                } else {
                    $domRemove(this._vScrollbarDiv);
                    $domRemoveStyle(this._headDiv, "width");
                    $domRemoveStyle(this._bodyDiv, "width");
                }
                if (isHVisible) {
                    $domSetStyle(this._hScrollbarDiv, "width", bodyWidth + "px");
                    $domSetStyle(this._hScrollbarHeightDiv, "width", hScrollWidth + "px");
                } else {
                    $domRemove(this._hScrollbarDiv);
                }
            },
            _updateFixedLayout: function() {
                var leftWidth = 0;
                if (this._hasColumnFixed) {
                    leftWidth = this._headLeftTable._getColGroupWidth();
                    var _leftWidth = leftWidth;
                    if (leftWidth > 0) {
                        _leftWidth += 1;
                    }
                    $domSetStyle(this._headLeftDiv, "width", _leftWidth + "px");
                    $domSetStyle(this._bodyLeftDiv, "width", _leftWidth + "px");
                }
                $domSetStyle(this._headCenterTableRoot, "padding-left", leftWidth + "px");
                $domSetStyle(this._bodyCenterTableRoot, "padding-left", leftWidth + "px");
            },
            _updateFixedRightLayout: function() {
                var rightWidth = 0;
                if (this._hasColumnFixedRight) {
                    rightWidth = this._headRightTable._getColGroupWidth();
                    var _rightWidth = rightWidth;
                    if (rightWidth > 0) {
                        _rightWidth += 1;
                    }
                    $domSetStyle(this._headRightDiv, "width", _rightWidth + "px");
                    $domSetStyle(this._bodyRightDiv, "width", _rightWidth + "px");
                }
                $domSetStyle(this._headCenterTableRoot, "padding-right", rightWidth + "px");
                $domSetStyle(this._bodyCenterTableRoot, "padding-right", rightWidth + "px");
            },
            _syncHeadRowHeight: function() {
                var tables = [ this._headCenterTable ];
                if (this._hasColumnFixed) {
                    tables.push(this._headLeftTable);
                }
                if (this._hasColumnFixedRight) {
                    tables.push(this._headRightTable);
                }
                tables.forEach(function(tableView) {
                    var trArray = tableView.getRowTRArray();
                    trArray.forEach(function(tr) {
                        $domRemoveStyle(tr, "height");
                    });
                });
                if (tables.length > 1) {
                    var trHeightArray = [];
                    tables.forEach(function(tableView) {
                        var trArray = tableView.getRowTRArray();
                        trArray.forEach(function(tr, index) {
                            trHeightArray[index] = $MathMax(trHeightArray[index] | 0, tr.offsetHeight + 1);
                        });
                    });
                    tables.forEach(function(tableView) {
                        var trArray = tableView.getRowTRArray();
                        trArray.forEach(function(tr, index) {
                            $domSetStyle(tr, "height", trHeightArray[index] + "px");
                        });
                    });
                }
            },
            _syncBodyRowHeight: function() {
                var tables = [ this._bodyCenterTable ];
                if (this._hasColumnFixed) {
                    tables.push(this._bodyLeftTable);
                }
                if (this._hasColumnFixedRight) {
                    tables.push(this._bodyRightTable);
                }
                var allTRArr = [];
                tables.forEach(function(tableView, index) {
                    var trArray = $domQueryAll("tr[__z_did_]", tableView._tableBody);
                    allTRArr[index] = trArray;
                    trArray.forEach(function(tr) {
                        $domRemoveStyle(tr, "height");
                    });
                });
                if (tables.length > 1) {
                    var trHeightArray = [];
                    allTRArr.forEach(function(trArr) {
                        trArr.forEach(function(tr, index) {
                            trHeightArray[index] = $MathMax(trHeightArray[index] | 0, tr.offsetHeight + 1);
                        });
                    });
                    allTRArr.forEach(function(trArr) {
                        trArr.forEach(function(tr, index) {
                            $domSetStyle(tr, "height", trHeightArray[index] + "px");
                        });
                    });
                }
            }
        }, {
            _syncBodyVScroll: function() {
                this._bodyDiv.scrollTop = this._vScrollbarDiv.scrollTop;
            },
            _syncBodyHScroll: function() {
                this._headCenterDiv.scrollLeft = this._hScrollbarDiv.scrollLeft;
                this._bodyCenterDiv.scrollLeft = this._hScrollbarDiv.scrollLeft;
            },
            _syncVScrollByBody: function() {
                this._vScrollbarDiv.scrollTop = this._bodyDiv.scrollTop;
            }
        }, {
            _getCellValue: function(data, column) {
                return this.getCellValue(data, column);
            },
            getCellValue: function(data, column) {
                return $TableBodyRenderUtil.getCellValue(data, column);
            }
        }, {
            getDataAt: function(evt) {
                var renderer = $DomEventUtil.getEventTarget(evt, "[__z_did_]");
                if (renderer) {
                    var did = renderer.getAttribute("__z_did_");
                    return $findArray(this.getDataArray(false), function(data) {
                        return data.id() === did;
                    });
                }
                return null;
            }
        }, $HoverInterface($Grid), {
            _onHoverChange: function(data, isHover) {
                this._updateBodyData(data);
                this._callOn("onHoverChange", "on.hover.change", {
                    data: data,
                    isHover: isHover
                }, [ data, isHover ]);
            }
        }, {
            check: function(data, isAdd) {
                return this._bodyCenterTable.check.apply(this._bodyCenterTable, arguments);
            },
            uncheck: function(data) {
                return this._bodyCenterTable.uncheck.apply(this._bodyCenterTable, arguments);
            },
            addCheck: function(data) {
                return this._bodyCenterTable.addCheck.apply(this._bodyCenterTable, arguments);
            },
            removeCheck: function(data) {
                return this._bodyCenterTable.removeCheck.apply(this._bodyCenterTable, arguments);
            },
            clearCheck: function() {
                return this._bodyCenterTable.clearCheck.apply(this._bodyCenterTable, arguments);
            },
            setCheck: function(dataArray) {
                return this._bodyCenterTable.setCheck.apply(this._bodyCenterTable, arguments);
            },
            checkAll: function(onlyVisible) {
                return this._bodyCenterTable.checkAll.apply(this._bodyCenterTable, arguments);
            },
            toggleCheck: function(data) {
                return this._bodyCenterTable.toggleCheck.apply(this._bodyCenterTable, arguments);
            },
            getChecked: function(copy) {
                return this._bodyCenterTable.getChecked.apply(this._bodyCenterTable, arguments);
            },
            isChecked: function(data) {
                return this._bodyCenterTable.isChecked.apply(this._bodyCenterTable, arguments);
            },
            isCheckable: function(data) {
                return this.getDataViewProperty(data, "checkable") !== false;
            },
            _onCheckChange: function(evt) {
                this._callOn("onCheckChange", "on.check.change", evt, [ evt ]);
            },
            onCheckChange: function(listener, context) {
                this.addListener("on.check.change", listener, context);
            }
        }, {
            isSelectable: function(data) {
                return this.getDataViewProperty(data, "selectable") === true;
            },
            select: function(data, isAdd) {
                return this._bodyCenterTable.select.apply(this._bodyCenterTable, arguments);
            },
            unselect: function(data) {
                return this._bodyCenterTable.unselect.apply(this._bodyCenterTable, arguments);
            },
            addSelect: function(data) {
                return this._bodyCenterTable.addSelect.apply(this._bodyCenterTable, arguments);
            },
            removeSelect: function(data) {
                return this._bodyCenterTable.removeSelect.apply(this._bodyCenterTable, arguments);
            },
            clearSelect: function() {
                return this._bodyCenterTable.clearSelect.apply(this._bodyCenterTable, arguments);
            },
            setSelect: function(data) {
                return this._bodyCenterTable.setSelect.apply(this._bodyCenterTable, arguments);
            },
            selectAll: function(onlyVisible) {
                return this._bodyCenterTable.selectAll.apply(this._bodyCenterTable, arguments);
            },
            getSelected: function(copy) {
                return this._bodyCenterTable.getSelected.apply(this._bodyCenterTable, arguments);
            },
            getLastSelected: function() {
                return this._bodyCenterTable.getLastSelected.apply(this._bodyCenterTable, arguments);
            },
            isSelected: function(data) {
                return this._bodyCenterTable.isSelected.apply(this._bodyCenterTable, arguments);
            },
            _onSelectChange: function(evt) {
                this._callOn("onSelectChange", "on.select.change", evt, [ evt ]);
            },
            onSelectChange: function(listener, context) {
                this.addListener("on.select.change", listener, context);
            },
            _onSelectBatchChange: function(selected) {
                this._callOn("onSelectBatchChange", "on.select.batch.change", selected, [ selected ]);
                if (selected.length > 0) {
                    if (this.getProperty("make_visible_on_select") === true) {
                        this.makeVisible(this.getLastSelected());
                    }
                }
            },
            onSelectBatchChange: function(listener, context) {
                this.addListener("on.select.batch.change", listener, context);
            }
        }, {}));
        var $TreeGridViewUtil = {
            createBodyView: function(grid, headTable, initBodyShareProperty) {
                var bodyView = new $TreeTableBodyView($mergeObject($GridViewUtil.getBodyOverridingMethods(grid), {
                    isTreeColumn: function(column) {
                        return grid._isTreeColumn(column);
                    },
                    hasChildrenVisible: function(data) {
                        if (grid.hasChildrenVisible) {
                            return grid.hasChildrenVisible(data);
                        }
                        return $TreeTableBodyView.prototype.hasChildrenVisible.apply(this, arguments);
                    }
                }));
                $GridViewUtil._onBodyViewChange(grid, bodyView);
                if (initBodyShareProperty !== false) {
                    $GridViewUtil.initBodyViewShareProperty(grid, bodyView);
                }
                bodyView.setTableHead(headTable);
                return bodyView;
            },
            bubblingBodyEventToGrid: function(grid) {
                var bodyCenterTable = grid._bodyCenterTable;
                bodyCenterTable.onExpand(function(data) {
                    grid._onExpandAdd.apply(grid, arguments);
                });
                bodyCenterTable.onCollapse(function(data) {
                    grid._onExpandRemove.apply(grid, arguments);
                });
                bodyCenterTable.onCollapseAll(function(dataArray) {
                    grid._onExpandClear.apply(grid, arguments);
                });
                bodyCenterTable.onExpandSet(function(dataArray) {
                    grid._onExpandSet.apply(grid, arguments);
                });
                bodyCenterTable.onExpandChange(function(evt) {
                    grid._onExpandChange.apply(grid, arguments);
                });
            },
            syncBodyViewExpand: function(grid, bodyView, evt) {
                if (bodyView._$is_body_expand_syncing === true) {
                    return;
                }
                var type = evt.type;
                if (type === "add") {
                    grid._onExpandAdd(evt.data);
                } else if (type === "remove") {
                    grid._onExpandRemove(evt.data);
                } else if (type === "clear") {
                    grid._onExpandClear(evt.data);
                } else if (type === "set") {
                    grid._onExpandSet(evt.data);
                }
                grid._onExpandChange(evt);
                var bodyTables = [];
                if (grid._bodyCenterTable !== bodyView) {
                    bodyTables.push(grid._bodyCenterTable);
                }
                if (grid._hasColumnFixed) {
                    if (grid._bodyLeftTable !== bodyView) {
                        bodyTables.push(grid._bodyLeftTable);
                    }
                }
                if (grid._hasColumnFixedRight) {
                    if (grid._bodyRightTable !== bodyView) {
                        bodyTables.push(grid._bodyRightTable);
                    }
                }
                if (bodyTables.length > 0) {
                    bodyTables.forEach(function(bodyTable) {
                        bodyTable._$is_body_expand_syncing = true;
                    });
                    var eData = evt.data;
                    if (type === "add") {
                        bodyTables.forEach(function(bodyTable) {
                            bodyTable.expand(eData);
                        });
                    } else if (type === "remove") {
                        bodyTables.forEach(function(bodyTable) {
                            bodyTable.collapse(eData);
                        });
                    } else if (type === "clear") {
                        bodyTables.forEach(function(bodyTable) {
                            bodyTable.collapseAll();
                        });
                    } else if (type === "set") {}
                    bodyTables.forEach(function(bodyTable) {
                        delete bodyTable._$is_body_expand_syncing;
                    });
                }
            }
        };
        var $TreeGrid = function() {
            if (!(this instanceof $TreeGrid)) {
                return $ClassUtil.createInstance($TreeGrid, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-treegrid", arg0);
            }
            $TreeGrid.superClass.constructor.apply(this, arguments);
            $TreeGridViewUtil.bubblingBodyEventToGrid(this);
            $domAddClass(this.getRoot(), "z-treegrid");
        };
        $extendClass($TreeGrid, $Grid, {
            __className_: "TreeGrid",
            ___zdefaults_: $mergeObject($ExpandInterfaceDefault()),
            _createBodyView: function(headTable, syncProperty) {
                return $TreeGridViewUtil.createBodyView(this, headTable, syncProperty);
            },
            _beforeSetColumnProvider: function(columnProvider) {
                $TreeGrid.superClass._beforeSetColumnProvider.apply(this, arguments);
                var treeColumn = columnProvider.find(function(column) {
                    return column.getProperty("tree") === true && !column.hasChildren();
                });
                if (!treeColumn) {
                    treeColumn = columnProvider._checkColumn;
                    if (!treeColumn) {
                        treeColumn = columnProvider.find(function(column) {
                            return !column.hasChildren();
                        });
                    }
                }
                columnProvider._treeColumn = treeColumn;
            },
            _isTreeColumn: function(column) {
                if (column) {
                    return this._columnProvider._treeColumn === column;
                }
                return false;
            },
            makeVisible: function(data) {
                if (data) {
                    var ancestorArray = $DataLevelUtil.getAncestorArray(data);
                    ancestorArray.forEach(function(ancestor) {
                        this.expand(ancestor);
                    }, this);
                    $TreeGrid.superClass.makeVisible.apply(this, arguments);
                }
            },
            getExpanded: function(copy) {
                return this._bodyCenterTable.getExpanded.apply(this._bodyCenterTable, arguments);
            },
            expand: function(data) {
                return this._bodyCenterTable.expand.apply(this._bodyCenterTable, arguments);
            },
            collapse: function(data) {
                return this._bodyCenterTable.collapse.apply(this._bodyCenterTable, arguments);
            },
            expandAll: function(onlyVisible) {
                return this._bodyCenterTable.expandAll.apply(this._bodyCenterTable, arguments);
            },
            collapseAll: function() {
                return this._bodyCenterTable.collapseAll.apply(this._bodyCenterTable, arguments);
            },
            toggleExpand: function(data) {
                return this._bodyCenterTable.toggleExpand.apply(this._bodyCenterTable, arguments);
            },
            isExpanded: function(data) {
                return this._bodyCenterTable.isExpanded.apply(this._bodyCenterTable, arguments);
            },
            _onExpandAdd: function(data) {
                this._callOn("onExpand", "on.expand.add", data, [ data ]);
            },
            onExpand: function(listener, context) {
                this.addListener("on.expand.add", listener, context);
            },
            _onExpandRemove: function(data) {
                this._callOn("onCollapse", "on.expand.remove", data, [ data ]);
            },
            onCollapse: function(listener, context) {
                this.addListener("on.expand.remove", listener, context);
            },
            _onExpandClear: function(dataArray) {
                this._callOn("onCollapseAll", "on.expand.clear", dataArray, [ dataArray ]);
            },
            onCollapseAll: function(listener, context) {
                this.addListener("on.expand.clear", listener, context);
            },
            _onExpandSet: function(dataArray) {
                this._callOn("onExpandSet", "on.expand.set", dataArray, [ dataArray ]);
            },
            onExpandSet: function(listener, context) {
                this.addListener("on.expand.set", listener, context);
            },
            _onExpandChange: function(evt) {
                this._callOn("onExpandChange", "on.expand.change", evt, [ evt ]);
            },
            onExpandChange: function(listener, context) {
                this.addListener("on.expand.change", listener, context);
            }
        });
        var $MenuUtil = {
            ROOT_POP_DIRECTION_MAP: {
                down: "down_right",
                down_right: "down_right",
                down_left: "down_left",
                up: "up_right",
                up_right: "up_right",
                up_left: "up_left",
                right: "right_down",
                right_down: "right_down",
                right_up: "right_up",
                left: "left_down",
                left_down: "left_down",
                left_up: "left_up",
                default: "down_right"
            },
            SUB_POP_DIRECTION_MAP: {
                down: "right_down",
                down_right: "right_down",
                down_left: "left_down",
                up: "right_up",
                up_right: "right_up",
                up_left: "left_up",
                right: "right_down",
                right_down: "right_down",
                right_up: "right_up",
                left: "left_down",
                left_down: "left_down",
                left_up: "left_up",
                default: "right_down"
            },
            getPopDirection: function(menu, data) {
                var direction = menu.getProperty("direction");
                if (direction == null) {
                    if (menu._isVertical()) {
                        direction = "right";
                    } else {
                        direction = "bottom";
                    }
                } else {
                    direction = direction.toLowerCase();
                }
                if ($MenuUtil.isRootMenu(data)) {
                    return $MenuUtil.ROOT_POP_DIRECTION_MAP[direction] || $MenuUtil.ROOT_POP_DIRECTION_MAP["default"];
                }
                return $MenuUtil.SUB_POP_DIRECTION_MAP[direction] || $MenuUtil.SUB_POP_DIRECTION_MAP["default"];
            },
            isRootMenu: function(data) {
                return data.getProperty("parent") == null;
            },
            getMenuExpandExpandedTemplate: function(renderer) {
                if ($MenuUtil.isRootMenu(data)) {
                    return view._renderConfig["root"];
                }
            }
        };
        var $MenuController = function() {
            $MenuController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($MenuController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "blur", "click" ];
            },
            handle_blur: function() {
                if (window.focus_ui_mode === "debug") {
                    return;
                }
                this.getView().collapseAll();
            },
            handle_click: function(evt, view) {
                if (!view.getDataAt(evt)) {
                    view.collapseAll();
                    view._setHoverData(null, true, evt);
                }
            },
            add: function(view) {
                $MenuController.superClass.add.apply(this, arguments);
                this.getView().getRoot().setAttribute("tabindex", 0);
            },
            remove: function() {
                this.getView().getRoot().removeAttribute("tabindex");
                $MenuController.superClass.remove.apply(this, arguments);
            }
        });
        var $MenuRenderer = function() {
            $MenuRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($MenuRenderer, $IDataULLevelRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                var isDivider = view.isDivider(data);
                if (isDivider) {
                    renderConfig["divider"] = true;
                } else {
                    $MenuRenderer.superClass.updateRenderConfig.apply(this, arguments);
                    this._updateMenuRenderConfig(view, data, renderConfig);
                }
            },
            _updateMenuRenderConfig: function(view, data, renderConfig) {
                var isRootMenu = $MenuUtil.isRootMenu(data);
                renderConfig["root_menu"] = isRootMenu;
                if (this.getRenderConfig("has_children") === true) {
                    renderConfig["pop_direction"] = $MenuUtil.getPopDirection(view, data);
                    if (isRootMenu) {
                        renderConfig["expand_icon_visible"] = view.getDataViewProperty(data, "expand_icon_visible", "root_expand_icon_visible") === true;
                    }
                }
            },
            updateRenderer: function(view, data, renderConfig) {
                var isDivider = this.getRenderConfig("divider") === true;
                $domToggleClass(this._renderer, "divider", isDivider);
                if (!isDivider) {
                    $MenuRenderer.superClass.updateRenderer.apply(this, arguments);
                    $domRemoveClass(this._renderer, "down_right down_left up_right up_left right_down right_up left_down left_up");
                    var pop_direction = this.getRenderConfig("pop_direction");
                    if (pop_direction) {
                        $domAddClass(this._renderer, pop_direction);
                    }
                    $domToggleClass(this._renderer, this.getRenderConfig("root_menu") === true && this.getRenderConfig("expand_icon_visible") === true);
                }
            },
            _getExpandTemplate: function() {
                var tmp;
                var expanded = this.getRenderConfig("expanded") === true;
                if (this.getRenderConfig("root_menu") === true) {
                    if (expanded) {
                        tmp = this.getViewRenderConfig("root_expand_expanded_icon_template");
                    } else {
                        tmp = this.getViewRenderConfig("root_expand_collapsed_icon_template");
                    }
                    if (!tmp) {
                        var pop_direction = this.getRenderConfig("pop_direction");
                        if (pop_direction) {
                            tmp = this.getViewRenderConfig("expand_" + pop_direction.split("_")[0] + "_icon_template");
                        }
                    }
                } else {
                    if (expanded) {
                        tmp = this.getViewRenderConfig("expand_expanded_icon_template");
                    } else {
                        tmp = this.getViewRenderConfig("expand_collapsed_icon_template");
                    }
                    if (!tmp) {
                        tmp = this.getViewRenderConfig("expand_right_icon_template");
                    }
                }
                return tmp;
            }
        });
        var $Menu = function() {
            if (!(this instanceof $Menu)) {
                return $ClassUtil.createInstance($Menu, arguments);
            }
            var arg0 = arguments[0];
            if ($DomType.isElement(arg0)) {
                return $HTMLWidgetParser.parseView("zw-menu", arg0);
            }
            $Menu.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-menu");
            this._ToggleModeClass();
            this.addController(new $MenuController());
        };
        $extendClass($Menu, $IDataULLevelView, $mergeObject({
            __className_: "Menu",
            ___zdefaults_: {
                selectable: false,
                expand_on_click: false,
                accordion: true,
                hoverable: true,
                three_states_check: false,
                check_on_click: true,
                hover_delay: 200,
                mode: "horizontal",
                direction: null,
                root_expand_icon_visible: false,
                root_expand_expanded_icon_template: null,
                root_expand_collapsed_icon_template: null,
                expand_icon_visible: true,
                expand_expanded_icon_template: null,
                expand_collapsed_icon_template: null,
                expand_up_icon_template: $CommonIconTemplate.to_up,
                expand_down_icon_template: $CommonIconTemplate.to_down,
                expand_left_icon_template: $CommonIconTemplate.to_left,
                expand_right_icon_template: $CommonIconTemplate.to_right,
                open_on_hover: false,
                close_on_click: true
            },
            _displayToResize: function() {
                $Menu.superClass._displayToResize.apply(this, arguments);
                var parent = this.getRoot().parentNode;
                if (parent) {
                    $domSetStyle(parent, "overflow", "visible");
                }
            },
            _onViewChange: function(key, value, old) {
                $Menu.superClass._onViewChange.apply(this, arguments);
                this._doMenuViewUpdate(key);
            },
            _doMenuViewUpdate: function(key, value, old) {
                if (key === "mode") {
                    this._ToggleModeClass();
                }
            },
            _ToggleModeClass: function() {
                $domToggleClass(this.getRoot(), "horizontal", !this._isVertical());
                $domToggleClass(this.getRoot(), "vertical", this._isVertical());
            },
            _isVertical: function() {
                return this.getProperty("mode") === "vertical";
            },
            _onExpandChange: function() {
                $Menu.superClass._onExpandChange.apply(this, arguments);
                if (this._hasExpanded()) {
                    this.getRoot().focus({
                        preventScroll: true
                    });
                }
            },
            _setHoverData: function() {
                var oldHoverData = this._hoverData;
                $Menu.superClass._setHoverData.apply(this, arguments);
                var newHoverData = this._hoverData;
                if (oldHoverData === newHoverData) {
                    return;
                }
                this._handleExpandByHover(oldHoverData, newHoverData);
            },
            _handleExpandByHover: function(oldHoverData, newHoverData) {
                if (newHoverData) {
                    var isRootMenu = $MenuUtil.isRootMenu(newHoverData);
                    var hasExpanded = this._hasExpanded();
                    if (oldHoverData) {
                        if (this.isExpanded(oldHoverData) && !$DataLevelUtil.isDescendantOf(newHoverData, oldHoverData)) {
                            if (isRootMenu && $MenuUtil.isRootMenu(oldHoverData)) {
                                if (this.isExpandable(newHoverData) && this._hasDescendantVisible(newHoverData) || this.getProperty("open_on_hover") !== false) {
                                    this.collapse(oldHoverData);
                                }
                            } else {
                                this.collapse(oldHoverData);
                            }
                        }
                    }
                    if (isRootMenu) {
                        if (!hasExpanded && this.getProperty("open_on_hover") === false) {
                            return;
                        }
                    }
                    this._expandByHover(newHoverData);
                } else {
                    if (oldHoverData) {
                        if (this.isExpanded(oldHoverData)) {
                            if ($MenuUtil.isRootMenu(oldHoverData)) {
                                if (this.getProperty("open_on_hover") === false) {
                                    return;
                                }
                            }
                            this.collapse(oldHoverData);
                        }
                    }
                }
            },
            _expandByHover: function(hoverData) {
                if (this.isExpandable(hoverData) && this._hasDescendantVisible(hoverData)) {
                    var delay = this.getProperty("hover_delay");
                    if (!$MenuUtil.isRootMenu(hoverData) && delay > 0) {
                        $callLater(function() {
                            if (this._hoverData) {
                                this.expand(this._hoverData);
                            }
                        }, delay, this);
                    } else {
                        this.expand(hoverData);
                    }
                }
            },
            _onDataClick: function(data, evt) {
                if ($MenuUtil.isRootMenu(data)) {
                    if (!this._isExpandable(data)) {
                        this.collapseAll();
                    } else {
                        this.toggleExpand(data);
                    }
                } else {
                    if (this.getProperty("close_on_click") !== false && !this.hasChildrenVisible(data)) {
                        this.collapseAll();
                    }
                }
                if (!this.hasChildrenVisible(data)) {
                    this._onMenuItemClick(data, evt);
                }
                $Menu.superClass._onDataClick.apply(this, arguments);
            },
            _onMenuItemClick: function(data, evt) {
                this._callOn("onMenuItemClick", "on.menu.item.click", {
                    data: data,
                    event: evt
                }, [ data, evt ]);
            },
            onMenuItemClick: function(listener, context) {
                this.addListener("on.menu.item.click", listener, context);
            },
            _hasExpanded: function() {
                return this._expandProvider.size() > 0;
            },
            getDataRendererClass: function(data) {
                return $MenuRenderer;
            },
            isDivider: function(data) {
                return data.getProperty("divider") === true;
            }
        }, {
            _isAccordion: function() {
                return true;
            },
            _isDisabled: function(data) {
                return this.isDivider(data) || this.isDisabled(data);
            },
            makeVisible: function() {}
        }));
        var $PopUpUtil = {
            _CachedPopUpViewMap: {},
            addCacheView: function(popView) {
                var className = popView.getClassName();
                var list = $PopUpUtil._CachedPopUpViewMap[className];
                if (!list) {
                    list = [];
                    $PopUpUtil._CachedPopUpViewMap[className] = list;
                }
                list.push(popView);
            },
            removeCacheView: function(popView) {
                var className = popView.getClassName();
                var list = $PopUpUtil._CachedPopUpViewMap[className];
                if (list) {
                    $arrayRemoveItem(list, popView);
                }
            },
            closeAll: function(className) {
                $mergeArray([], $PopUpUtil._CachedPopUpViewMap[className]).forEach(function(popView) {
                    popView.close();
                });
            },
            z_index: 1e4,
            open: function(popView, parent) {
                $PopUpUtil.addCacheView(popView);
                this.completeAnimations(popView);
                var popEle = popView.getRoot();
                popView._beforeOpen();
                var oldOpacity = $domGetStyle(popEle, "opacity");
                $domSetStyle(popEle, "opacity", 0);
                $domSetStyle(popEle, "left", "-10100px");
                $PopUpUtil.resetStaticPosition(parent);
                parent.appendChild(popEle);
                $callRAFLater(function() {
                    $PopUpUtil.startAnimations(popView);
                    $domSetStyle(popEle, "opacity", oldOpacity);
                    if ($domGetStyle(popEle, "left") === "-10100px") {
                        $domRemoveStyle(popEle, "left");
                    }
                    popView._onOpen();
                });
            },
            _getAnimationEle: function(popView) {
                var bodyDiv = popView._bodyDiv;
                if (bodyDiv && bodyDiv.parentNode) {
                    return popView.getRoot();
                }
                return popView._getContentEle();
            },
            completeAnimations: function(popView) {
                $WAnimationUtil.completeAnimation($PopUpUtil._getAnimationEle(popView));
                $WAnimationUtil.completeAnimation(popView._maskDiv);
            },
            startAnimations: function(popView, isClose) {
                $PopUpUtil._startMaskAnimations(popView, isClose);
                var contentEle = $PopUpUtil._getAnimationEle(popView);
                if (!contentEle) {
                    return;
                }
                var animationCls;
                if (isClose === true) {
                    animationCls = popView.getProperty("close_animation");
                } else {
                    animationCls = popView.getProperty("open_animation");
                }
                var rootDiv = popView.getRoot();
                rootDiv.scrollLeft = 0;
                rootDiv.scrollTop = 0;
                $WAnimationUtil.startAnimation(contentEle, animationCls, function() {
                    if (isClose === true) {
                        if (popView.getProperty("release_on_close") === true) {
                            var currentContentObj = popView._currentContentObj;
                            if (currentContentObj && rootDiv.contains(currentContentObj.contentEle)) {
                                $ContentUtil.releaseContent(currentContentObj);
                            }
                        }
                        $domRemove(rootDiv);
                    }
                });
            },
            _startMaskAnimations: function(popView, isClose) {
                var maskEle = popView._maskDiv;
                if (!maskEle) {
                    return;
                }
                var animationCls = isClose === true ? popView.getProperty("mask_close_animation") : popView.getProperty("mask_open_animation");
                $WAnimationUtil.startAnimation(maskEle, animationCls, function() {
                    if (isClose === true) {
                        $domRemove(maskEle);
                    }
                });
            },
            isOpen: function(popView) {
                return popView && popView.getRoot().parentNode && $domContainsClass(popView.getRoot(), "open");
            },
            close: function(popView) {
                var beforeClose = popView.beforeClose();
                if (beforeClose === false) {
                    return;
                }
                if (window.event && popView instanceof $Modal) {
                    window.event.stopImmediatePropagation();
                }
                if ($isFunction(beforeClose)) {
                    beforeClose(function() {
                        $PopUpUtil._doClose(popView);
                    });
                } else {
                    $PopUpUtil._doClose(popView);
                }
            },
            _doClose: function(popView) {
                $PopUpUtil.removeCacheView(popView);
                this.completeAnimations(popView);
                $PopUpUtil.startAnimations(popView, true);
                popView._beforeClose();
                popView._onClose();
                popView._afterClose();
            },
            setPosition: function(popEle, position) {
                [ "left", "right", "top", "bottom" ].forEach(function(p) {
                    var pv = position[p];
                    if (pv != null) {
                        $domSetStyle(popEle, p, pv + "px");
                    } else {
                        $domRemoveStyle(popEle, p);
                    }
                });
            },
            resetStaticPosition: function(ele) {
                if ($domGetStyle(ele, "position") === "static") {
                    $domSetStyle(ele, "position", "relative");
                }
            },
            addDismissListener: function(contentEle, popView, viewType) {
                if (!contentEle) {
                    return;
                }
                var closeEleArray = $domQueryAll($domGetAttrSelector("data-dismiss", viewType), contentEle);
                closeEleArray.forEach(function(closeEle) {
                    $domOn(closeEle, "click", popView.close, popView);
                });
            },
            removeDismissListener: function(contentEle, popView, viewType) {
                if (!contentEle) {
                    return;
                }
                var closeEleArray = $domQueryAll($domGetAttrSelector("data-dismiss", viewType), contentEle);
                closeEleArray.forEach(function(closeEle) {
                    $domOff(closeEle, "click", popView.close, popView);
                });
            }
        };
        var $PopUpDirectionUtil = {
            DIRECTION_CLASS_MAP: {
                right: "to-right",
                right_down: "to-right-down",
                right_up: "to-right-up",
                left: "to-left",
                left_down: "to-left-down",
                left_up: "to-left-up",
                up: "to-up",
                up_right: "to-up-right",
                up_left: "to-up-left",
                down: "to-down",
                down_right: "to-down-right",
                down_left: "to-down-left"
            },
            POSITION_CLASS_MAP: {
                top_right: "top-right",
                top_left: "top-left",
                bottom_right: "bottom-right",
                bottom_left: "bottom-left",
                center: "center"
            },
            POSITION_DIRECTION_MAP: {
                top_left: "down",
                top_right: "down",
                bottom_left: "up",
                bottom_right: "up"
            },
            setDirectionClass: function(popEle, direction, defaultDirection) {
                $domRemoveClass(popEle, $PopUpDirectionUtil.ALL_DIRECTION_CLASS);
                $domAddClass(popEle, $PopUpDirectionUtil.DIRECTION_CLASS_MAP[direction] || defaultDirection);
            },
            setPositionClass: function(popEle, position, defaultPosition) {
                $domRemoveClass(popEle, $PopUpDirectionUtil.ALL_POSITION_CLASS);
                $domAddClass(popEle, $PopUpDirectionUtil.POSITION_CLASS_MAP[position] || defaultPosition);
            },
            getScreenCenterDirection: function(hostEleOrEvtOrRect) {
                var windowCenterX, windowCenterY;
                if ($DomEventUtil.isPointerEvent(hostEleOrEvtOrRect)) {
                    var center = $DomGeom.getEventWindowOffset(hostEleOrEvtOrRect);
                    windowCenterX = center.x;
                    windowCenterY = center.y;
                } else if ($HostPopUpUtil.isRect(hostEleOrEvtOrRect)) {
                    windowCenterX = hostEleOrEvtOrRect.x + hostEleOrEvtOrRect.width / 2;
                    windowCenterY = hostEleOrEvtOrRect.y + hostEleOrEvtOrRect.height / 2;
                } else if ($HostPopUpUtil.isPoint(hostEleOrEvtOrRect)) {
                    windowCenterX = hostEleOrEvtOrRect.x;
                    windowCenterY = hostEleOrEvtOrRect.y;
                } else {
                    var hostWindowOffset = hostEleOrEvtOrRect.getBoundingClientRect();
                    windowCenterX = hostWindowOffset.left + hostWindowOffset.width / 2;
                    windowCenterY = hostWindowOffset.top + hostWindowOffset.height / 2;
                }
                var windowSize = $DomGeom.getWindowSize();
                var windowWidth = windowSize.width;
                var windowHeight = windowSize.height;
                if (windowCenterX < windowWidth / 3) {
                    if (windowCenterY < windowHeight / 3) {
                        return "right_down";
                    }
                    if (windowCenterY > windowHeight * 2 / 3) {
                        return "right_up";
                    }
                    return "right";
                }
                if (windowCenterX > windowWidth * 2 / 3) {
                    if (windowCenterY < windowHeight / 3) {
                        return "left_down";
                    }
                    if (windowCenterY > windowHeight * 2 / 3) {
                        return "left_up";
                    }
                    return "left";
                }
                if (windowCenterY < windowHeight / 3) {
                    return "down";
                }
                if (windowCenterY > windowHeight * 2 / 3) {
                    return "up";
                }
                return "down";
            },
            getStackPosition: function(clsPrefix, popEle, parent, position, direction, offset, gap) {
                switch (position) {
                    case "top_left":
                        return $PopUpDirectionUtil._getTopLeftStackPosition(clsPrefix, popEle, parent, direction, offset, gap);

                    case "bottom_left":
                        return $PopUpDirectionUtil._getBottomLeftStackPosition(clsPrefix, popEle, parent, direction, offset, gap);

                    case "bottom_right":
                        return $PopUpDirectionUtil._getBottomRightStackPosition(clsPrefix, popEle, parent, direction, offset, gap);

                    default:
                        return $PopUpDirectionUtil._getTopRightStackPosition(clsPrefix, popEle, parent, direction, offset, gap);
                }
            },
            _getTopLeftStackPosition: function(clsPrefix, popEle, parent, direction, offset, gap) {
                direction = $PopUpDirectionUtil.getPositionDirection("top_left", direction);
                var directionCls = $PopUpDirectionUtil.DIRECTION_CLASS_MAP[direction];
                var stackArray;
                if (parent) {
                    stackArray = $domQueryAll("." + clsPrefix + ".top-left." + directionCls, parent);
                } else {
                    stackArray = $domQueryAll("." + clsPrefix + ".top-left." + directionCls);
                }
                var lastStackEle = stackArray[stackArray.length - 1];
                if (!lastStackEle) {
                    return {
                        top: offset,
                        left: offset
                    };
                }
                var popEleWidth = popEle.offsetWidth;
                var popEleHeight = popEle.offsetHeight;
                var lastStackEleTop = parseInt($domGetStyle(lastStackEle, "top")) | 0;
                var lastStackEleLeft = parseInt($domGetStyle(lastStackEle, "left")) | 0;
                var lastStackEleWidth = lastStackEle.offsetWidth;
                var lastStackEleHeight = lastStackEle.offsetHeight;
                var top, left;
                switch (direction) {
                    case "left":
                        top = lastStackEleTop;
                        left = lastStackEleLeft - popEleWidth - gap;
                        break;

                    case "right":
                        top = lastStackEleTop;
                        left = lastStackEleLeft + lastStackEleWidth + gap;
                        break;

                    case "up":
                        top = lastStackEleTop - gap - popEleHeight;
                        left = offset;
                        break;

                    default:
                        top = lastStackEleTop + lastStackEleHeight + gap;
                        left = offset;
                        break;
                }
                return {
                    top: top,
                    left: left
                };
            },
            _getTopRightStackPosition: function(clsPrefix, popEle, parent, direction, offset, gap) {
                direction = $PopUpDirectionUtil.getPositionDirection("top_right", direction);
                var directionCls = $PopUpDirectionUtil.DIRECTION_CLASS_MAP[direction];
                var stackArray;
                if (parent) {
                    stackArray = $domQueryAll("." + clsPrefix + ".top-right." + directionCls, parent);
                } else {
                    stackArray = $domQueryAll("." + clsPrefix + ".top-right." + directionCls);
                }
                var lastStackEle = stackArray[stackArray.length - 1];
                if (!lastStackEle) {
                    return {
                        top: offset,
                        right: offset
                    };
                }
                var popEleWidth = popEle.offsetWidth;
                var popEleHeight = popEle.offsetHeight;
                var lastStackEleTop = parseInt($domGetStyle(lastStackEle, "top")) | 0;
                var lastStackEleRight = parseInt($domGetStyle(lastStackEle, "right")) | 0;
                var lastStackEleWidth = lastStackEle.offsetWidth;
                var lastStackEleHeight = lastStackEle.offsetHeight;
                var top, right;
                switch (direction) {
                    case "left":
                        top = lastStackEleTop;
                        right = lastStackEleRight + lastStackEleWidth + gap;
                        break;

                    case "right":
                        top = lastStackEleTop;
                        right = lastStackEleRight - gap - popEleWidth;
                        break;

                    case "up":
                        top = lastStackEleTop - gap - popEleHeight;
                        right = offset;
                        break;

                    default:
                        top = lastStackEleTop + lastStackEleHeight + gap;
                        right = offset;
                        break;
                }
                return {
                    top: top,
                    right: right
                };
            },
            _getBottomRightStackPosition: function(clsPrefix, popEle, parent, direction, offset, gap) {
                direction = $PopUpDirectionUtil.getPositionDirection("bottom_right", direction);
                var directionCls = $PopUpDirectionUtil.DIRECTION_CLASS_MAP[direction];
                var stackArray;
                if (parent) {
                    stackArray = $domQueryAll("." + clsPrefix + ".bottom-right." + directionCls, parent);
                } else {
                    stackArray = $domQueryAll("." + clsPrefix + ".bottom-right." + directionCls);
                }
                var lastStackEle = stackArray[stackArray.length - 1];
                if (!lastStackEle) {
                    return {
                        bottom: offset,
                        right: offset
                    };
                }
                var popEleWidth = popEle.offsetWidth;
                var popEleHeight = popEle.offsetHeight;
                var lastStackEleBottom = parseInt($domGetStyle(lastStackEle, "bottom")) | 0;
                var lastStackEleRight = parseInt($domGetStyle(lastStackEle, "right")) | 0;
                var lastStackEleWidth = lastStackEle.offsetWidth;
                var lastStackEleHeight = lastStackEle.offsetHeight;
                var bottom, right;
                switch (direction) {
                    case "left":
                        bottom = lastStackEleBottom;
                        right = lastStackEleRight + lastStackEleWidth + gap;
                        break;

                    case "right":
                        bottom = lastStackEleBottom;
                        right = lastStackEleRight - gap - popEleWidth;
                        break;

                    case "down":
                        bottom = lastStackEleBottom - gap - popEleHeight;
                        right = offset;
                        break;

                    default:
                        bottom = lastStackEleBottom + lastStackEleHeight + gap;
                        right = offset;
                        break;
                }
                return {
                    bottom: bottom,
                    right: right
                };
            },
            _getBottomLeftStackPosition: function(clsPrefix, popEle, parent, direction, offset, gap) {
                direction = $PopUpDirectionUtil.getPositionDirection("bottom_left", direction);
                var directionCls = $PopUpDirectionUtil.DIRECTION_CLASS_MAP[direction];
                var stackArray;
                if (parent) {
                    stackArray = $domQueryAll("." + clsPrefix + ".bottom-left." + directionCls, parent);
                } else {
                    stackArray = $domQueryAll("." + clsPrefix + ".bottom-left." + directionCls);
                }
                var lastStackEle = stackArray[stackArray.length - 1];
                if (!lastStackEle) {
                    return {
                        bottom: offset,
                        left: offset
                    };
                }
                var popEleWidth = popEle.offsetWidth;
                var popEleHeight = popEle.offsetHeight;
                var lastStackEleBottom = parseInt($domGetStyle(lastStackEle, "bottom")) | 0;
                var lastStackEleLeft = parseInt($domGetStyle(lastStackEle, "left")) | 0;
                var lastStackEleWidth = lastStackEle.offsetWidth;
                var lastStackEleHeight = lastStackEle.offsetHeight;
                var bottom, left;
                switch (direction) {
                    case "left":
                        bottom = lastStackEleBottom;
                        left = lastStackEleLeft - popEleWidth - gap;
                        break;

                    case "right":
                        bottom = lastStackEleBottom;
                        left = lastStackEleLeft + gap + lastStackEleWidth;
                        break;

                    case "down":
                        bottom = lastStackEleBottom - gap - popEleHeight;
                        left = offset;
                        break;

                    default:
                        bottom = lastStackEleBottom + lastStackEleHeight + gap;
                        left = offset;
                        break;
                }
                return {
                    bottom: bottom,
                    left: left
                };
            },
            getPositionDirection: function(position, direction) {
                return direction || $PopUpDirectionUtil.POSITION_DIRECTION_MAP[position] || "down";
            }
        };
        $PopUpDirectionUtil.ALL_DIRECTION_CLASS = $getObjectValues($PopUpDirectionUtil.DIRECTION_CLASS_MAP).join(" ");
        $PopUpDirectionUtil.ALL_POSITION_CLASS = $getObjectValues($PopUpDirectionUtil.POSITION_CLASS_MAP).join(" ");
        var $HostPopUpUtil = {
            isRect: function(obj) {
                if ($isObject(obj)) {
                    return obj.hasOwnProperty("x") && obj.hasOwnProperty("y") && obj.hasOwnProperty("width") && obj.hasOwnProperty("height");
                }
                return false;
            },
            isPoint: function(obj) {
                if ($isObject(obj)) {
                    return obj.hasOwnProperty("x") && obj.hasOwnProperty("y");
                }
                return false;
            },
            hostPopup: function(viewClass, viewType, hostEleOrEvtOrRect, props) {
                props = $mergeObject({}, $ContentUtil.getLabelContent(props));
                var ele = $ContentUtil.getContentElement(props.content);
                if (ele && !props.hasOwnProperty("release_on_close")) {
                    props.release_on_close = true;
                }
                var popView = new viewClass(props);
                $callRAFLater(function() {
                    popView.open(hostEleOrEvtOrRect);
                });
                if (ele) {
                    $PopUpUtil.addDismissListener(ele, popView, viewType);
                    popView._afterClose = function() {
                        $PopUpUtil.removeDismissListener(ele, popView, viewType);
                    };
                }
                return popView;
            },
            open: function(popView, popEle, hostEleOrEvtOrRect, direction, offset) {
                if (direction === "screen_center") {
                    direction = $PopUpDirectionUtil.getScreenCenterDirection(hostEleOrEvtOrRect);
                }
                $PopUpDirectionUtil.setDirectionClass(popEle, direction, "to-top");
                var parent = document.body;
                $PopUpUtil.open(popView, parent);
                $HostPopUpUtil._positionOnHost(parent, popEle, hostEleOrEvtOrRect, direction, offset);
            },
            _positionOnHost: function(parent, popEle, hostEleOrEvtOrRect, direction, offset) {
                var hostPageOffset;
                var hostEleWidth = 0, hostEleHeight = 0;
                if ($DomEventUtil.isPointerEvent(hostEleOrEvtOrRect)) {
                    hostPageOffset = $DomGeom.getEventPageOffset(hostEleOrEvtOrRect);
                } else if ($HostPopUpUtil.isRect(hostEleOrEvtOrRect)) {
                    if (hostEleOrEvtOrRect.scroll === true) {
                        hostPageOffset = {
                            x: hostEleOrEvtOrRect.x,
                            y: hostEleOrEvtOrRect.y
                        };
                    } else {
                        hostPageOffset = $DomGeom.getWindowPageOffset();
                        hostPageOffset.x += hostEleOrEvtOrRect.x;
                        hostPageOffset.y += hostEleOrEvtOrRect.y;
                    }
                    hostEleWidth = hostEleOrEvtOrRect.width;
                    hostEleHeight = hostEleOrEvtOrRect.height;
                } else if ($HostPopUpUtil.isPoint(hostEleOrEvtOrRect)) {
                    if (hostEleOrEvtOrRect.scroll === true) {
                        hostPageOffset = {
                            x: hostEleOrEvtOrRect.x,
                            y: hostEleOrEvtOrRect.y
                        };
                    } else {
                        hostPageOffset = $DomGeom.getWindowPageOffset();
                        hostPageOffset.x += hostEleOrEvtOrRect.x;
                        hostPageOffset.y += hostEleOrEvtOrRect.y;
                    }
                } else {
                    hostPageOffset = $DomGeom.getElementPageOffset(hostEleOrEvtOrRect);
                    hostEleWidth = hostEleOrEvtOrRect.offsetWidth;
                    hostEleHeight = hostEleOrEvtOrRect.offsetHeight;
                }
                var hostPageX = hostPageOffset.x;
                var hostPageY = hostPageOffset.y;
                var popEleWidth = popEle.offsetWidth;
                var popEleHeight = popEle.offsetHeight;
                var offsetX = 0;
                var offsetY = 0;
                var isObjOffset = $isObject(offset);
                if (isObjOffset) {
                    offsetX = offset.x | 0;
                    offsetY = offset.y | 0;
                } else {
                    offsetX = offset | 0;
                    offsetY = offset | 0;
                }
                var left, top;
                switch (direction) {
                    case "right":
                        top = hostPageY + hostEleHeight / 2 - popEleHeight / 2;
                        left = hostPageX + hostEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                        }
                        break;

                    case "right_down":
                        top = hostPageY;
                        left = hostPageX + hostEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                        }
                        break;

                    case "right_up":
                        top = hostPageY + hostEleHeight - popEleHeight;
                        left = hostPageX + hostEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                        }
                        break;

                    case "left":
                        top = hostPageY + hostEleHeight / 2 - popEleHeight / 2;
                        left = hostPageX - popEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                            offsetX = -offsetX;
                        }
                        break;

                    case "left_down":
                        top = hostPageY;
                        left = hostPageX - popEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                            offsetX = -offsetX;
                        }
                        break;

                    case "left_up":
                        top = hostPageY + hostEleHeight - popEleHeight;
                        left = hostPageX - popEleWidth;
                        if (!isObjOffset) {
                            offsetY = 0;
                            offsetX = -offsetX;
                        }
                        break;

                    case "up_right":
                        top = hostPageY - popEleHeight;
                        left = hostPageX;
                        if (!isObjOffset) {
                            offsetX = 0;
                            offsetY = -offsetY;
                        }
                        break;

                    case "up_left":
                        top = hostPageY - popEleHeight;
                        left = hostPageX + hostEleWidth - popEleWidth;
                        if (!isObjOffset) {
                            offsetX = 0;
                            offsetY = -offsetY;
                        }
                        break;

                    case "down":
                        top = hostPageY + hostEleHeight;
                        left = hostPageX + hostEleWidth / 2 - popEleWidth / 2;
                        if (!isObjOffset) {
                            offsetX = 0;
                        }
                        break;

                    case "down_right":
                        top = hostPageY + hostEleHeight;
                        left = hostPageX;
                        if (!isObjOffset) {
                            offsetX = 0;
                        }
                        break;

                    case "down_left":
                        top = hostPageY + hostEleHeight;
                        left = hostPageX + hostEleWidth - popEleWidth;
                        if (!isObjOffset) {
                            offsetX = 0;
                        }
                        break;

                    default:
                        top = hostPageY - popEleHeight;
                        left = hostPageX + hostEleWidth / 2 - popEleWidth / 2;
                        if (!isObjOffset) {
                            offsetX = 0;
                            offsetY = -offsetY;
                        }
                        break;
                }
                var bodyPageOffset = $DomGeom.getElementPageOffset(parent);
                $domSetStyle(popEle, "left", left + offsetX - bodyPageOffset.x + "px");
                $domSetStyle(popEle, "top", top + offsetY - bodyPageOffset.y + "px");
            }
        };
        var $PopUpController = function() {
            $PopUpController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($PopUpController, $IViewController, {
            add: function(view) {
                $PopUpController.superClass.add.apply(this, arguments);
                $domOn(view._closeWrapper, "click", this.handleCloseClick, this);
            },
            remove: function() {
                $domOff(this._view._closeWrapper, "click", this.handleCloseClick, this);
                $PopUpController.superClass.remove.apply(this, arguments);
            },
            handleCloseClick: function(evt) {
                evt.stopPropagation();
                this.getView().close();
            },
            getViewDefaultTypes: function() {
                if (this.getView().getProperty("close_on_press_escape") === true) {
                    return [ "click", "keydown" ];
                }
                return [ "click" ];
            },
            handle_keydown: function(evt, view) {
                if (!$PopUpUtil.isOpen(view)) {
                    return;
                }
                if (evt.keyCode === 27) {
                    if (view.getProperty("close_on_press_escape") === true) {
                        view.close();
                    }
                }
            },
            handle_click: function(evt, view) {
                if (!$PopUpUtil.isOpen(view)) {
                    return;
                }
                if (view.getProperty("close_on_click") === true) {
                    evt.stopPropagation();
                    view.close();
                }
                if (!$isInDom(evt.target)) {
                    evt.stopPropagation();
                }
            },
            getWindowDefaultTypes: function() {
                var types = [];
                if (this.getView().getProperty("close_on_click_outside") === true) {
                    types.push("click");
                }
                if (this.getView().getProperty("close_on_window_blur") === true) {
                    types.push("blur");
                }
                return types;
            },
            handle_window_click: function(evt, view) {
                if (view.getProperty("close_on_click_outside") !== true) {
                    return;
                }
                if (!$PopUpUtil.isOpen(view)) {
                    return;
                }
                var root = view.getRoot();
                if ($domQuery(".z-widget.popup.open", root)) {
                    return;
                }
                var target = evt.target;
                if (root.contains(target) && target !== view._maskDiv) {
                    return;
                }
                if ($domContainsClass(root, "z-modal")) {
                    if ($domQuery(".z-widget.popup.open:not(.z-modal)")) {
                        return;
                    }
                    var msgBox = $domQuery(".z-widget.popup.open.z-message-box");
                    if (msgBox != null && msgBox !== root) {
                        return;
                    }
                }
                view.close();
            },
            handle_window_blur: function(evt, view) {
                if (!$PopUpUtil.isOpen(view)) {
                    return;
                }
                if (window.focus_ui_mode === "debug") {
                    return;
                }
                view.close();
            }
        });
        var $IPopUpView = function() {
            this._headerDiv = $domCreate("div", "header ");
            this._bodyDiv = $domCreate("div", "body");
            this._closeWrapper = $domCreate("span", "close");
            $IPopUpView.superClass.constructor.apply(this, arguments);
            var root = this.getRoot();
            $WViewUtil.addWidgetClass(root);
            $domAddClass(root, "popup");
            root.appendChild(this._headerDiv);
            root.appendChild(this._bodyDiv);
            this.addController(new $PopUpController());
        };
        $extendClass($IPopUpView, $IView, $mergeObject({
            ___zdefaults_: {
                close_icon_visible: false,
                close_icon_template: $IconTemplate.remove,
                close_on_click: false,
                mask_visible: false,
                release_on_close: false,
                close_on_click_outside: false,
                close_on_window_blur: false,
                close_on_press_escape: false,
                auto_focus: true,
                open_animation: null,
                close_animation: null,
                mask_open_animation: "z-animation-fadeIn",
                mask_close_animation: "z-animation-fadeOut"
            },
            _appendToUpdate: function() {},
            open: function() {},
            _beforeOpen: function() {
                this._initPopUpView();
            },
            _onOpen: function() {
                $domAddClass(this.getRoot(), "open");
                this._callOn("onOpen", "on.open", {
                    type: "open"
                }, []);
            },
            onOpen: function(listener, context) {
                this.addListener("on.open", listener, context);
            },
            close: function() {
                $PopUpUtil.close(this);
            },
            beforeClose: function() {},
            _beforeClose: function() {
                $domRemoveClass(this.getRoot(), "open");
            },
            _onClose: function() {
                this._callOn("onClose", "on.close", {
                    type: "close"
                }, []);
            },
            _afterClose: function() {},
            onClose: function(listener, context) {
                this.addListener("on.close", listener, context);
            },
            isOpen: function() {
                return $PopUpUtil.isOpen(this);
            },
            getContentContainer: function() {
                return this._bodyDiv;
            }
        }, {
            _initPopUpView: function() {
                this._initPopUpTitle();
                this._initPopUpMask();
                this._initPopUpCloseIcon();
                this._setPopUpContent();
            },
            _initPopUpTitle: function() {
                var title = this.getProperty("title");
                if (title == null) {
                    this._headerDiv.innerHTML = "";
                } else {
                    this._headerDiv.innerHTML = title;
                }
            },
            _initPopUpMask: function() {
                var mask_visible = this.getProperty("mask_visible");
                if (mask_visible === true) {
                    if (!this._maskDiv) {
                        this._maskDiv = $domCreate("div", "mask");
                    }
                    var root = this.getRoot();
                    root.insertBefore(this._maskDiv, root.firstChild);
                } else {
                    if (this._maskDiv) {
                        $domRemove(this._maskDiv);
                    }
                }
            },
            _initPopUpCloseIcon: function() {
                var visible = this.getProperty("close_icon_visible");
                if (visible === true) {
                    this._closeWrapper.innerHTML = this.getProperty("close_icon_template");
                    this.getRoot().appendChild(this._closeWrapper);
                } else {
                    $domRemove(this._closeWrapper);
                }
            },
            _setPopUpContent: function() {
                var contentObj = $ContentUtil.getContentObject(this.getProperty("content"));
                if (contentObj) {
                    this.setCurrentContent(contentObj, true);
                    var root = this.getRoot();
                    var focusEle = $findArray($domQueryAll("[autofocus]", root), function(ele) {
                        return ele.disabled === false;
                    });
                    if (focusEle) {
                        z.dom.focus(focusEle, {
                            preventScroll: true
                        });
                        return;
                    }
                    if (this.getProperty("auto_focus") === true) {
                        z.dom.focus(root, {
                            preventScroll: true
                        });
                    }
                }
            },
            _getContentEle: function() {
                if (this._currentContentObj) {
                    return this._currentContentObj.contentEle;
                }
                return null;
            }
        }, $ContentInterface($IPopUpView)));
        var $IHostPopUpView = function() {
            $IHostPopUpView.superClass.constructor.apply(this, arguments);
            var root = this.getRoot();
            this._arrowDiv = $domCreate("div", "arrow");
            root.insertBefore(this._arrowDiv, root.firstElementChild);
        };
        $extendClass($IHostPopUpView, $IPopUpView, {
            ___zdefaults_: {
                delay: 0,
                direction: "right",
                offset: 2,
                close_on_click_outside: true,
                close_on_window_blur: true,
                auto_focus: false,
                open_animation: "z-animation-fadeIn",
                close_animation: "z-animation-fadeOut"
            },
            open: function(hostEleOrEvtOrRect) {
                this._cancelLater();
                if (!$DomEventUtil.isPointerEvent(hostEleOrEvtOrRect) && !$HostPopUpUtil.isRect(hostEleOrEvtOrRect) && !$HostPopUpUtil.isPoint(hostEleOrEvtOrRect)) {
                    hostEleOrEvtOrRect = $domQueryElement(hostEleOrEvtOrRect);
                }
                if (!hostEleOrEvtOrRect) {
                    return;
                }
                var root = this.getRoot();
                var delay = this.getProperty("delay");
                if ($isObject(delay)) {
                    delay = delay.open | 0;
                } else {
                    delay = delay | 0;
                }
                var direction = this.getProperty("direction");
                var offset = this.getProperty("offset");
                if (delay > 0) {
                    this._laterID = $callLater(function() {
                        $HostPopUpUtil.open(this, root, hostEleOrEvtOrRect, direction, offset);
                    }, delay, this);
                } else {
                    $HostPopUpUtil.open(this, root, hostEleOrEvtOrRect, direction, offset);
                }
            },
            _onOpen: function() {
                this._laterID = null;
                $IHostPopUpView.superClass._onOpen.apply(this, arguments);
            },
            close: function() {
                this._cancelLater();
                var delay = this.getProperty("delay");
                if ($isObject(delay)) {
                    delay = delay.close | 0;
                } else {
                    delay = delay | 0;
                }
                if (delay > 0) {
                    this._laterID = $callLater(function() {
                        $PopUpUtil.close(this);
                    }, delay, this);
                } else {
                    $PopUpUtil.close(this);
                }
            },
            _onClose: function() {
                this._laterID = null;
                $IHostPopUpView.superClass._onClose.apply(this, arguments);
            },
            _cancelLater: function() {
                if (this._laterID) {
                    $TimerUtil.cancelCallLater(this._laterID);
                    this._laterID = null;
                }
            }
        });
        var $ToggleUtil = {
            TRIGGER_EVENT: {
                hover: {
                    open: "mouseenter",
                    close: "mouseleave"
                },
                focus: {
                    open: "focus",
                    close: "blur"
                },
                click: {
                    open: "click",
                    close: "click"
                }
            },
            getTriggerEvent: function(trigger, defaultTrigger) {
                return $ToggleUtil.TRIGGER_EVENT[trigger] || $ToggleUtil.TRIGGER_EVENT[defaultTrigger];
            },
            clearToggleTrigger: function(toggleType, hostEle) {
                $ToggleUtil._removeToggleTrigger(toggleType, hostEle);
                $ToggleUtil._removeToggleTrigger(toggleType, hostEle, "close");
            },
            _removeToggleTrigger: function(toggleType, hostEle, opType) {
                var prefix = "_$z_toggle_" + toggleType;
                if (opType) {
                    prefix += "_" + opType;
                }
                var triggerObj = hostEle[prefix];
                if (triggerObj) {
                    $domOff(hostEle, triggerObj.trigger, triggerObj.listener);
                    delete hostEle[prefix];
                }
            },
            onTrigger: function(toggleType, hostEle, trigger, listener, opType) {
                $domOn(hostEle, trigger, listener);
                var prefix = "_$z_toggle_" + toggleType;
                if (opType) {
                    prefix += "_" + opType;
                }
                hostEle[prefix] = {
                    trigger: trigger,
                    listener: listener
                };
            },
            getToggleItems: function(type, args) {
                var rootEle;
                if (args.length > 0) {
                    rootEle = $domQuery(args[0]);
                    if (!rootEle) {
                        return;
                    }
                } else {
                    rootEle = document.body;
                }
                type = "zw-" + type;
                var itemArr = $domQueryAll($domGetAttrSelector("data-toggle", type), rootEle);
                if (rootEle.getAttribute("data-toggle") === type) {
                    itemArr.unshift(rootEle);
                }
                return itemArr;
            }
        };
        var $TooltipUtil = {
            tooltip: function(hostEle, props) {
                return $HostPopUpUtil.hostPopup($Tooltip, "tooltip", hostEle, props);
            },
            close: function() {
                $PopUpUtil.closeAll("Tooltip");
            },
            tooltipOn: function(hostEle, trigger, auto_close) {
                hostEle = $domQueryElement(hostEle);
                if (!hostEle) {
                    return;
                }
                $TooltipUtil._tooltipOn(hostEle, trigger, auto_close);
            },
            toggleInit: function(rootEle) {
                $ToggleUtil.getToggleItems("tooltip", arguments).forEach(function(hostEle) {
                    $TooltipUtil._tooltipOn(hostEle, hostEle.getAttribute("data-trigger"), hostEle.getAttribute("data-auto-close") !== "false");
                });
            },
            _tooltipOn: function(hostEle, trigger, auto_close) {
                $ToggleUtil.clearToggleTrigger("tooltip", hostEle);
                var triggerEvt = $ToggleUtil.getTriggerEvent(trigger, "hover");
                var tooltip;
                $ToggleUtil.onTrigger("tooltip", hostEle, triggerEvt.open, function() {
                    if ($PopUpUtil.isOpen(tooltip)) {
                        return;
                    }
                    tooltip = $TooltipUtil._openTooltip(hostEle, tooltip);
                });
                if (auto_close !== false) {
                    $ToggleUtil.onTrigger("tooltip", hostEle, triggerEvt.close, function() {
                        if (tooltip) {
                            tooltip.close();
                        }
                    }, "close");
                }
            },
            _openTooltip: function(hostEle, tooltip) {
                var config = $TooltipUtil._getConfig(hostEle);
                if (!config) {
                    return tooltip;
                }
                var isInit = tooltip == null;
                tooltip = tooltip || new $Tooltip();
                tooltip.set(config);
                $callRAFLater(function() {
                    tooltip.open(hostEle);
                });
                if (isInit) {
                    $PopUpUtil.addDismissListener($ContentUtil.getContentElement(tooltip.get("content")), tooltip, "popover");
                }
                return tooltip;
            },
            _getConfig: function(hostEle) {
                var content;
                if (hostEle.hasAttribute("data-content")) {
                    content = hostEle.getAttribute("data-content");
                } else {
                    content = hostEle.getAttribute("title");
                    if (content) {
                        hostEle._tooltip_title = content;
                        hostEle.removeAttribute("title");
                    } else {
                        content = hostEle._tooltip_title;
                    }
                }
                if (!content) {
                    return null;
                }
                var delay;
                if (hostEle.hasAttribute("data-open-delay")) {
                    delay = {
                        open: hostEle.getAttribute("data-open-delay") | 0
                    };
                }
                if (hostEle.hasAttribute("data-close-delay")) {
                    if (!delay) {
                        delay = {
                            open: hostEle.getAttribute("data-close-delay") | 0
                        };
                    } else {
                        delay.close = hostEle.getAttribute("data-close-delay") | 0;
                    }
                }
                if (!delay) {
                    delay = hostEle.getAttribute("data-delay") | 0;
                }
                return {
                    title: hostEle.getAttribute("data-title"),
                    content: content,
                    direction: hostEle.getAttribute("data-direction") || "right",
                    delay: delay,
                    offset: hostEle.getAttribute("data-offset") | 0,
                    class: hostEle.getAttribute("data-class"),
                    close_on_click: hostEle.getAttribute("data-close-on-click") === "true"
                };
            }
        };
        var $Tooltip = function() {
            if (!(this instanceof $Tooltip)) {
                return $ClassUtil.createInstance($Tooltip, arguments);
            }
            $Tooltip.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-tooltip");
        };
        $extendClass($Tooltip, $IHostPopUpView, {
            __className_: "Tooltip"
        });
        var $PopoverUtil = {
            popover: function(hostEle, props) {
                return $HostPopUpUtil.hostPopup($Popover, "popover", hostEle, props);
            },
            close: function() {
                $PopUpUtil.closeAll("Popover");
            },
            popoverOn: function(hostEle, trigger, auto_close) {
                hostEle = $domQueryElement(hostEle);
                if (!hostEle) {
                    return;
                }
                $PopoverUtil._popoverOn(hostEle, trigger, auto_close);
            },
            toggleInit: function(rootEle) {
                $ToggleUtil.getToggleItems("popover", arguments).forEach(function(hostEle) {
                    $PopoverUtil._popoverOn(hostEle, hostEle.getAttribute("data-trigger"), hostEle.getAttribute("data-auto-close") !== "false");
                });
            },
            _popoverOn: function(hostEle, trigger, auto_close) {
                $ToggleUtil.clearToggleTrigger("popover", hostEle);
                var triggerEvt = $ToggleUtil.getTriggerEvent(trigger, "click");
                var popover;
                $ToggleUtil.onTrigger("popover", hostEle, triggerEvt.open, function() {
                    if ($PopUpUtil.isOpen(popover)) {
                        return;
                    }
                    popover = $PopoverUtil._openPopover(hostEle, popover);
                });
                if (auto_close !== false) {
                    $ToggleUtil.onTrigger("popover", hostEle, triggerEvt.close, function() {
                        if ($PopUpUtil.isOpen(popover)) {
                            popover.close();
                        }
                    }, "close");
                }
            },
            _openPopover: function(hostEle, popover) {
                var config = $PopoverUtil._getConfig(hostEle);
                if (!config) {
                    return popover;
                }
                var isInit = popover == null;
                popover = popover || new $Popover();
                popover.set(config);
                $callRAFLater(function() {
                    popover.open(hostEle);
                });
                if (isInit) {
                    $PopUpUtil.addDismissListener($ContentUtil.getContentElement(popover.get("content")), popover, "popover");
                }
                return popover;
            },
            _getConfig: function(hostEle) {
                var content = hostEle.getAttribute("data-content");
                if (!content) {
                    return null;
                }
                return {
                    title: hostEle.getAttribute("data-title"),
                    content: content,
                    direction: hostEle.getAttribute("data-direction") || "right",
                    offset: hostEle.getAttribute("data-offset") | 0,
                    class: hostEle.getAttribute("data-class"),
                    close_on_click: hostEle.getAttribute("data-close-on-click") === "true",
                    close_icon_visible: hostEle.getAttribute("data-close-icon-visible") === "true"
                };
            }
        };
        var $Popover = function() {
            if (!(this instanceof $Popover)) {
                return $ClassUtil.createInstance($Popover, arguments);
            }
            $Popover.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-popover");
        };
        $extendClass($Popover, $IHostPopUpView, {
            __className_: "Popover"
        });
        var $LoaderUtil = {
            loading: function(label, targetEle, props) {
                targetEle = $domQueryElement(targetEle) || document.body;
                if (arguments[0] === false) {
                    if (targetEle._z_loader) {
                        targetEle._z_loader.close();
                        delete targetEle._z_loader;
                    } else {
                        $LoaderUtil._clearTargetLoader(targetEle);
                    }
                    return;
                }
                var loader = targetEle._z_loader || new $Loader();
                loader.set($mergeObject({}, $ContentUtil.getLabelContent(label), props));
                targetEle._z_loader = loader;
                loader.open(targetEle);
                return loader;
            },
            _clearTargetLoader: function(targetEle) {
                var loaderArr = $DomQuery.querySelectorChildren(".z-loader", targetEle);
                loaderArr.forEach(function(loaderRoot) {
                    $domRemove(loaderRoot);
                });
            }
        };
        var $Loader = function() {
            if (!(this instanceof $Loader)) {
                return $ClassUtil.createInstance($Loader, arguments);
            }
            this._loadindDiv = $domCreate("div", "loading");
            $Loader.superClass.constructor.apply(this, arguments);
            this._loadindDiv.innerHTML = this.getProperty("loading_icon_template");
            this._bodyDiv.appendChild(this._loadindDiv);
            $domAddClass(this.getRoot(), "z-loader");
        };
        $extendClass($Loader, $IPopUpView, {
            __className_: "Loader",
            ___zdefaults_: {
                loading_icon_template: $CommonIconTemplate.loader,
                mask_visible: true
            },
            _onViewChange: function(key, value, old) {
                $Loader.superClass._onViewChange.apply(this, arguments);
                if (key === "loading_icon_template") {
                    this._loadindDiv.innerHTML = this.getProperty("loading_icon_template");
                }
            },
            open: function(targetEle) {
                targetEle = $domQueryElement(targetEle) || document.body;
                var root = this.getRoot();
                if (targetEle.lastElementChild !== root) {
                    $PopUpUtil.open(this, targetEle);
                } else {
                    this._setPopUpContent();
                }
            }
        });
        var $NotificationUtil = {
            notify: function(label, props) {
                if (label === false) {
                    $PopUpUtil.closeAll("Notification");
                    return;
                }
                if ($isObject(props)) {
                    label = $NotificationUtil._getTypeLabel(label, props.type);
                }
                var notification = new $Notification($mergeObject({}, props, $ContentUtil.getLabelContent(label)));
                notification.open();
                return notification;
            },
            _getTypeLabel: function(label, type) {
                label = label == null ? "" : label + "";
                if (type) {
                    var div = $domCreate("div", "ntype " + type);
                    var icon = $IconTemplate["notify_" + type] || "";
                    if (icon) {
                        div.innerHTML = "<span class='icon'>" + icon + "</span> <span>" + label + "</span>";
                    } else {
                        div.innerHTML = label;
                    }
                    return div.outerHTML;
                }
                return label;
            }
        };
        var $Notification = function() {
            if (!(this instanceof $Notification)) {
                return $ClassUtil.createInstance($Notification, arguments);
            }
            $Notification.superClass.constructor.apply(this, arguments);
            $domAddClass(this.getRoot(), "z-notification");
        };
        $extendClass($Notification, $IPopUpView, {
            __className_: "Notification",
            ___zdefaults_: {
                duration: $getDefault("WIDGET_NOTIFICATION_DURATION"),
                type: "",
                position: $getDefault("WIDGET_NOTIFICATION_POSITION"),
                direction: null,
                offset: 10,
                gap: 6,
                close_on_click: true,
                close_icon_visible: true,
                auto_focus: false
            },
            open: function() {
                var root = this.getRoot();
                var parent = document.body;
                var position = this.getProperty("position");
                var direction = this.getProperty("direction");
                var offset = this.getProperty("offset") | 0;
                var gap = this.getProperty("gap") | 0;
                $PopUpUtil.open(this, parent);
                var stackPosition = $PopUpDirectionUtil.getStackPosition("z-notification", root, parent, position, direction, offset, gap);
                $PopUpUtil.setPosition(root, stackPosition);
                var _direction = $PopUpDirectionUtil.getPositionDirection(position, direction);
                $PopUpDirectionUtil.setPositionClass(root, position, "top-right");
                $PopUpDirectionUtil.setDirectionClass(root, _direction, "to-down");
                var duration = this.getProperty("duration") | 0;
                if (duration > 0) {
                    this._laterID = $callLater(this.close, duration, this);
                }
            },
            _onClose: function() {
                this._laterID = null;
                $Notification.superClass._onClose.apply(this, arguments);
            }
        });
        var $ModalUtil = {
            modal: function(modalContentEle, props, parent) {
                modalContentEle = $domQueryElement(modalContentEle);
                if (!modalContentEle) {
                    return;
                }
                if (props === false) {
                    var modal = modalContentEle._$z_modal;
                    if (modal) {
                        $ModalUtil._closeModal(modalContentEle, modal);
                    }
                    return;
                }
                return $ModalUtil._openModal(modalContentEle, props, parent);
            },
            close: function(modalContentEle) {
                modalContentEle = $domQueryElement(modalContentEle);
                if (!modalContentEle) {
                    return;
                }
                var modal = modalContentEle._$z_modal;
                if (modal) {
                    $ModalUtil._closeModal(modalContentEle, modal);
                }
            },
            _openModal: function(modalContentEle, props, parent) {
                var modal = modalContentEle._$z_modal || new $Modal();
                var _props = {
                    content: modalContentEle
                };
                if (props) {
                    $eachObject(props, function(key, value) {
                        if ($isFunction(value)) {
                            modal[key] = value;
                        } else {
                            _props[key] = value;
                        }
                    });
                }
                modal.set(_props);
                modal.open(parent);
                if (!modalContentEle._$z_modal) {
                    $PopUpUtil.addDismissListener(modalContentEle, modal, "modal");
                    modalContentEle._$z_modal = modal;
                }
                return modal;
            },
            _closeModal: function(modalContentEle, modal) {
                modal.close();
                $PopUpUtil.removeDismissListener(modalContentEle, modal, "modal");
                delete modalContentEle._$z_modal;
            },
            modalOn: function(hostEle, trigger, auto_close) {
                hostEle = $domQueryElement(hostEle);
                if (!hostEle) {
                    return;
                }
                $ModalUtil._modalOn(hostEle, trigger, auto_close);
            },
            toggleInit: function(rootEle) {
                $ToggleUtil.getToggleItems("modal", arguments).forEach(function(hostEle) {
                    $ModalUtil._modalOn(hostEle, hostEle.getAttribute("data-trigger"), hostEle.getAttribute("data-auto-close") !== "false");
                });
            },
            _modalOn: function(hostEle, trigger, auto_close) {
                $ToggleUtil.clearToggleTrigger("modal", hostEle);
                var triggerEvt = $ToggleUtil.getTriggerEvent(trigger, "click");
                var modal;
                $ToggleUtil.onTrigger("modal", hostEle, triggerEvt.open, function() {
                    if ($PopUpUtil.isOpen(modal)) {
                        return;
                    }
                    modal = $ModalUtil._openHostModal(modal, hostEle);
                });
                if (auto_close !== false) {
                    $ToggleUtil.onTrigger("modal", hostEle, triggerEvt.close, function() {
                        if ($PopUpUtil.isOpen(modal)) {
                            modal.close();
                        }
                    }, "close");
                }
            },
            _openHostModal: function(modal, hostEle) {
                var config = $ModalUtil._getModalHostConfig(hostEle);
                if (!config) {
                    return modal;
                }
                var isInit = modal == null;
                modal = modal || new $Modal();
                modal.set(config);
                $callRAFLater(function() {
                    modal.open();
                });
                if (isInit) {
                    $PopUpUtil.addDismissListener($ContentUtil.getContentElement(modal.get("content")), modal, "modal");
                }
                return modal;
            },
            _getModalHostConfig: function(hostEle) {
                var content = hostEle.getAttribute("data-content");
                if (!content) {
                    return null;
                }
                return {
                    title: hostEle.getAttribute("data-title"),
                    content: content,
                    class: hostEle.getAttribute("data-class"),
                    close_on_click: hostEle.getAttribute("data-close-on-click") === "true",
                    close_on_click_outside: hostEle.getAttribute("data-close-on-click-outside") !== "false",
                    close_icon_visible: hostEle.getAttribute("data-close-icon-visible") === "true"
                };
            }
        };
        var $MessageBoxUtil = {
            alert: function(message, title, callBack, options) {
                return $MessageBoxUtil.box("alert", message, title, callBack, options);
            },
            confirm: function(message, title, callBack, options) {
                return $MessageBoxUtil.box("confirm", message, title, callBack, options);
            },
            prompt: function(message, title, callBack, options) {
                return $MessageBoxUtil.box("prompt", message, title, callBack, options);
            },
            box: function(type, message, title, callBack, options) {
                if (window.Promise) {
                    return new Promise(function(resolve, reject) {
                        $MessageBoxUtil._box(type, message, title, callBack, options, resolve, reject);
                    });
                }
                $MessageBoxUtil._box(type, message, title, callBack, options);
            },
            _box: function(type, message, title, callBack, options, promiseResolve, promiseReject) {
                var _callBack, _options;
                var arg3 = arguments[3];
                if ($isObject(arg3)) {
                    _options = arg3;
                    _callBack = arguments[4];
                } else if ($isFunction(arg3)) {
                    _options = arguments[4];
                    _callBack = arg3;
                }
                _options = $mergeObject({
                    confirm_class: $getDefault("WIDGET_MESSAGEBOX_CONFIRM_CLASS"),
                    cancel_class: $getDefault("WIDGET_MESSAGEBOX_CANCEL_CLASS"),
                    confirm_text: $getDefault("WIDGET_MESSAGEBOX_CONFIRM_TEXT"),
                    cancel_text: $getDefault("WIDGET_MESSAGEBOX_CANCEL_TEXT")
                }, _options);
                var promise = false;
                if (!_options.hasOwnProperty("promise")) {
                    if ((type === "confirm" || type === "prompt") && _callBack == null) {
                        promise = true;
                    }
                } else {
                    promise = _options.promise;
                }
                var isPrompt = type === "prompt";
                var result = isPrompt ? null : false;
                var isConfirm = false;
                var msg_cls = "z-message-box " + type + " " + (_options.class || "");
                var modalDiv = $domCreate("div", "zw-modal");
                var contentDiv = $domCreate("div", "content");
                if (title != null) {
                    contentDiv.innerHTML += "<div class='header'><span class='title'>" + title + "</span></div>";
                }
                var bodyDiv = $domCreate("div", "body");
                bodyDiv.innerHTML = message;
                if (isPrompt) {
                    var promptInput = $domCreate("input", _options.input_class || "");
                    promptInput.value = _options.value == null ? "" : _options.value;
                    $domOn(promptInput, "keydown", function(evt) {
                        if (evt.keyCode === 13) {
                            isConfirm = true;
                            result = $DomValue.getValue(promptInput);
                            $ModalUtil.modal(modalDiv, false);
                        }
                    });
                    bodyDiv.appendChild(promptInput);
                    promptInput.select();
                }
                contentDiv.appendChild(bodyDiv);
                var footerDiv = $domCreate("div", "footer");
                var confirmBtn = $domCreate("button", _options.confirm_class);
                confirmBtn.setAttribute("data-dismiss", "modal");
                confirmBtn.innerHTML = _options.confirm_text;
                footerDiv.appendChild(confirmBtn);
                if (promptInput) {
                    promptInput.setAttribute("autofocus", true);
                    promptInput.select();
                } else {
                    confirmBtn.setAttribute("autofocus", true);
                }
                if (type !== "alert") {
                    var cancelBtn = $domCreate("button", _options.cancel_class);
                    cancelBtn.setAttribute("data-dismiss", "modal");
                    cancelBtn.innerHTML = _options.cancel_text;
                    footerDiv.appendChild(cancelBtn);
                }
                contentDiv.appendChild(footerDiv);
                modalDiv.appendChild(contentDiv);
                $domOn(confirmBtn, "click", function() {
                    isConfirm = true;
                    if (isPrompt) {
                        result = $DomValue.getValue(promptInput);
                    } else {
                        result = true;
                    }
                });
                var props = {
                    close_on_click_outside: _options.close_on_click_outside !== true,
                    close_on_press_escape: true,
                    class: msg_cls
                };
                if (_callBack || promiseResolve) {
                    props.onClose = function() {
                        if (_callBack) {
                            _callBack(result);
                        }
                        if (promise === true && promiseResolve) {
                            if (isConfirm === true) {
                                promiseResolve(result);
                            } else {
                                promiseReject(result);
                            }
                        }
                    };
                }
                $ModalUtil.modal(modalDiv, props);
            }
        };
        var $Modal = function() {
            if (!(this instanceof $Modal)) {
                return $ClassUtil.createInstance($Modal, arguments);
            }
            $Modal.superClass.constructor.apply(this, arguments);
            $domRemove(this._bodyDiv);
            $domRemove(this._headerDiv);
            $domAddClass(this.getRoot(), "z-modal");
        };
        $extendClass($Modal, $IPopUpView, {
            __className_: "Modal",
            ___zdefaults_: {
                mask_visible: true,
                release_on_close: true,
                close_on_click_outside: true,
                open_animation: $getDefault("WIDGET_MODAL_OPEN_ANIMATION"),
                close_animation: $getDefault("WIDGET_MODAL_CLOSE_ANIMATION")
            },
            open: function(parent) {
                parent = $domQueryElement(parent) || document.body;
                $PopUpUtil.open(this, parent);
            },
            getContentContainer: function() {
                return this.getRoot();
            }
        });
        $mergeObject(z.$, {
            widget: {
                DefaultController: $DefaultController,
                HoverController: $HoverController,
                ContentInterface: $ContentInterface,
                DataContentInterface: $DataContentInterface,
                LevelCheckInterface: $LevelCheckInterface,
                LevelListViewInterface: $LevelListViewInterface,
                ListViewInterface: $ListViewInterface,
                HostPopUpUtil: $HostPopUpUtil,
                IHostPopUpView: $IHostPopUpView,
                IPopUpView: $IPopUpView,
                PopUpController: $PopUpController,
                PopUpDirectionUtil: $PopUpDirectionUtil,
                PopUpUtil: $PopUpUtil,
                ToggleUtil: $ToggleUtil,
                IDataULLevelView: $IDataULLevelView,
                IDataULListView: $IDataULListView,
                IDataULView: $IDataULView,
                IDataULLevelRenderer: $IDataULLevelRenderer,
                IDataULRenderer: $IDataULRenderer,
                IDataWidgetRenderer: $IDataWidgetRenderer,
                IDataWidgetView: $IDataWidgetView,
                ContentUtil: $ContentUtil,
                HTMLWidgetParser: $HTMLWidgetParser,
                LevelListViewRenderUtil: $LevelListViewRenderUtil,
                LevelViewRenderUtil: $LevelViewRenderUtil,
                LevelViewVisibleUtil: $LevelViewVisibleUtil,
                ListViewRenderUtil: $ListViewRenderUtil,
                RenderNodeUtil: $RenderNodeUtil,
                WAnimationUtil: $WAnimationUtil,
                WViewUtil: $WViewUtil
            }
        });
        z.widget = {
            ListView: $ListView,
            Tabs: $Tabs,
            Tree: $Tree,
            Collapse: $Collapse,
            Pagination: $Pagination,
            Grid: $Grid,
            TreeGrid: $TreeGrid,
            Menu: $Menu,
            Tooltip: $Tooltip,
            Popover: $Popover,
            Loader: $Loader,
            Notification: $Notification,
            tooltip: $TooltipUtil.tooltipOn,
            popover: $PopoverUtil.popoverOn,
            modal: $ModalUtil.modal,
            alert: $MessageBoxUtil.alert,
            confirm: $MessageBoxUtil.confirm,
            prompt: $MessageBoxUtil.prompt,
            loading: $LoaderUtil.loading,
            notify: $NotificationUtil.notify,
            $interface: {
                DataContentInterface: $DataContentInterface
            }
        };
        z.widget.tooltip.init = $TooltipUtil.toggleInit;
        z.widget.tooltip.open = $TooltipUtil.tooltip;
        z.widget.tooltip.close = $TooltipUtil.close;
        z.widget.popover.init = $PopoverUtil.toggleInit;
        z.widget.popover.open = $PopoverUtil.popover;
        z.widget.popover.close = $PopoverUtil.close;
        z.widget.modal.init = $ModalUtil.toggleInit;
        z.widget.modal.on = $ModalUtil.modalOn;
    })(window);
    (function(window, undefined) {
        $setSysDefault({
            FORM_VALIDATOR_RULES_ATTRIBUTE: "v-rules",
            FORM_VALIDATOR_ATTRIBUTE_PREFIX: "v-",
            FORM_VALIDATOR_MESSAGE_FOR_ATTRIBUTE: "v-message-for",
            FORM_VALIDATOR_INVALID_CLASS: "z-validator-invalid",
            FORM_VALIDATOR_MESSAGE_CLASS: "z-validator-message",
            FORM_FORM_MODEL_ATTRIBUTE: "ze-model",
            FORM_FORM_MODEL_TYPE_ATTRIBUTE: "ze-model-type",
            FORM_FORM_MODEL_RESET: "ze-reset",
            FORM_FORM_MODEL_EXCLUDE: "ze-exclude",
            FORM_FORM_MODEL_FOR: "for-ze-model",
            FORM_FORM_VISIBLE_ATTRIBUTE: "ze-visible",
            FORM_FORM_HIDDEN_ATTRIBUTE: "ze-hidden",
            FORM_FORM_DISABLED_ATTRIBUTE: "ze-disabled",
            FORM_FORM_ATTRIBUTE_REGEX: null,
            FORM_FORM_EVENT_ATTRIBUTE: "ze-on"
        });
        var $FormUtil = {
            isVisible: function(ele) {
                return $domGetStyle(ele, "display") !== "none" && $domGetStyle(ele, "visibility") !== "hidden" && ele.offsetWidth > 0 && ele.offsetHeight > 0;
            },
            show: function(ele, byVisibility, visibleCSS) {
                if (byVisibility !== true) {
                    if ($domGetStyle(ele, "display") === "none") {
                        var displayValue;
                        if (visibleCSS && visibleCSS !== "none") {
                            displayValue = visibleCSS;
                        } else if (ele._$z_default_display && ele._$z_default_display !== "none") {
                            displayValue = ele._$z_default_display;
                        } else {
                            displayValue = "";
                        }
                        $domSetStyle(ele, "display", displayValue);
                    }
                    delete ele._$z_default_display;
                } else {
                    if ($domGetStyle(ele, "visibility") === "hidden") {
                        var visibilityValue;
                        if (visibleCSS && visibleCSS !== "hidden") {
                            visibilityValue = visibleCSS;
                        } else if (ele._$z_default_visibility && ele._$z_default_visibility !== "hidden") {
                            visibilityValue = ele._$z_default_visibility;
                        } else {
                            visibilityValue = "visible";
                        }
                        $domSetStyle(ele, "visibility", visibilityValue);
                    }
                    delete ele._$z_default_visibility;
                }
            },
            hide: function(ele, byVisibility) {
                if (byVisibility !== true) {
                    ele._$z_default_display = $domGetStyle(ele, "display");
                    $domSetStyle(ele, "display", "none");
                } else {
                    ele._$z_default_visibility = $domGetStyle(ele, "visibility");
                    $domSetStyle(ele, "visibility", "hidden");
                }
            },
            disable: function(ele) {
                ele.setAttribute("disabled", "");
            },
            enable: function(ele) {
                ele.removeAttribute("disabled");
            }
        };
        var $ValDefaultMsg = {
            required: "The field is required",
            integer: "The field must be an integer",
            numeric: "The field must contain only numbers",
            alphanumeric: "The field must only contain alpha-numeric characters",
            alphanumeric_dash: "The field must only contain alpha-numeric characters, underscores and dashes",
            alphanumeric_space: "The field must only contain alpha-numeric characters and space characters",
            email: "The field must be a valid email address",
            ipv4: "The field must be a valid IP",
            minlength: "The field must be at least %p characters in length",
            maxlength: "The field must not exceed %p characters in length",
            greaterthan: "The field must contain a number greater than %p",
            lessthan: "The field must contain a number less than %p",
            equal: "The field must be equal to %p",
            match: "The field must match %p field"
        };
        var $ValMsgUtil = {
            appendMessages: function(form, errItems, msgConfig) {
                if (msgConfig === false) {
                    return;
                }
                $ValMsgUtil.clearMessage(form, msgConfig);
                errItems.forEach(function(errItem) {
                    $ValMsgUtil._appendMessageItem(form, errItem, msgConfig);
                });
            },
            appendMessageItem: function(form, errItem, msgConfig) {
                if (msgConfig === false) {
                    return;
                }
                var element = errItem.element;
                $ValMsgUtil._removeMessageItem(form, element, msgConfig);
                $ValMsgUtil._appendMessageItem(form, errItem, msgConfig);
            },
            _appendMessageItem: function(form, errItem, msgConfig) {
                var message = errItem.message;
                var ele = errItem.element;
                var msgCls = msgConfig.message_class;
                var inValCls = msgConfig.invalid_class;
                var container = msgConfig.container;
                $domAddClass(ele, inValCls);
                var msgEle;
                var msgTag;
                if (container) {
                    if ($domIsTagType(container, "UL") || $domIsTagType(container, "OL")) {
                        msgTag = "li";
                    } else {
                        msgTag = "span";
                    }
                    msgEle = $domCreate(msgTag, msgCls);
                } else {
                    var forEle = $ValMsgUtil._getMessageEle(ele, form, msgCls);
                    if (forEle) {
                        msgEle = forEle;
                    } else {
                        msgTag = "span";
                    }
                }
                if (msgTag) {
                    msgEle = $domCreate(msgTag, msgCls);
                    ele._val_msg_ele = msgEle;
                    if (container) {
                        container.appendChild(msgEle);
                    } else {
                        z.dom.insertAfter(msgEle, ele);
                    }
                }
                msgEle.innerHTML = message == null ? "" : message;
            },
            removeMessageItem: function(form, ele, msgConfig) {
                if (msgConfig === false) {
                    return;
                }
                $ValMsgUtil._removeMessageItem(form, ele, msgConfig);
            },
            _removeMessageItem: function(form, ele, msgConfig) {
                var inValCls = msgConfig.invalid_class;
                var msgCls = msgConfig.message_class;
                $domRemoveClass(ele, inValCls);
                var msgEle = ele._val_msg_ele;
                if (msgEle) {
                    $domRemove(msgEle);
                    delete ele._val_msg_ele;
                } else {
                    var forEle = $ValMsgUtil._getMessageEle(ele, form, msgCls);
                    if (forEle) {
                        $domEmpty(forEle);
                    }
                }
            },
            _getMessageEle: function(ele, form, msgCls) {
                var msgEle;
                var name = ele.getAttribute("name");
                if (name) {
                    msgEle = $domQueryElement($domGetAttrSelector($getDefault("FORM_VALIDATOR_MESSAGE_FOR_ATTRIBUTE"), name), form);
                }
                if (!msgEle) {
                    var model = ele.getAttribute($getDefault("FORM_FORM_MODEL_ATTRIBUTE"));
                    if (model) {
                        msgEle = $domQueryElement($domGetAttrSelector($getDefault("FORM_VALIDATOR_MESSAGE_FOR_ATTRIBUTE"), model), form);
                    }
                }
                if (!msgEle) {
                    var nextEle = ele.nextElementSibling;
                    if (nextEle && $domContainsClass(nextEle, msgCls)) {
                        msgEle = nextEle;
                    }
                }
                return msgEle;
            },
            clearMessage: function(form, msgConfig) {
                if (msgConfig === false) {
                    return;
                }
                var container = msgConfig.container;
                if (container) {
                    $domEmpty(container);
                }
                var inValCls = "." + msgConfig.invalid_class;
                $domQueryAll(inValCls, form).forEach(function(ele) {
                    $ValMsgUtil._removeMessageItem(form, ele, msgConfig);
                });
            }
        };
        $mergeObject($ValMsgUtil, {
            getMessageText: function(rulesItem, valRuleName, param) {
                var msg;
                if (rulesItem.hasOwnProperty("message")) {
                    msg = rulesItem.message;
                } else if (valRuleName) {
                    msg = $ValDefaultMsg[valRuleName];
                }
                if (msg) {
                    var field = rulesItem.name;
                    msg = msg.replace("%f", field || "");
                    return msg.replace("%p", param || "");
                }
                return null;
            },
            registerMessage: function(ruleName, message) {
                if ($isObject(ruleName)) {
                    $eachObject(ruleName, function(key, value) {
                        $ValMsgUtil._registerMessage(key, value);
                    });
                } else {
                    $ValMsgUtil._registerMessage(ruleName, message);
                }
            },
            _registerMessage: function(ruleName, message) {
                if (message == null) {
                    delete $ValDefaultMsg[ruleName];
                } else {
                    $ValDefaultMsg[ruleName] = message;
                }
            }
        });
        var $ValRuleRegex = {
            RULE_REGEX: /^(.+?)\[(.+)\]$/,
            INTEGER: /^-?\d+$/,
            NUMERIC: /^-?\d*\.?\d+$/,
            ALPHANUMERIC: /^[a-zA-Z0-9]+$/,
            ALPHANUMERIC_DASH: /^[a-zA-Z0-9_\-]+$/,
            ALPHANUMERIC_SPACE: /^[a-zA-Z0-9 ]+$/,
            MAIL: /^([\w.+-]+)@([\da-zA-Z.-]+)\.([a-zA-Z.]{2,})$/,
            IPV4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
        };
        var $ValRuleDomUtil = {
            queryRulesItemEle: function(item, form) {
                var ele;
                if (item.hasOwnProperty("element")) {
                    ele = item.element;
                } else if (item.hasOwnProperty("selector")) {
                    ele = $domQueryElement(item.selector, form);
                } else if (item.hasOwnProperty("id")) {
                    ele = document.getElementById(item.id);
                } else if (item.hasOwnProperty("name")) {
                    ele = $domQueryElement($domGetAttrSelector("name", item.name), form);
                }
                return ele;
            },
            getDomRules: function(form) {
                var rules = [];
                var attPrefix = $getDefault("FORM_VALIDATOR_ATTRIBUTE_PREFIX");
                var attPrefixLen = attPrefix.length;
                $domQueryAll("[" + $getDefault("FORM_VALIDATOR_RULES_ATTRIBUTE") + "]", form).forEach(function(ruleEle) {
                    var item = {
                        element: ruleEle
                    };
                    $eachObject(z.dom.getAttributes(ruleEle), function(name, value) {
                        if (name === "name") {
                            item[name] = value;
                        }
                        if (name.startsWith(attPrefix)) {
                            item[name.substring(attPrefixLen)] = value;
                        }
                    });
                    rules.push(item);
                });
                return rules;
            }
        };
        var $ValRules = {
            required: function(ele) {
                var value = $domGetValue(ele);
                if ($isBoolean(value)) {
                    return value === true;
                }
                if ($isString(value)) {
                    return value.trim() !== "";
                }
                if (value instanceof FileList) {
                    return value.length > 0;
                }
                return value != null;
            },
            integer: function(ele) {
                return $ValRuleRegex.INTEGER.test($domGetValue(ele));
            },
            numeric: function(ele) {
                return $ValRuleRegex.NUMERIC.test($domGetValue(ele));
            },
            alphanumeric: function(ele) {
                return $ValRuleRegex.ALPHANUMERIC.test($domGetValue(ele));
            },
            alphanumeric_dash: function(ele) {
                return $ValRuleRegex.ALPHANUMERIC_DASH.test($domGetValue(ele));
            },
            alphanumeric_space: function(ele) {
                return $ValRuleRegex.ALPHANUMERIC_SPACE.test($domGetValue(ele));
            },
            email: function(ele) {
                return $ValRuleRegex.MAIL.test($domGetValue(ele));
            },
            ipv4: function(ele) {
                return $ValRuleRegex.IPV4.test($domGetValue(ele));
            },
            minlength: function(ele, arg) {
                var value = $domGetValue(ele);
                if ($isString(value)) {
                    value = value.trim();
                    return value.length >= arg;
                }
                return false;
            },
            maxlength: function(ele, arg) {
                var value = $domGetValue(ele);
                if ($isString(value)) {
                    value = value.trim();
                    return value.length <= arg;
                }
                return false;
            },
            greaterthan: function(ele, arg) {
                var val = $domGetValue(ele);
                if (!$ValRules._isNumeric(val)) {
                    return false;
                }
                return +val > +$ValRules._getCompareValue(arg);
            },
            lessthan: function(ele, arg) {
                var val = $domGetValue(ele);
                if (!$ValRules._isNumeric(val)) {
                    return false;
                }
                return +val < +$ValRules._getCompareValue(arg);
            },
            equal: function(ele, arg) {
                return $domGetValue(ele) === $ValRules._getCompareValue(arg);
            },
            match: function(ele, arg) {
                return $domGetValue(ele) === $ValRules._getCompareValue(arg);
            },
            _isNumeric: function(val) {
                return $ValRuleRegex.NUMERIC.test(val);
            },
            _getCompareValue: function(arg) {
                if ($ValRules._isNumeric(arg)) {
                    return arg;
                }
                try {
                    var argEle = $domQueryElement(arg) || $domQueryElement($domGetAttrSelector("name", arg));
                    if (argEle) {
                        return $domGetValue(argEle);
                    }
                } catch (err) {}
                return arg;
            }
        };
        var $ValRuleUtil = {
            registerRule: function(ruleName, valMethod, ruleMsg) {
                if ($isFunction(valMethod)) {
                    $ValRules[ruleName] = valMethod;
                }
                if (ruleMsg) {
                    $ValMsgUtil.registerMessage(ruleName, ruleMsg);
                }
            },
            getRulesValMethodArray: function(rules) {
                var arr = [];
                if ($isString(rules)) {
                    arr = rules.split("|");
                } else if ($isArray(rules)) {
                    arr = rules;
                }
                var arrFun = [];
                arr.forEach(function(item) {
                    if ($isString(item)) {
                        var items = $ValRuleRegex.RULE_REGEX.exec(item);
                        var ruleName, param;
                        if (items) {
                            ruleName = items[1];
                            param = items[2];
                        } else {
                            ruleName = item;
                        }
                        var ruleMethod = $ValRules[ruleName];
                        if (ruleMethod) {
                            arrFun.push({
                                rule_name: ruleName,
                                method: ruleMethod,
                                param: param
                            });
                        }
                    } else if ($isFunction(item)) {
                        arrFun.push({
                            method: item
                        });
                    }
                });
                return arrFun;
            }
        };
        var $ValUtil = {
            validate: function(form, rules, config) {
                form = $domQueryElement(form);
                if (!form) {
                    return [];
                }
                var _config = $ValUtil._getConfig(config);
                config = _config.config;
                var msgConfig = _config.msg_config;
                var allRules = $mergeArray($ValRuleDomUtil.getDomRules(form), rules);
                var errArray = $ValUtil.doValidate(form, allRules);
                $ValMsgUtil.appendMessages(form, errArray, msgConfig);
                if (config.autofocus !== false) {
                    var first = errArray[0];
                    if (first) {
                        $callLater(function() {
                            first.element.focus();
                        }, 60);
                    }
                }
                return errArray;
            },
            reset: function(form, config) {
                form = $domQueryElement(form);
                if (!form) {
                    return [];
                }
                var _config = $ValUtil._getConfig(config);
                config = _config.config;
                var msgConfig = _config.msg_config;
                $ValMsgUtil.clearMessage(form, msgConfig);
            },
            _getConfig: function(config) {
                var _config = $mergeObject({
                    invalid_class: $getDefault("FORM_VALIDATOR_INVALID_CLASS"),
                    message_class: $getDefault("FORM_VALIDATOR_MESSAGE_CLASS"),
                    visible_only: true,
                    autofocus: true
                }, config);
                return {
                    config: _config,
                    msg_config: _config.message === false ? false : {
                        container: $domQueryElement(_config.message_container),
                        invalid_class: _config.invalid_class,
                        message_class: _config.message_class
                    }
                };
            },
            doValidate: function(form, allRules, visible_only) {
                var errArray = [];
                var errEleArray = [];
                allRules.forEach(function(rulesItem) {
                    var ele = $ValRuleDomUtil.queryRulesItemEle(rulesItem, form);
                    if (!ele) {
                        return;
                    }
                    if (visible_only !== false && !$FormUtil.isVisible(ele)) {
                        return;
                    }
                    if (errEleArray.indexOf(ele) >= 0) {
                        return;
                    }
                    var errItem = $ValUtil.doValidateRulesItem(ele, rulesItem);
                    if (errItem) {
                        errArray.push(errItem);
                        errEleArray.push(errItem.element);
                    }
                });
                return errArray;
            },
            doValidateRulesItem: function(element, rulesItem) {
                var errItem;
                $eachArray($ValRuleUtil.getRulesValMethodArray(rulesItem.rules), function(valRuleItem) {
                    var method = valRuleItem.method;
                    var param = valRuleItem.param;
                    if (method(element, param) === false) {
                        var rule_name = valRuleItem.rule_name;
                        errItem = {
                            reason: rule_name,
                            element: element,
                            message: $ValMsgUtil.getMessageText(rulesItem, rule_name, param),
                            rule: rulesItem
                        };
                        return false;
                    }
                });
                return errItem;
            }
        };
        var $Validator = function(form, rules, opts) {
            if (!(this instanceof $Validator)) {
                return $ClassUtil.createInstance($Validator, arguments);
            }
            this._rules = [];
            $Validator.superClass.constructor.apply(this, [ opts ]);
            this.set("form", form);
            if (rules) {
                this.set("rules", rules);
            }
        };
        $extendClass($Validator, $ChangeSupport, {
            ___zdefaults_: {
                invalid_class: $getDefault("FORM_VALIDATOR_INVALID_CLASS"),
                message_class: $getDefault("FORM_VALIDATOR_MESSAGE_CLASS"),
                visible_only: true,
                autofocus: true
            },
            afterSetProperty: function(key, value, old) {
                $Validator.superClass.afterSetProperty.apply(this, arguments);
                switch (key) {
                    case "rules":
                        this.reset();
                        this._doRulesUpdate();
                        break;

                    case "form":
                        this.reset();
                        this._doFormUpdate(value);
                        break;

                    case "message":
                        this.reset();
                        break;

                    case "message_container":
                        this.reset();
                        break;

                    case "invalid_class":
                        this.reset();
                        break;

                    case "message_class":
                        this.reset();
                        break;

                    case "visible_only":
                        this.reset();
                        break;
                }
            },
            _doFormUpdate: function(form) {
                this.reset();
                this._setRuleEleChangeListener("off");
                this._form = $domQueryElement(form);
                this._doRulesUpdate();
            },
            update: function() {
                if (this._form) {
                    this.reset();
                    this._doRulesUpdate();
                }
            },
            _doRulesUpdate: function() {
                if (!this._form) {
                    return;
                }
                this._setRuleEleChangeListener("off");
                this._rules = $mergeArray($ValRuleDomUtil.getDomRules(this._form), this.get("rules"));
                this._setRuleEleChangeListener("on");
            },
            _setRuleEleChangeListener: function(type) {
                if (!this._form) {
                    return;
                }
                var form = this._form;
                var eleArray = [];
                this._rules.forEach(function(item) {
                    var ele = $ValRuleDomUtil.queryRulesItemEle(item, form);
                    if (!ele) {
                        return;
                    }
                    if (eleArray.indexOf(ele) >= 0) {
                        return;
                    }
                    eleArray.push(ele);
                    var evtType = this._getChangeEvent(ele);
                    if (type === "on") {
                        $domOn(ele, evtType, this._handleChange, this);
                    } else {
                        $domOff(ele, evtType, this._handleChange, this);
                    }
                }, this);
            },
            _getChangeEvent: function(ele) {
                var evtType = this.getChangeEvent(ele);
                if (evtType) {
                    return evtType;
                }
                if ($DomType.isInput(ele)) {
                    var type = ele.getAttribute("type");
                    if (type == null || type === "text" || type === "email" || type === "password" || type === "number" || type === "url") {
                        return "input";
                    }
                } else if ($DomType.isTextArea(ele)) {
                    return "input";
                }
                return "change";
            },
            getChangeEvent: function(ele) {},
            _handleChange: function(evt) {
                if (!this._form) {
                    return;
                }
                var evtTarget = evt.target;
                var errArray = $ValUtil.doValidate(this._form, this._rules, this.getProperty("visible_only"));
                var currentItem = $findArray(errArray, function(errItem) {
                    return errItem.element === evtTarget;
                });
                if (currentItem) {
                    $ValMsgUtil.appendMessageItem(this._form, currentItem, this._getMessageConfig());
                } else {
                    $ValMsgUtil.removeMessageItem(this._form, evtTarget, this._getMessageConfig());
                }
                this._onValidate(errArray, currentItem, evt);
            },
            _onValidate: function(errArray, currentItem, evt) {
                this._callOn("onValidate", "on.validate", {
                    errors: errArray,
                    current: currentItem,
                    event: evt
                }, [ errArray, currentItem, evt ]);
            },
            _callOn: function(onCallBack, onEventType, onEvent, callBackArgs) {
                var _onCallBack = this[onCallBack];
                if (_onCallBack === this.constructor.prototype[onCallBack]) {
                    this.dispatchEvent(onEventType, onEvent);
                } else {
                    _onCallBack.apply(this, callBackArgs);
                }
            },
            onValidate: function(listener, thisArg) {
                this.addListener("on.validate", listener, thisArg);
            },
            _getMessageConfig: function() {
                if (this.get("message") === false) {
                    return false;
                }
                return {
                    container: $domQueryElement(this.get("message_container")),
                    invalid_class: this.get("invalid_class"),
                    message_class: this.get("message_class")
                };
            },
            reset: function() {
                if (!this._form) {
                    return;
                }
                $ValMsgUtil.clearMessage(this._form, this._getMessageConfig());
            },
            validate: function() {
                if (!this._form) {
                    return;
                }
                var errArray = $ValUtil.doValidate(this._form, this._rules, this.getProperty("visible_only"));
                $ValMsgUtil.appendMessages(this._form, errArray, this._getMessageConfig());
                if (this.get("autofocus") !== false) {
                    var first = errArray[0];
                    if (first) {
                        $callLater(function() {
                            first.element.focus();
                        }, 60);
                    }
                }
                return errArray;
            },
            registerRule: function(ruleName, valMethod, ruleMsg) {
                return $ValRuleUtil.registerRule(ruleName, valMethod, ruleMsg);
            },
            registerRuleMessage: function(ruleName, message) {
                return $ValMsgUtil.registerMessage(ruleName, message);
            }
        });
        var $FormValueConverter = {
            integer: function(value) {
                if (value == null) {
                    return null;
                }
                value = value.trim();
                if (!/^-?\d+$/.test(value)) {
                    return null;
                }
                return value | 0;
            },
            array: function(value) {
                if (value == null) {
                    return null;
                }
                return $filterArray(value.split(","), function(v) {
                    return v.trim() !== "";
                });
            }
        };
        var $FormValue = {
            set: function(form, value) {
                $FormValue._set(form, value);
            },
            get: function(form, exclude) {
                var values = {};
                var excludeAttr = $getDefault("FORM_FORM_MODEL_EXCLUDE");
                $eachObject($FormValue._queryModelEleMap(form), function(model, eleArr) {
                    if (exclude === true) {
                        eleArr = $filterArray(eleArr, function(ele) {
                            return !$FormValue._isExclude(ele, excludeAttr);
                        });
                    }
                    var mv;
                    if (eleArr.length === 1) {
                        mv = $FormValue._getEleValue(eleArr[0]);
                    } else {
                        mv = [];
                        eleArr.forEach(function(ele) {
                            mv.push($FormValue._getEleValue(ele));
                        });
                    }
                    $setObjectDeepValue(values, model, mv);
                });
                return values;
            },
            clear: function(form) {
                $FormValue._set(form, null, true);
            },
            _isExclude: function(ele, excludeAttr) {
                return ele.hasOwnProperty(excludeAttr) && ele.getAttribute(excludeAttr) !== "false";
            },
            _queryModelEleMap: function(form) {
                var modelAttr = $getDefault("FORM_FORM_MODEL_ATTRIBUTE");
                var modelEleMap = {};
                $domQueryAll("[" + modelAttr + "]", form).forEach(function(ele) {
                    var model = ele.getAttribute(modelAttr).trim();
                    if (model) {
                        var eleArr = modelEleMap[model];
                        if (!eleArr) {
                            eleArr = [];
                            modelEleMap[model] = eleArr;
                        }
                        eleArr.push(ele);
                    }
                });
                return modelEleMap;
            },
            _set: function(form, value, clear) {
                if (clear !== true && !$isObject(value)) {
                    value = {};
                }
                $eachObject($FormValue._queryModelEleMap(form), function(model, eleArr) {
                    var eleValue;
                    var resetAttr = null;
                    if (clear === true) {
                        eleValue = "";
                    } else {
                        eleValue = $getObjectDeepValue(value, model);
                        if (eleValue == null) {
                            eleValue = "";
                            if (!$hasObjectDeepValue(value, model)) {
                                resetAttr = $getDefault("FORM_FORM_MODEL_RESET");
                            }
                        }
                    }
                    if (eleArr.length === 1) {
                        $FormValue._setEleValue(eleArr[0], eleValue, resetAttr);
                    } else {
                        if ($isArray(eleValue)) {
                            eleArr.forEach(function(ele, index) {
                                var v = eleValue[index];
                                if (v == null) {
                                    v = "";
                                }
                                $FormValue._setEleValue(ele, v, resetAttr);
                            });
                        } else {
                            eleArr.forEach(function(ele) {
                                $FormValue._setEleValue(ele, eleValue, resetAttr);
                            });
                        }
                    }
                });
            },
            _setEleValue: function(ele, eleValue, resetAttr) {
                if (resetAttr != null && ele.getAttribute(resetAttr) === "false") {
                    return;
                }
                $domSetValue(ele, eleValue);
            },
            _getEleValue: function(ele) {
                var value = $domGetValue(ele);
                var converter = $FormValueConverter[ele.getAttribute($getDefault("FORM_FORM_MODEL_TYPE_ATTRIBUTE"))];
                if (converter) {
                    value = converter(value);
                }
                return value;
            }
        };
        var $FormStatus = {
            updateStatus: function(form, value) {
                $FormStatus.updateVisible(form, value);
                $FormStatus.updateDisable(form, value);
            },
            updateVisible: function(form, value) {
                $FormStatus._doUpdate(form, $getDefault("FORM_FORM_VISIBLE_ATTRIBUTE"), value, function(ele, value) {
                    if (value === true) {
                        $FormUtil.show(ele);
                    } else {
                        $FormUtil.hide(ele);
                    }
                });
                $FormStatus._doUpdate(form, $getDefault("FORM_FORM_HIDDEN_ATTRIBUTE"), value, function(ele, value) {
                    if (value === true) {
                        $FormUtil.hide(ele);
                    } else {
                        $FormUtil.show(ele);
                    }
                });
            },
            updateDisable: function(form, value) {
                $FormStatus._doUpdate(form, $getDefault("FORM_FORM_DISABLED_ATTRIBUTE"), value, function(ele, value) {
                    if (value === true) {
                        $FormUtil.disable(ele);
                    } else {
                        $FormUtil.enable(ele);
                    }
                });
            },
            _doUpdate: function(root, mark, value, callBack) {
                $domQueryAll("[" + mark + "]", root).forEach(function(ele) {
                    var condition = (ele.getAttribute(mark) || "").trim();
                    if (condition) {
                        callBack(ele, $Util.exec(condition, value, $getDefault("FORM_FORM_ATTRIBUTE_REGEX")));
                    }
                });
            }
        };
        var $FormChange = {
            addFormChangeListener: function(form, callBack, thisArg) {
                $domQueryAll("[" + $getDefault("FORM_FORM_MODEL_ATTRIBUTE") + "]", form).forEach(function(ele) {
                    $domOn(ele, "change", callBack, thisArg);
                });
            },
            removeFormChangeListener: function(form, callBack, thisArg) {
                $domQueryAll("[" + $getDefault("FORM_FORM_MODEL_ATTRIBUTE") + "]", form).forEach(function(ele) {
                    $domOff(ele, "change", callBack, thisArg);
                });
            }
        };
        var $Form = function(form, opts) {
            if (!(this instanceof $Form)) {
                return $ClassUtil.createInstance($Form, arguments);
            }
            $Form.superClass.constructor.apply(this, [ opts ]);
            this.set("form", form);
            this._doValidateUpdate();
            this._updateStatus();
        };
        $extendClass($Form, $ChangeSupport, {
            ___zdefaults_: {
                validate: true
            },
            afterSetProperty: function(key, value, old) {
                $Form.superClass.afterSetProperty.apply(this, arguments);
                switch (key) {
                    case "form":
                        this._doFormUpdate(value);
                        break;

                    case "validate":
                        this._doValidateUpdate();
                        break;
                }
            },
            update: function() {
                if (this._form) {
                    $FormChange.removeFormChangeListener(this._form, this._handleFormModelElementChange, this);
                    $FormChange.addFormChangeListener(this._form, this._handleFormModelElementChange, this);
                    this._updateStatus();
                }
                if (this._validator) {
                    this._validator.update();
                }
            },
            _doFormUpdate: function(form) {
                if (this._form) {
                    $FormChange.removeFormChangeListener(this._form, this._handleFormModelElementChange, this);
                    $FormFor.removeForListener(this._form);
                }
                this._form = $domQueryElement(form);
                if (this._validator) {
                    this._validator.set("form", this._form);
                }
                if (this._form) {
                    $FormChange.addFormChangeListener(this._form, this._handleFormModelElementChange, this);
                    $FormFor.addForListener(this._form);
                }
            },
            _doValidateUpdate: function() {
                if (this.getProperty("validate") !== false) {
                    if (!this._validator) {
                        this._validator = $Validator(this._form);
                    }
                } else if (this._validator) {
                    this._validator.set("form", null);
                    delete this._validator;
                }
            },
            _handleFormModelElementChange: function(evt) {
                this._updateStatus();
                this._callOn("onFormChange", "on.form.change", evt, [ evt ]);
            },
            onFormChange: function(listener, context) {
                this.addListener("on.form.change", listener, context);
            },
            _updateStatus: function(value) {
                $FormStatus.updateStatus(this._form, $mergeObject(this._getValue(), value));
            },
            _getValue: function() {
                if (!this._form) {
                    return {};
                }
                return $FormValue.get(this._form);
            },
            setValue: function(value) {
                if (!this._form) {
                    return;
                }
                value = $mergeObject({}, value);
                $FormValue.set(this._form, value);
                this._updateStatus(value);
                if (this._validator) {
                    this._validator.reset();
                }
            },
            getValue: function(validate) {
                if (validate === false) {
                    return this._getValue();
                }
                if (!this._form) {
                    return null;
                }
                if (this._validator) {
                    var errorArr = this._validator.validate();
                    if (errorArr.length > 0) {
                        return null;
                    }
                }
                return $FormValue.get(this._form);
            },
            clearValue: function() {
                if (!this._form) {
                    return null;
                }
                $FormValue.clear(this._form);
                this._updateStatus();
                if (this._validator) {
                    this._validator.reset();
                }
            },
            getValidator: function() {
                return this._validator;
            }
        });
        var $FormEvent = {
            on: function(thisArg, root) {
                $FormEvent._each(thisArg, root, false);
                $FormEvent._each(thisArg, root, true);
            },
            off: function(thisArg, root) {
                $FormEvent._each(thisArg, root, false);
            },
            _each: function(thisArg, root, isOn) {
                thisArg = thisArg || window;
                var attr = $getDefault("FORM_FORM_EVENT_ATTRIBUTE");
                var eleArr;
                if (root) {
                    root = $domQueryEventElement(root);
                    if (!root) {
                        return;
                    }
                    eleArr = $domQueryAll("[" + attr + "]", root);
                } else {
                    eleArr = $domQueryAll("[" + attr + "]");
                }
                eleArr.forEach(function(ele) {
                    ele.getAttribute(attr).split(";").forEach(function(typeItem) {
                        var items = typeItem.trim().split(":");
                        if (items.length === 2) {
                            var event = items[0].trim();
                            if (event) {
                                items[1].split(",").forEach(function(handler) {
                                    handler = handler.trim();
                                    if (handler) {
                                        handler = $getObjectDeepValue(thisArg, handler);
                                        if ($isFunction(handler)) {
                                            if (isOn === true) {
                                                $domTypeOn(ele, event, handler, thisArg);
                                            } else {
                                                $domTypeOff(ele, event, handler, thisArg);
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    });
                });
            }
        };
        var $FormFor = {
            addForListener: function(form) {
                $domQueryAll($domGetAttrSelector($getDefault("FORM_FORM_MODEL_FOR")), form).forEach(function(ele) {
                    $domOn(ele, "click", $FormFor._handleForClick);
                });
            },
            removeForListener: function(form) {
                $domQueryAll($domGetAttrSelector($getDefault("FORM_FORM_MODEL_FOR")), form).forEach(function(ele) {
                    $domOff(ele, "click", $FormFor._handleForClick);
                });
            },
            _handleForClick: function(event) {
                var forAttr = $getDefault("FORM_FORM_MODEL_FOR");
                var forEle = $DomEventUtil.getEventTarget(event, "[" + forAttr + "]");
                var eleParent = forEle.parentNode;
                var for_attr_model = $getDefault("FORM_FORM_MODEL_ATTRIBUTE");
                var for_attr_value = forEle.getAttribute(forAttr);
                while (eleParent) {
                    var control = $domQuery($domGetAttrSelector(for_attr_model, for_attr_value), eleParent);
                    if (control) {
                        control.focus();
                        return;
                    }
                    eleParent = eleParent.parentNode;
                }
            }
        };
        z.form = {
            Validator: $Validator,
            Form: $Form,
            bindEvent: $FormEvent.on,
            unbindEvent: $FormEvent.off,
            attrOn: $FormEvent.on,
            attrOff: $FormEvent.off
        };
        z.form.Validator.validate = $ValUtil.validate;
        z.form.Validator.reset = $ValUtil.reset;
        z.form.Validator.registerRule = $ValRuleUtil.registerRule;
        z.form.Validator.registerRuleMessage = $ValMsgUtil.registerMessage;
    })(window);
    (function(window, undefined) {
        $setSysDefault({
            GVIEW_NODE_WIDTH: 32,
            GVIEW_NODE_HEIGHT: 32,
            GVIEW_GROUP_WIDTH: 36,
            GVIEW_GROUP_HEIGHT: 36,
            GVIEW_SUBVIEW_WIDTH: 60,
            GVIEW_SUBVIEW_HEIGHT: 36,
            GVIEW_NODE_SHAPE: "circle",
            GVIEW_NODE_FILL: "#0175a2",
            GVIEW_NODE_STROKE: "#0175a2",
            GVIEW_NODE_STROKE_LINE_WIDTH: 1,
            GVIEW_NODE_HEATMAP_COLORS: {
                .25: "rgb(0,0,255)",
                .55: "rgb(0,255,0)",
                .85: "yellow",
                1: "rgb(255,0,0)"
            },
            GVIEW_NODE_LABEL_POSITION: "bottom",
            GVIEW_NODE_LABEL_GAP: 3,
            GVIEW_NODE_SELECT_BORDER_PADDING: 2,
            GVIEW_NODE_OUTLINE_PADDING: 2,
            GVIEW_NODE_OUTLINE_STROKE_LINE_WIDTH: 1,
            GVIEW_GROUP_SHAPE: "roundrect",
            GVIEW_GROUP_EXPAND_SHAPE: "covexhull",
            GVIEW_GROUP_EXPAND_FILL: "rgba(50,100,200,0.1)",
            GVIEW_GROUP_EXPAND_STROKE: "#0175a2",
            GVIEW_GROUP_EXPAND_PADDING: 10,
            GVIEW_SUBVIEW_SHAPE: "cloud",
            GVIEW_LINK_STROKE: "#0175a2",
            GVIEW_LINK_STROKE_LINE_WIDTH: 1,
            GVIEW_LABEL_FILL: "#000",
            GVIEW_LABEL_BOX_PADDING: 2,
            GVIEW_INFO_FILL: "#000",
            GVIEW_INFO_BOX_FILL: "#0EB29A",
            GVIEW_SELECT_BORDER_STROKE_LINE_WIDTH: 1,
            GVIEW_SELECT_BORDER_STROKE: "#0EB29A",
            GVIEW_SELECT_SHADOW_COLOR: "#0EB29A",
            GVIEW_SELECT_SHADOW_BLUR: 6,
            GVIEW_HOVER_STYLE: {
                shadowColor: "#888",
                shadowBlur: 6
            },
            GVIEW_LINK_GAP: 16,
            GVIEW_HIT_PADDING: 2,
            GVIEW_GROUP_EXPAND_ON_DBLCLICK: true,
            GVIEW_SUBVIEW_DRILL_ON_DBLCLICK: true,
            GVIEW_LINK_BUNDLE_ON_DBLCLICK: true
        });
        var $GVDrawIndexUtil = {
            getDrawGroupArray: function(view) {
                return $filterArray($GVDrawIndexUtil._getDrawNodeArray(view), function(data) {
                    return $isGroup(data) && view.isExpanded(data);
                });
            },
            getDrawNodeArray: function(view) {
                return $filterArray($GVDrawIndexUtil._getDrawNodeArray(view), function(data) {
                    if ($isGroup(data)) {
                        return !view.isExpanded(data);
                    }
                    return $isNode(data);
                });
            },
            _getDrawNodeArray: function(view) {
                var subview = view.getCurrentSubview();
                var arr;
                if (subview) {
                    arr = subview.getChildren();
                } else {
                    arr = view.getRootDataArray();
                }
                var indexArr = [];
                arr.sort(function(d1, d2) {
                    return $GVDrawIndexUtil._indexCompare(view, arr, d1, d2);
                });
                arr.forEach(function(data) {
                    $GVDrawIndexUtil._fillIndexArr(view, data, indexArr);
                });
                return $filterArray(indexArr, function(data) {
                    return $isNode(data);
                });
            },
            _fillIndexArr: function(view, data, indexArr) {
                if ($isNode(data)) {
                    indexArr.push(data);
                }
                if (data.hasChildren()) {
                    var children = data.getChildren(false);
                    children.sort(function(d1, d2) {
                        return $GVDrawIndexUtil._indexCompare(view, children, d1, d2);
                    });
                    children.forEach(function(child) {
                        $GVDrawIndexUtil._fillIndexArr(view, child, indexArr);
                    });
                }
            },
            _indexCompare: function(view, arr, d1, d2) {
                var s1 = $GVDrawIndexUtil._getSelectIndex(view, d1);
                var s2 = $GVDrawIndexUtil._getSelectIndex(view, d2);
                if (s1 === s2) {
                    s1 = arr.indexOf(d1);
                    s2 = arr.indexOf(d2);
                }
                if (s1 > s2) {
                    return 1;
                }
                if (s1 < s2) {
                    return -1;
                }
                return 0;
            },
            _getSelectIndex: function(view, data) {
                var indexArr = [ $GVDrawIndexUtil._getDataSelectIndex(view, data) ];
                if ($isNode(data)) {
                    $SubviewUtil.getSameSubviewDescendantArray(view, data).forEach(function(item) {
                        indexArr.push($GVDrawIndexUtil._getDataSelectIndex(view, data));
                    });
                }
                return $MathMax.apply(null, indexArr);
            },
            _getDataSelectIndex: function(view, data) {
                var selected = view.getSelected(false);
                return selected.indexOf(data);
            }
        };
        var $GViewUtil = {
            getNodeViewProperty: function(view, node, prop, viewProp) {
                return $GViewUtil._getDataViewPrefixProperty(view, node, prop, "node", viewProp);
            },
            getLinkViewProperty: function(view, link, prop, viewProp) {
                return $GViewUtil._getDataViewPrefixProperty(view, link, prop, "link", viewProp);
            },
            getGroupViewProperty: function(view, group, prop, viewProp) {
                return $GViewUtil._getDataViewPrefixProperty(view, group, prop, "group", viewProp);
            },
            getDataViewLabelProperty: function(view, data, prop, viewProp) {
                return $GViewUtil._getDataViewPrefixProperty(view, data, prop, null, viewProp);
            },
            getDataViewInfoProperty: function(view, data, prop, viewProp) {
                return $GViewUtil._getDataViewPrefixProperty(view, data, prop, null, viewProp);
            },
            getDataViewVisibleLabel: function(view, data) {
                if (view) {
                    var label_visible = view.getDataViewProperty(data, "label_visible") !== false;
                    if (label_visible) {
                        return view.getLabel(data);
                    }
                    return null;
                }
                return data.getProperty("name");
            },
            getDataViewVisibleInfo: function(view, data) {
                if (view) {
                    var info_visible = view.getDataViewProperty(data, "info_visible") !== false;
                    if (info_visible) {
                        return view.getInfo(data);
                    }
                    return null;
                }
                return data.getProperty("info");
            },
            getFont: function(font) {
                return font || $C2DTextUtil.getSystemFont();
            },
            getOffset: function(view, data, prefix) {
                var offset = $GViewUtil._getDataViewPrefixProperty(view, data, prefix + "_offset");
                if (offset) {
                    return {
                        x: offset.x | 0,
                        y: offset.y | 0
                    };
                }
                return {
                    x: $GViewUtil._getDataViewPrefixProperty(view, data, prefix + "_offset_x") | 0,
                    y: $GViewUtil._getDataViewPrefixProperty(view, data, prefix + "_offset_y") | 0
                };
            },
            _getDataViewPrefixProperty: function(view, data, prop, prefix, viewProp) {
                if (view) {
                    return view.getDataViewProperty(data, prop, $GViewUtil._getViewPrefixProperty(prop, prefix, viewProp));
                }
                return data.getProperty(prop);
            },
            _hasDataViewPrefixProperty: function(view, data, prop, prefix, viewProp) {
                if (view) {
                    return view.hasDataViewProperty(data, prop, $GViewUtil._getViewPrefixProperty(prop, prefix, viewProp));
                }
                return data.hasProperty(prop);
            },
            _getViewPrefixProperty: function(prop, prefix, viewProp) {
                if (viewProp == null) {
                    if (prefix) {
                        viewProp = prefix + "_" + prop;
                    } else {
                        viewProp = prop;
                    }
                }
                return viewProp;
            },
            getVisibleDataBounds: function(gview, dataArr) {
                var visibleBoundsArr = [];
                var all = true;
                if (dataArr != null && dataArr.length > 0) {
                    all = false;
                }
                $eachArray(gview.getDataArray(false), function(data) {
                    if (all === false) {
                        if (dataArr.indexOf(data) === -1) {
                            return;
                        }
                    }
                    if (data.getBounds && gview._isVisible(data)) {
                        var bounds = data.getBounds(gview, false);
                        if (bounds) {
                            visibleBoundsArr.push(bounds);
                        }
                    }
                });
                return $MathRectUtil.calcRectsUnion(visibleBoundsArr);
            },
            toDataURL: function(gview, type) {
                var ovBounds = $GViewUtil.getVisibleDataBounds(gview);
                if (ovBounds == null) {
                    return null;
                }
                var width = ovBounds.width, height = ovBounds.height;
                var gap = 10;
                var cvs = $domCreate("canvas");
                cvs.setAttribute("width", width + gap);
                cvs.setAttribute("height", height + gap);
                var g2d = cvs.getContext("2d");
                var font = gview.getProperty("label_font") || $C2DTextUtil.getSystemFont();
                if (g2d.font !== font) {
                    g2d.font = font;
                }
                var ratio = devicePixelRatio;
                if (ratio !== 1) {
                    g2d.scale(ratio, ratio);
                }
                var tx = -(ovBounds.x - gap / 2);
                var ty = -(ovBounds.y - gap / 2);
                var zoom = 1;
                if (tx !== 0 || ty !== 0 || zoom !== 1) {
                    g2d.setTransform(zoom, 0, 0, zoom, tx, ty);
                }
                gview._drawData(g2d);
                return cvs.toDataURL(type || "image/png");
            }
        };
        $mergeObject($ModelTypeCheck, {
            isNode: function(obj, just) {
                var is_node = $ModelTypeCheck._isIModelType(obj, "Node", $TypeConst.NODE);
                if (just === true && is_node === true) {
                    return !$isGroup(obj) && !$isSubview(obj);
                }
                return is_node;
            },
            isLink: function(obj, just) {
                var is_link = $ModelTypeCheck._isIModelType(obj, "Link", $TypeConst.LINK);
                if (just === true && is_link === true) {
                    return !$isLinkSubview(obj);
                }
                return is_link;
            },
            isGroup: function(obj) {
                return $ModelTypeCheck._isIModelType(obj, "Group", $TypeConst.GROUP);
            },
            isSubview: function(obj) {
                return $ModelTypeCheck._isIModelType(obj, "Subview", $TypeConst.SUBVIEW);
            },
            isLinkSubview: function(obj) {
                return $ModelTypeCheck._isIModelType(obj, "LinkSubview", $TypeConst.LINKSUBVIEW);
            },
            isGView: function(obj) {
                return $ModelTypeCheck._isIModelType(obj, "GView", $TypeConst.GVIEW);
            }
        });
        var $isNode = $ModelTypeCheck.isNode, $isLink = $ModelTypeCheck.isLink, $isGroup = $ModelTypeCheck.isGroup, $isSubview = $ModelTypeCheck.isSubview, $isLinkSubview = $ModelTypeCheck.isLinkSubview;
        var $NodeUtil = {
            isPointsNode: function(node) {
                var type = node.getType();
                return type === "path" || type === "heatmap";
            },
            getSizeProperty: function(view, node, property) {
                var viewProp = "node_" + property;
                if (view && view.hasDataViewProperty(node, property, viewProp)) {
                    return view.getDataViewProperty(node, property, viewProp);
                }
                if (node.getType() === "image") {
                    var image = node.getProperty("image");
                    if (image) {
                        var img;
                        if ($isString(image)) {
                            img = $ImageUtil.get(image);
                        } else {
                            img = image;
                        }
                        if (img) {
                            return img[property];
                        }
                    }
                }
                if (view) {
                    return view.getDataViewProperty(node, property, viewProp);
                }
                return node.getProperty(property);
            },
            setPosition: function(view, node, position) {
                if (position == null) {
                    return;
                }
                if ($NodeUtil.isPointsNode(node)) {
                    $NodeUtil.updateNodePointsByBounds(view, node, position);
                } else {
                    node.setProperty("x", position.x);
                    node.setProperty("y", position.y);
                }
            },
            setSize: function(view, node, size) {
                if (size == null) {
                    return;
                }
                if ($NodeUtil.isPointsNode(node)) {
                    $NodeUtil.updateNodePointsByBounds(view, node, size);
                } else {
                    node.setProperty("width", size.width);
                    node.setProperty("height", size.height);
                }
            },
            updateNodePointsByBounds: function(view, node, newBounds) {
                var points = node.get("points") || [];
                if (points.length < 1) {
                    return;
                }
                var bounds = node.getBounds(view);
                if (bounds == null) {
                    return;
                }
                var xZoom = 1;
                if (newBounds.hasOwnProperty("width")) {
                    if (bounds.width <= 0) {
                        return;
                    }
                    xZoom = newBounds.width / bounds.width;
                }
                var yZoom = 1;
                if (newBounds.hasOwnProperty("height")) {
                    if (bounds.height <= 0) {
                        return;
                    }
                    yZoom = newBounds.height / bounds.height;
                }
                var xOffset = 0;
                var minX = bounds.x;
                if (newBounds.hasOwnProperty("x")) {
                    xOffset = newBounds.x - bounds.x;
                    minX = newBounds.x;
                }
                var yOffset = 0;
                var minY = bounds.y;
                if (newBounds.hasOwnProperty("y")) {
                    yOffset = newBounds.y - bounds.y;
                    minY = newBounds.y;
                }
                var _points = [];
                points.forEach(function(point) {
                    _points.push($mergeObject(point, {
                        x: minX + (point.x + xOffset - minX) * xZoom,
                        y: minY + (point.y + yOffset - minY) * yZoom
                    }));
                });
                node.set("points", _points);
            },
            isGIFNode: function(node) {
                var type = node.getType();
                if (type !== "image") {
                    return false;
                }
                var image = node.get("image");
                if ($isString(image)) {
                    return image.endsWith(".gif");
                }
                return false;
            }
        };
        var $LinkUtil = {
            getLoopSibling: function(view, link) {
                var fromNode = link.getProperty("from");
                var links = $filterArray(fromNode.getFromLinks(false), function(link) {
                    return fromNode === link.getProperty("to");
                });
                if (view) {
                    return $filterArray(links, function(link) {
                        return view._isVisible(link);
                    });
                }
                return links;
            },
            getSiblingByType: function(view, link, sameDirection) {
                return $LinkUtil._getSibling(view, link, sameDirection, true);
            },
            getSibling: function(view, link, sameDirection) {
                return $LinkUtil._getSibling(view, link, sameDirection, false);
            },
            _getSibling: function(view, link, sameDirection, sameType) {
                var fromNode = $LinkUtil.getFromNodeAgent(view, link);
                var toNode = $LinkUtil.getToNodeAgent(view, link);
                var arr = [];
                if (fromNode && toNode) {
                    var type = $GViewUtil.getLinkViewProperty(view, link, "type");
                    var fromNodeLinks = $LinkUtil.getNodeAgentLinks(view, fromNode);
                    var toNodeLinks = $LinkUtil.getNodeAgentLinks(view, toNode);
                    fromNodeLinks.forEach(function(aLink) {
                        if (toNodeLinks.indexOf(aLink) < 0) {
                            return;
                        }
                        if (view && !view._isVisible(aLink)) {
                            return;
                        }
                        if (sameDirection === true && $LinkUtil.getFromNodeAgent(view, aLink) !== fromNode) {
                            return;
                        }
                        if (sameType === true && $GViewUtil.getLinkViewProperty(view, aLink, "type") !== type) {
                            return;
                        }
                        arr.push(aLink);
                    });
                }
                if (arr.length > 1) {
                    var dataArr = view.getDataArray(false);
                    arr = arr.sort(function(l1, l2) {
                        return dataArr.indexOf(l1) - dataArr.indexOf(l2);
                    });
                }
                return arr;
            },
            getNodeAgentLinks: function(view, node) {
                var result = [];
                if (view) {
                    $DataLevelUtil.getAddedDescendantArray(view.getProvider(), node).forEach(function(child) {
                        if ($isNode(child)) {
                            var links = child.getLinks();
                            if (links.length > 0) {
                                links.forEach(function(link) {
                                    if ($LinkUtil.getFromNodeAgent(view, link) === node || $LinkUtil.getToNodeAgent(view, link) === node) {
                                        result.push(link);
                                    }
                                });
                            }
                        }
                    });
                }
                return $filterArray($mergeArray(result, node.getLinks()), function(link, index) {
                    return result.indexOf(link) === index;
                });
            },
            getFromNodeAgent: function(view, link) {
                if (view) {
                    var from = $LinkUtil._getCurrentSubviewAgent(view, link.getProperty("from"));
                    var to = $LinkUtil._getCurrentSubviewAgent(view, link.getProperty("to"));
                    if (from === to) {
                        return from;
                    }
                    return $LinkUtil._getSpanSubviewAgent(view, from, to);
                }
                return link.getProperty("from");
            },
            getToNodeAgent: function(view, link) {
                if (view) {
                    var to = $LinkUtil._getCurrentSubviewAgent(view, link.get("to"));
                    var from = $LinkUtil._getCurrentSubviewAgent(view, link.get("from"));
                    if (from === to) {
                        return to;
                    }
                    return $LinkUtil._getSpanSubviewAgent(view, to, from);
                }
                return link.getProperty("to");
            },
            _getCurrentSubviewAgent: function(view, node) {
                if (!node) {
                    return null;
                }
                var parent = node.get("parent");
                while ($isGroup(parent)) {
                    if ($isGroup(parent.get("parent"))) {
                        if (view.isExpanded(parent) !== true) {
                            node = parent;
                        }
                        parent = parent.get("parent");
                    } else {
                        if (view.isExpanded(parent) === true) {
                            return node;
                        } else {
                            return parent;
                        }
                    }
                }
                if ($isNode(node)) {
                    return node;
                }
                return null;
            },
            _getSpanSubviewAgent: function(view, node, peerNode) {
                if (!node || !peerNode) {
                    return null;
                }
                var nodeSV = $SubviewUtil.getDataSubview(node);
                var refNodeSV = $SubviewUtil.getDataSubview(peerNode);
                if (nodeSV !== refNodeSV) {
                    while (refNodeSV != null && nodeSV !== refNodeSV) {
                        refNodeSV = $SubviewUtil.getDataSubview(refNodeSV);
                    }
                    if (nodeSV === refNodeSV) {
                        return node;
                    }
                    var arr = [];
                    arr.push(node);
                    var parent = node.get("parent");
                    while ($isNode(parent)) {
                        if (!$DataLevelUtil.isDescendantOf(peerNode, parent)) {
                            arr.unshift(parent);
                            parent = parent.get("parent");
                        } else {
                            break;
                        }
                    }
                    var n = arr.length;
                    for (var i = 0; i < n; i++) {
                        var element = arr[i];
                        if ($isGroup(element) && !view.isExpanded(element) === true) {
                            return element;
                        }
                        if ($isSubview(element)) {
                            return element;
                        }
                    }
                    return node;
                }
                if ($isNode(node)) {
                    return node;
                }
                return null;
            }
        };
        var $GroupUtil = {
            getGroupAncestorArray: function(data) {
                var arr = [];
                var parent = data.get("parent");
                while (parent) {
                    if ($isGroup(parent)) {
                        arr.push(parent);
                    }
                    parent = parent.get("parent");
                }
                return arr;
            },
            getGroupVisibleNodes: function(view, group) {
                var children = $filterArray(group.getGroupChildren(), function(child) {
                    return $isNode(child);
                });
                if (view) {
                    return $filterArray(children, function(child) {
                        return view._isVisible_(child);
                    });
                }
                return children;
            },
            setPosition: function(view, group, position) {
                var bounds = group.getBounds(view);
                $GroupUtil.updateChildrenPositionByOffset(view, group, position.x - bounds.x, position.y - bounds.y);
            },
            updateChildrenPositionByOffset: function(view, group, xOffset, yOffset) {
                group.getGroupChildren().forEach(function(child) {
                    var bounds = child.getBounds(view);
                    child.setPosition({
                        x: bounds.x + xOffset,
                        y: bounds.y + yOffset
                    });
                });
            }
        };
        var $SubviewUtil = {
            getDataSubview: function(data) {
                var parent = data.get("parent");
                while (parent && !$ModelTypeCheck.isSubview(parent)) {
                    parent = parent.get("parent");
                }
                return parent;
            },
            getSameSubviewAncestorArray: function(data) {
                var arr = [];
                var parent = data.get("parent");
                while (parent) {
                    if ($isSubview(parent)) {
                        break;
                    }
                    arr.push(parent);
                    parent = parent.get("parent");
                }
                return arr;
            },
            getSameSubviewDescendantArray: function(view, data) {
                var arr = $DataLevelUtil.getAddedDescendantArray(view.getProvider(), data);
                var subview = $SubviewUtil.getDataSubview(data);
                return $filterArray(arr, function(dData) {
                    return subview === $SubviewUtil.getDataSubview(dData);
                });
            },
            expandSameSubviewGroup: function(view, data, current) {
                if (data) {
                    var groups = $SubviewUtil.getSameSubviewAncestorArray(data);
                    if (current === true) {
                        groups.unshift(data);
                    }
                    groups.forEach(function(ancestor) {
                        if ($isGroup(ancestor)) {
                            view.expand(ancestor);
                        }
                    });
                }
            },
            getSpanSubview: function(node, peerNode) {
                if (!node || !peerNode) {
                    return null;
                }
                var peerAncestorArr = $DataLevelUtil.getAncestorArray(peerNode);
                return $findArray($DataLevelUtil.getAncestorArray(node), function(parent) {
                    return peerAncestorArr.indexOf(parent) > -1 && $isSubview(parent);
                });
            }
        };
        var $DefaultLinkPathCalculator = {
            calcLinkDefaultPath: function(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, cornerOffset) {
                var linkIndex = siblings.indexOf(link);
                var siblingSize = siblings.length;
                var half = siblingSize / 2;
                var indexYGap = -(linkIndex - (half - .5)) * linkGap;
                var fromPoint, toPoint;
                var angle;
                if (refLinkConfig.same_direction) {
                    fromPoint = refLinkConfig.from;
                    toPoint = refLinkConfig.to;
                } else {
                    fromPoint = refLinkConfig.to;
                    toPoint = refLinkConfig.from;
                    indexYGap = -indexYGap;
                }
                angle = $mathCalcAngle(fromPoint, toPoint);
                var pathFromPoint, pathToPoint;
                if (cornerOffset > 0) {
                    pathFromPoint = $MathPointUtil.calcRotatedPoint(fromPoint, {
                        x: fromPoint.x + cornerOffset,
                        y: fromPoint.y + indexYGap
                    }, angle);
                    pathToPoint = $MathPointUtil.calcRotatedPoint(toPoint, {
                        x: toPoint.x - cornerOffset,
                        y: toPoint.y + indexYGap
                    }, angle);
                    return [ fromPoint, pathFromPoint, pathToPoint, toPoint ];
                }
                pathFromPoint = $MathPointUtil.calcRotatedPoint(fromPoint, {
                    x: fromPoint.x,
                    y: fromPoint.y + indexYGap
                }, angle);
                pathToPoint = $MathPointUtil.calcRotatedPoint(toPoint, {
                    x: toPoint.x,
                    y: toPoint.y + indexYGap
                }, angle);
                return [ pathFromPoint, pathToPoint ];
            },
            _getPositionPoint: function(nodeBounds, peerNodeBounds, position) {
                var x = nodeBounds.x, y = nodeBounds.y, width = nodeBounds.width, height = nodeBounds.height;
                var cx = x + width / 2, cy = y + height / 2;
                var ax = peerNodeBounds.x, ay = peerNodeBounds.y, aWidth = peerNodeBounds.width, aHeight = peerNodeBounds.height;
                var acx = ax + aWidth / 2, acy = ay + aHeight / 2;
                if (position === "edge_center") {
                    var angle = $mathCalcAngle({
                        x: cx,
                        y: cy
                    }, {
                        x: acx,
                        y: acy
                    });
                    if (angle > 45 && angle < 135) {
                        position = "bottom";
                    } else if (angle >= 135 && angle <= 225) {
                        position = "left";
                    } else if (angle > 225 && angle < 315) {
                        position = "top";
                    } else {
                        position = "right";
                    }
                }
                var point;
                switch (position) {
                    case "center":
                        point = {
                            x: cx,
                            y: cy
                        };
                        break;

                    case "top":
                        point = {
                            x: cx,
                            y: y
                        };
                        break;

                    case "right":
                        point = {
                            x: x + width,
                            y: cy
                        };
                        break;

                    case "bottom":
                        point = {
                            x: cx,
                            y: y + height
                        };
                        break;

                    case "left":
                        point = {
                            x: x,
                            y: cy
                        };
                        break;

                    case "v_center":
                        if (cy < acy) {
                            point = {
                                x: cx,
                                y: y + height
                            };
                        } else {
                            point = {
                                x: cx,
                                y: y
                            };
                        }
                        break;

                    case "h_center":
                        if (cx < acx) {
                            point = {
                                x: x + width,
                                y: cy
                            };
                        } else {
                            point = {
                                x: x,
                                y: cy
                            };
                        }
                        break;

                    default:
                        point = $MathLineUtil.calcRectLineIntersection(nodeBounds, {
                            x: acx,
                            y: acy
                        }, {
                            x: cx,
                            y: cy
                        }, true)[0];
                }
                if (point == null) {
                    point = {
                        x: cx,
                        y: cy
                    };
                }
                return point;
            }
        };
        var $LoopLinkPathCalculator = {
            calcLinkLoopPath: function(link, siblings, linkGap, nodeBounds) {
                var linkIndex = siblings.indexOf(link);
                var cx = nodeBounds.x + nodeBounds.width;
                var cy = nodeBounds.y;
                var radius = linkGap + linkIndex * linkGap;
                var c = .551915024494;
                var cg = radius * c;
                return [ {
                    x: cx - radius,
                    y: cy,
                    seg: "bezier_curve_to"
                }, {
                    x: cx - radius,
                    y: cy - cg
                }, {
                    x: cx - cg,
                    y: cy - radius
                }, {
                    x: cx,
                    y: cy - radius,
                    seg: "bezier_curve_to"
                }, {
                    x: cx + cg,
                    y: cy - radius
                }, {
                    x: cx + radius,
                    y: cy - cg
                }, {
                    x: cx + radius,
                    y: cy,
                    seg: "bezier_curve_to"
                }, {
                    x: cx + radius,
                    y: cy + cg
                }, {
                    x: cx + cg,
                    y: cy + radius
                }, {
                    x: cx,
                    y: cy + radius
                } ];
            }
        };
        var $RALinkPathCalculator = {
            calcLinkRAPath: function(type, link, siblings, linkGap, fromBounds, toBounds, options) {
                switch (type) {
                    case "ra_hv":
                        return $RALinkPathCalculator.calcLinkRAHVPath(link, siblings, linkGap, fromBounds, toBounds);

                    case "ra_vh":
                        return $RALinkPathCalculator.calcLinkRAVHPath(link, siblings, linkGap, fromBounds, toBounds);

                    case "ra_hvh":
                        return $RALinkPathCalculator.calcLinkRAHVHPath(link, siblings, linkGap, fromBounds, toBounds, options);

                    case "ra_vhv":
                        return $RALinkPathCalculator.calcLinkRAVHVPath(link, siblings, linkGap, fromBounds, toBounds, options);

                    case "ra_top":
                        return $RALinkPathCalculator.calcLinkRATopPath(link, siblings, linkGap, fromBounds, toBounds);

                    case "ra_bottom":
                        return $RALinkPathCalculator.calcLinkRABottomPath(link, siblings, linkGap, fromBounds, toBounds);

                    case "ra_left":
                        return $RALinkPathCalculator.calcLinkRALeftPath(link, siblings, linkGap, fromBounds, toBounds);

                    case "ra_right":
                        return $RALinkPathCalculator.calcLinkRARightPath(link, siblings, linkGap, fromBounds, toBounds);
                }
            }
        };
        $RALinkPathCalculator.calcLinkRABottomPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromBottomY = fromBounds.y + fromBounds.height;
            var toBottomY = toBounds.y + toBounds.height;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var bottomLength = $MathMax(linkGap * 2, 6);
            var indexGap = linkIndex * linkGap;
            var raY = $MathMax(fromBottomY, toBottomY) + bottomLength + indexGap;
            var xGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint;
            if (fromCenterX < toCenterX) {
                linkFromPoint = {
                    x: fromCenterX + xGap,
                    y: fromBottomY
                };
                linkFromRAPoint = {
                    x: linkFromPoint.x,
                    y: raY
                };
                linkToPoint = {
                    x: toCenterX - xGap,
                    y: toBottomY
                };
                linkToRAPoint = {
                    x: linkToPoint.x,
                    y: raY
                };
            } else {
                linkFromPoint = {
                    x: fromCenterX - xGap,
                    y: fromBottomY
                };
                linkFromRAPoint = {
                    x: linkFromPoint.x,
                    y: raY
                };
                linkToPoint = {
                    x: toCenterX + xGap,
                    y: toBottomY
                };
                linkToRAPoint = {
                    x: linkToPoint.x,
                    y: raY
                };
            }
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRAHVPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var fromLeftX = fromBounds.x;
            var fromRightX = fromBounds.x + fromBounds.width;
            var toTopY = toBounds.y;
            var toBottomY = toBounds.y + toBounds.height;
            var indexGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkRAPoint, linkToPoint;
            if (fromCenterX < toCenterX) {
                linkFromPoint = {
                    x: fromRightX,
                    y: fromCenterY - indexGap
                };
                if (fromCenterY < toCenterY) {
                    linkToPoint = {
                        x: toCenterX + indexGap,
                        y: toTopY
                    };
                } else {
                    linkToPoint = {
                        x: toCenterX - indexGap,
                        y: toBottomY
                    };
                }
                linkRAPoint = {
                    x: linkToPoint.x,
                    y: linkFromPoint.y
                };
            } else {
                linkFromPoint = {
                    x: fromLeftX,
                    y: fromCenterY - indexGap
                };
                if (fromCenterY < toCenterY) {
                    linkToPoint = {
                        x: toCenterX - indexGap,
                        y: toTopY
                    };
                } else {
                    linkToPoint = {
                        x: toCenterX + indexGap,
                        y: toBottomY
                    };
                }
                linkRAPoint = {
                    x: linkToPoint.x,
                    y: linkFromPoint.y
                };
            }
            return [ linkFromPoint, linkRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRAHVHPath = function(link, siblings, linkGap, fromBounds, toBounds, options) {
            var linkIndex = siblings.indexOf(link);
            var siblingSize = siblings.length;
            var half = siblingSize / 2;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var fromLeftX = fromBounds.x;
            var fromRightX = fromBounds.x + fromBounds.width;
            var toLeftX = toBounds.x;
            var toRightX = toBounds.x + toBounds.width;
            var indexGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkCornerGap = (half - .5) * linkGap * 2;
            var linkFromPoint, linkFromRAPoint, linkToPoint, linkToRAPoint;
            if (fromCenterX < toCenterX) {
                linkFromPoint = {
                    x: fromRightX,
                    y: fromCenterY - indexGap
                };
                linkToPoint = {
                    x: toLeftX,
                    y: toCenterY - indexGap
                };
            } else {
                linkFromPoint = {
                    x: fromLeftX,
                    y: fromCenterY - indexGap
                };
                linkToPoint = {
                    x: toRightX,
                    y: toCenterY - indexGap
                };
            }
            var distance = $MathAbs(linkFromPoint.x - linkToPoint.x);
            var cornerFromDistance = options["from_corner_distance"];
            var cornerToDistance = options["to_corner_distance"];
            var cornerFromGap = -1, cornerToGap = -1;
            if (cornerFromDistance > 0 && cornerFromDistance < distance) {
                if (cornerFromDistance < 1) {
                    cornerFromGap = distance * cornerFromDistance;
                } else {
                    cornerFromGap = cornerFromDistance;
                }
            }
            if (cornerToDistance > 0 && cornerToDistance < distance) {
                if (cornerToDistance < 1) {
                    cornerToGap = distance * cornerToDistance;
                } else {
                    cornerToGap = cornerToDistance;
                }
            }
            var fromRANoDistance = true;
            var toRANoDistance = true;
            if (cornerFromGap !== -1 && cornerToGap !== -1) {
                if (cornerFromGap + cornerToGap < distance - linkCornerGap) {
                    fromRANoDistance = false;
                    toRANoDistance = false;
                }
            } else {
                if (cornerToGap !== -1) {
                    if (cornerToGap < distance - linkCornerGap) {
                        toRANoDistance = false;
                    }
                }
                if (cornerFromGap !== -1) {
                    if (cornerFromGap < distance - linkCornerGap) {
                        fromRANoDistance = false;
                    }
                }
            }
            var cornerX;
            if (fromRANoDistance === true || toRANoDistance === true) {
                if (fromCenterX < toCenterX) {
                    if (fromCenterY < toCenterY) {
                        cornerX = (linkFromPoint.x + linkToPoint.x) / 2 + indexGap;
                    } else {
                        cornerX = (linkFromPoint.x + linkToPoint.x) / 2 - indexGap;
                    }
                } else {
                    if (fromCenterY < toCenterY) {
                        cornerX = (linkFromPoint.x + linkToPoint.x) / 2 - indexGap;
                    } else {
                        cornerX = (linkFromPoint.x + linkToPoint.x) / 2 + indexGap;
                    }
                }
            }
            var linkFromRAPointX, linkToRAPointX;
            if (fromRANoDistance === false) {
                if (fromCenterX < toCenterX) {
                    linkFromRAPointX = linkFromPoint.x + cornerFromGap;
                    if (fromCenterY < toCenterY) {
                        linkFromRAPointX += (siblingSize - linkIndex - 1) * linkGap;
                    } else {
                        linkFromRAPointX += linkIndex * linkGap;
                    }
                } else {
                    linkFromRAPointX = linkFromPoint.x - cornerFromGap;
                    if (fromCenterY < toCenterY) {
                        linkFromRAPointX -= (siblingSize - linkIndex - 1) * linkGap;
                    } else {
                        linkFromRAPointX -= linkIndex * linkGap;
                    }
                }
            }
            if (toRANoDistance === false) {
                if (fromCenterX < toCenterX) {
                    linkToRAPointX = linkToPoint.x - cornerToGap;
                    if (fromCenterY < toCenterY) {
                        linkToRAPointX -= linkIndex * linkGap;
                    } else {
                        linkToRAPointX -= (siblingSize - linkIndex - 1) * linkGap;
                    }
                } else {
                    linkToRAPointX = linkToPoint.x + cornerToGap;
                    if (fromCenterY < toCenterY) {
                        linkToRAPointX += linkIndex * linkGap;
                    } else {
                        linkToRAPointX += (siblingSize - linkIndex - 1) * linkGap;
                    }
                }
            }
            if (fromRANoDistance === false) {
                if (toRANoDistance === true) {
                    linkToRAPointX = linkFromRAPointX;
                }
            } else {
                if (toRANoDistance === false) {
                    linkFromRAPointX = linkToRAPointX;
                } else {
                    linkToRAPointX = cornerX;
                    linkFromRAPointX = cornerX;
                }
            }
            linkFromRAPoint = {
                x: linkFromRAPointX,
                y: linkFromPoint.y
            };
            linkToRAPoint = {
                x: linkToRAPointX,
                y: linkToPoint.y
            };
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRALeftPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromX = fromBounds.x;
            var toX = toBounds.x;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var leftLength = $MathMax(linkGap * 2, 6);
            var indexGap = linkIndex * linkGap;
            var raX = $MathMin(fromX, toX) - leftLength - indexGap;
            var yGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint;
            if (fromCenterY < toCenterY) {
                linkFromPoint = {
                    x: fromX,
                    y: fromCenterY + yGap
                };
                linkFromRAPoint = {
                    x: raX,
                    y: linkFromPoint.y
                };
                linkToPoint = {
                    x: toX,
                    y: toCenterY - yGap
                };
                linkToRAPoint = {
                    x: raX,
                    y: linkToPoint.y
                };
            } else {
                linkFromPoint = {
                    x: fromX,
                    y: fromCenterY - yGap
                };
                linkFromRAPoint = {
                    x: raX,
                    y: linkFromPoint.y
                };
                linkToPoint = {
                    x: toX,
                    y: toCenterY + yGap
                };
                linkToRAPoint = {
                    x: raX,
                    y: linkToPoint.y
                };
            }
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRARightPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromRightX = fromBounds.x + fromBounds.width;
            var toRightX = toBounds.x + toBounds.width;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var rightLength = $MathMax(linkGap * 2, 6);
            var indexGap = linkIndex * linkGap;
            var raX = $MathMax(fromRightX, toRightX) + rightLength + indexGap;
            var yGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint;
            if (fromCenterY < toCenterY) {
                linkFromPoint = {
                    x: fromRightX,
                    y: fromCenterY + yGap
                };
                linkFromRAPoint = {
                    x: raX,
                    y: linkFromPoint.y
                };
                linkToPoint = {
                    x: toRightX,
                    y: toCenterY - yGap
                };
                linkToRAPoint = {
                    x: raX,
                    y: linkToPoint.y
                };
            } else {
                linkFromPoint = {
                    x: fromRightX,
                    y: fromCenterY - yGap
                };
                linkFromRAPoint = {
                    x: raX,
                    y: linkFromPoint.y
                };
                linkToPoint = {
                    x: toRightX,
                    y: toCenterY + yGap
                };
                linkToRAPoint = {
                    x: raX,
                    y: linkToPoint.y
                };
            }
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRATopPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromY = fromBounds.y;
            var toY = toBounds.y;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var topLength = $MathMax(linkGap * 2, 6);
            var indexGap = linkIndex * linkGap;
            var raY = $MathMin(fromY, toY) - topLength - indexGap;
            var xGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint;
            if (fromCenterX < toCenterX) {
                linkFromPoint = {
                    x: fromCenterX + xGap,
                    y: fromY
                };
                linkFromRAPoint = {
                    x: linkFromPoint.x,
                    y: raY
                };
                linkToPoint = {
                    x: toCenterX - xGap,
                    y: toY
                };
                linkToRAPoint = {
                    x: linkToPoint.x,
                    y: raY
                };
            } else {
                linkFromPoint = {
                    x: fromCenterX - xGap,
                    y: fromY
                };
                linkFromRAPoint = {
                    x: linkFromPoint.x,
                    y: raY
                };
                linkToPoint = {
                    x: toCenterX + xGap,
                    y: toY
                };
                linkToRAPoint = {
                    x: linkToPoint.x,
                    y: raY
                };
            }
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRAVHPath = function(link, siblings, linkGap, fromBounds, toBounds) {
            var linkIndex = siblings.indexOf(link);
            var half = siblings.length / 2;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var fromTopY = fromBounds.y;
            var fromBottomY = fromBounds.y + fromBounds.height;
            var toLeftX = toBounds.x;
            var toRightX = toBounds.x + toBounds.width;
            var indexGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkFromPoint, linkRAPoint, linkToPoint;
            if (fromCenterX < toCenterX) {
                if (fromCenterY < toCenterY) {
                    linkFromPoint = {
                        x: fromCenterX - indexGap,
                        y: fromBottomY
                    };
                    linkToPoint = {
                        x: toLeftX,
                        y: toCenterY + indexGap
                    };
                } else {
                    linkFromPoint = {
                        x: fromCenterX - indexGap,
                        y: fromTopY
                    };
                    linkToPoint = {
                        x: toLeftX,
                        y: toCenterY - indexGap
                    };
                }
                linkRAPoint = {
                    x: linkFromPoint.x,
                    y: linkToPoint.y
                };
            } else {
                if (fromCenterY < toCenterY) {
                    linkFromPoint = {
                        x: fromCenterX - indexGap,
                        y: fromBottomY
                    };
                    linkToPoint = {
                        x: toRightX,
                        y: toCenterY - indexGap
                    };
                } else {
                    linkFromPoint = {
                        x: fromCenterX - indexGap,
                        y: fromTopY
                    };
                    linkToPoint = {
                        x: toRightX,
                        y: toCenterY + indexGap
                    };
                }
                linkRAPoint = {
                    x: linkFromPoint.x,
                    y: linkToPoint.y
                };
            }
            return [ linkFromPoint, linkRAPoint, linkToPoint ];
        };
        $RALinkPathCalculator.calcLinkRAVHVPath = function(link, siblings, linkGap, fromBounds, toBounds, options) {
            var linkIndex = siblings.indexOf(link);
            var siblingSize = siblings.length;
            var half = siblingSize / 2;
            var fromCenterY = fromBounds.y + fromBounds.height / 2;
            var toCenterY = toBounds.y + toBounds.height / 2;
            var fromCenterX = fromBounds.x + fromBounds.width / 2;
            var toCenterX = toBounds.x + toBounds.width / 2;
            var fromTopY = fromBounds.y;
            var fromBottomY = fromBounds.y + fromBounds.height;
            var toTopY = toBounds.y;
            var toBottomY = toBounds.y + toBounds.height;
            var indexGap = (half - .5) * linkGap - linkIndex * linkGap;
            var linkCornerGap = (half - .5) * linkGap * 2;
            var linkFromPoint, linkFromRAPoint, linkToPoint, linkToRAPoint;
            if (fromCenterY < toCenterY) {
                linkFromPoint = {
                    x: fromCenterX - indexGap,
                    y: fromBottomY
                };
                linkToPoint = {
                    x: toCenterX - indexGap,
                    y: toTopY
                };
            } else {
                linkFromPoint = {
                    x: fromCenterX - indexGap,
                    y: fromTopY
                };
                linkToPoint = {
                    x: toCenterX - indexGap,
                    y: toBottomY
                };
            }
            var distance = $MathAbs(linkFromPoint.y - linkToPoint.y);
            var cornerFromDistance = options["from_corner_distance"];
            var cornerToDistance = options["to_corner_distance"];
            var cornerFromGap = -1, cornerToGap = -1;
            if (cornerFromDistance > 0 && cornerFromDistance < distance) {
                if (cornerFromDistance < 1) {
                    cornerFromGap = distance * cornerFromDistance;
                } else {
                    cornerFromGap = cornerFromDistance;
                }
            }
            if (cornerToDistance > 0 && cornerToDistance < distance) {
                if (cornerToDistance < 1) {
                    cornerToGap = distance * cornerToDistance;
                } else {
                    cornerToGap = cornerToDistance;
                }
            }
            var fromRANoDistance = true;
            var toRANoDistance = true;
            if (cornerFromGap !== -1 && cornerToGap !== -1) {
                if (cornerFromGap + cornerToGap < distance - linkCornerGap) {
                    fromRANoDistance = false;
                    toRANoDistance = false;
                }
            } else {
                if (cornerToGap !== -1) {
                    if (cornerToGap < distance - linkCornerGap) {
                        toRANoDistance = false;
                    }
                }
                if (cornerFromGap !== -1) {
                    if (cornerFromGap < distance - linkCornerGap) {
                        fromRANoDistance = false;
                    }
                }
            }
            var cornerY;
            if (fromRANoDistance === true || toRANoDistance === true) {
                if (fromCenterY < toCenterY) {
                    if (fromCenterX < toCenterX) {
                        cornerY = (linkFromPoint.y + linkToPoint.y) / 2 + indexGap;
                    } else {
                        cornerY = (linkFromPoint.y + linkToPoint.y) / 2 - indexGap;
                    }
                } else {
                    if (fromCenterX < toCenterX) {
                        cornerY = (linkFromPoint.y + linkToPoint.y) / 2 - indexGap;
                    } else {
                        cornerY = (linkFromPoint.y + linkToPoint.y) / 2 + indexGap;
                    }
                }
            }
            var linkFromRAPointY, linkToRAPointY;
            if (fromRANoDistance === false) {
                if (fromCenterY < toCenterY) {
                    linkFromRAPointY = linkFromPoint.y + cornerFromGap;
                    if (fromCenterX < toCenterX) {
                        linkFromRAPointY += (siblingSize - linkIndex - 1) * linkGap;
                    } else {
                        linkFromRAPointY += linkIndex * linkGap;
                    }
                } else {
                    linkFromRAPointY = linkFromPoint.y - cornerFromGap;
                    if (fromCenterX < toCenterX) {
                        linkFromRAPointY -= (siblingSize - linkIndex - 1) * linkGap;
                    } else {
                        linkFromRAPointY -= linkIndex * linkGap;
                    }
                }
            }
            if (toRANoDistance === false) {
                if (fromCenterY < toCenterY) {
                    linkToRAPointY = linkToPoint.y - cornerToGap;
                    if (fromCenterX < toCenterX) {
                        linkToRAPointY -= linkIndex * linkGap;
                    } else {
                        linkToRAPointY -= (siblingSize - linkIndex - 1) * linkGap;
                    }
                } else {
                    linkToRAPointY = linkToPoint.y + cornerToGap;
                    if (fromCenterX < toCenterX) {
                        linkToRAPointY += linkIndex * linkGap;
                    } else {
                        linkToRAPointY += (siblingSize - linkIndex - 1) * linkGap;
                    }
                }
            }
            if (fromRANoDistance === false) {
                if (toRANoDistance === true) {
                    linkToRAPointY = linkFromRAPointY;
                }
            } else {
                if (toRANoDistance === false) {
                    linkFromRAPointY = linkToRAPointY;
                } else {
                    linkToRAPointY = cornerY;
                    linkFromRAPointY = cornerY;
                }
            }
            linkFromRAPoint = {
                x: linkFromPoint.x,
                y: linkFromRAPointY
            };
            linkToRAPoint = {
                x: linkToPoint.x,
                y: linkToRAPointY
            };
            return [ linkFromPoint, linkFromRAPoint, linkToRAPoint, linkToPoint ];
        };
        var $CurveLinkPathCalculator = {
            calcLinkCurvePath: function(type, refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, curvature) {
                switch (type) {
                    case "quadratic":
                        return $CurveLinkPathCalculator.calcLinkQuadraticPath(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, curvature);

                    case "cubic":
                        return $CurveLinkPathCalculator.calcLinkCubicPath(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, curvature);
                }
            }
        };
        $CurveLinkPathCalculator.calcLinkCubicPath = function(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, curvature) {
            var points = $DefaultLinkPathCalculator.calcLinkDefaultPath(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds);
            if (curvature === 0) {
                return points;
            }
            var fromPoint = points[0];
            var toPoint = points[1];
            var angle = $mathCalcAngle(fromPoint, toPoint);
            var distance = $mathCalcDistance(fromPoint, toPoint);
            var offset = distance * curvature;
            var cpx = fromPoint.x + distance / 2;
            var cp1 = $MathPointUtil.calcRotatedPoint(fromPoint, {
                x: cpx,
                y: fromPoint.y - offset
            }, angle);
            var cp2 = $MathPointUtil.calcRotatedPoint(fromPoint, {
                x: cpx,
                y: fromPoint.y + offset
            }, angle);
            fromPoint.seg = "bezier_curve_to";
            return [ fromPoint, cp1, cp2, toPoint ];
        };
        $CurveLinkPathCalculator.calcLinkQuadraticPath = function(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds, curvature) {
            var points = $DefaultLinkPathCalculator.calcLinkDefaultPath(refLinkConfig, link, siblings, linkGap, fromBounds, toBounds);
            if (curvature === 0) {
                return points;
            }
            var fromPoint = points[0];
            var toPoint = points[1];
            var angle = $mathCalcAngle(fromPoint, toPoint);
            var distance = $mathCalcDistance(fromPoint, toPoint);
            var offset = distance * curvature;
            var cpx = fromPoint.x + distance / 2;
            var cp = $MathPointUtil.calcRotatedPoint(fromPoint, {
                x: cpx,
                y: fromPoint.y + offset
            }, angle);
            fromPoint.seg = "quadratic_curve_to";
            return [ fromPoint, cp, toPoint ];
        };
        var $ArrowCalculator = {
            calcArrowRenderProperties: function(arrow_shape, from_point, arrow_point, arrow_angle, arrow_offset, path_width, arrow_side_length) {
                if (arrow_offset !== 0) {
                    arrow_point = $MathLineUtil.calcOffsetPointOnLine(arrow_point, from_point, arrow_offset);
                }
                return $ArrowCalculator._calcShapeArrow(arrow_shape, from_point, arrow_point, path_width, arrow_side_length) || $ArrowCalculator._calcPathArrow(arrow_shape, from_point, arrow_point, arrow_angle, arrow_side_length);
            },
            calcArrowSizeLength: function(path_width, arrow_size) {
                arrow_size = parseFloat(arrow_size);
                path_width = parseFloat(path_width) + 2;
                return $MathFloor(path_width * (arrow_size * arrow_size / 32 + arrow_size / 16 + 1.9)) + 1;
            },
            _calcShapeArrow: function(arrow_shape, from_point, to_point, path_width, arrow_side_length) {
                arrow_side_length *= .8;
                var shape_width = arrow_side_length;
                var shape_height = arrow_side_length;
                if ([ "rect", "circle", "roundrect", "triangle", "right_triangle", "pentagon", "hexagon", "star", "parallelogram", "cloud", "ellipse", "diamond" ].indexOf(arrow_shape) > -1) {
                    var rotation = $mathCalcAngle(from_point, to_point);
                    if (arrow_shape === "circle") {
                        rotation = 0;
                    } else if (arrow_shape === "ellipse" || arrow_shape === "diamond") {
                        shape_width = shape_width * 1.2;
                    }
                    var shape_bounds = {
                        x: to_point.x - shape_width / 2,
                        y: to_point.y - shape_height / 2,
                        width: shape_width,
                        height: shape_height
                    };
                    var wholeRotationBounds = $MathRectUtil.calcRotatedRect(shape_bounds, rotation);
                    return {
                        type: "shape",
                        shape: arrow_shape,
                        shape_bounds: shape_bounds,
                        rotation: rotation,
                        bounds: wholeRotationBounds
                    };
                }
            },
            _calcPathArrow: function(arrow_shape, from_point, to_point, arrow_angle, arrow_side_length) {
                var points = $ArrowCalculator._calcArrowPoints(arrow_shape, from_point, to_point, arrow_side_length, arrow_angle, 0);
                if (points) {
                    var bounds = $MathPointUtil.calcPointsBounds(points);
                    return {
                        type: "path",
                        shape: arrow_shape,
                        points: points,
                        bounds: bounds
                    };
                }
            },
            _calcArrowPoints: function(arrow_shape, from_point, arrow_point, arrow_side_length, arrow_angle, arrow_offset) {
                if (arrow_offset != null && arrow_offset !== 0) {
                    arrow_point = $MathLineUtil.calcOffsetPointOnLine(arrow_point, from_point, arrow_offset);
                }
                var arrow_points = $ArrowCalculator._calcArrowAllPoints(from_point, arrow_point, arrow_side_length, arrow_angle);
                var points;
                switch (arrow_shape) {
                    case "open_arrow":
                        points = arrow_points.slice(0, 3);
                        break;

                    case "stealth_arrow":
                        points = arrow_points;
                        break;

                    case "arrow":
                        points = arrow_points.slice(0, 3);
                }
                if (points && arrow_shape !== "open_arrow") {
                    var lastPoint = points[points.length - 1];
                    if (lastPoint) {
                        lastPoint.seg = "close";
                    }
                }
                return points;
            },
            _calcArrowAllPoints: function(from_point, arrow_point, arrow_side_length, arrow_angle) {
                var fx = from_point.x;
                var fy = from_point.y;
                var r = $mathCalcDistance(from_point, arrow_point);
                var end_point = {
                    x: fx + r,
                    y: fy
                };
                var half_angle = $mathToRadians(arrow_angle / 2);
                var xl = arrow_side_length * $MathCos(half_angle);
                var yl = arrow_side_length * $MathSin(half_angle);
                var top_point = {
                    x: end_point.x - xl,
                    y: end_point.y - yl
                };
                var bottom_point = {
                    x: end_point.x - xl,
                    y: end_point.y + yl
                };
                var center_point = {
                    x: end_point.x - xl * 2 / 3,
                    y: fy
                };
                var rotation_angle = $mathCalcAngle(from_point, arrow_point);
                top_point = $MathPointUtil.calcRotatedPoint(from_point, top_point, rotation_angle);
                end_point = $MathPointUtil.calcRotatedPoint(from_point, end_point, rotation_angle);
                bottom_point = $MathPointUtil.calcRotatedPoint(from_point, bottom_point, rotation_angle);
                center_point = $MathPointUtil.calcRotatedPoint(from_point, center_point, rotation_angle);
                return [ top_point, end_point, bottom_point, center_point ];
            }
        };
        var $GroupCalculator = {
            calcGroupBounds: function(view, group, isExpand, bodyOnly) {
                var renderProps = $GroupCalculator.calcGroupRenderProperties(view, group, isExpand, bodyOnly);
                if (renderProps) {
                    return renderProps.bounds_render;
                }
            },
            calcGroupRenderProperties: function(view, group, isExpand, bodyOnly) {
                var expandProps = $GroupCalculator._calcGroupExpandRenderProps(view, group);
                var groupedChildrenBounds;
                if (expandProps) {
                    groupedChildrenBounds = expandProps.bounds;
                }
                if (groupedChildrenBounds == null) {
                    return $NodeCalculator.calcNodeRenderProperties(view, group, bodyOnly);
                }
                var bodyBounds;
                if (isExpand) {
                    bodyBounds = groupedChildrenBounds;
                } else {
                    var size = $NodeCalculator.calcNodeBodyBounds(view, group);
                    var width = size.width;
                    var height = size.height;
                    bodyBounds = {
                        x: groupedChildrenBounds.x + groupedChildrenBounds.width / 2 - width / 2,
                        y: groupedChildrenBounds.y + groupedChildrenBounds.height / 2 - height / 2,
                        width: width,
                        height: height
                    };
                }
                if (bodyOnly !== true) {
                    var outlineBounds = $NodeCalculator._calcNodeOutlineBounds(view, group, bodyBounds);
                    var labelRenderProps = $LabelCalculator.calcNodeLabelRenderProperties(view, group, bodyBounds);
                    if (labelRenderProps) {
                        var labelBounds = labelRenderProps.bounds;
                    }
                    var infoRenderProps = $InfoCalculator.calcNodeInfoRenderProperties(view, group, bodyBounds);
                    if (infoRenderProps) {
                        var infoBounds = infoRenderProps.bounds;
                    }
                    var borderBounds = $NodeCalculator._calcNodeBorderBounds(view, group, bodyBounds, outlineBounds);
                }
                var boundsArr = $filterArray([ bodyBounds, outlineBounds, labelBounds, infoBounds ], function(item) {
                    return item != null;
                });
                var wholeBounds = $MathRectUtil.calcRectsUnion(boundsArr);
                var rotation = 0;
                if (!isExpand) {
                    rotation = parseFloat($GViewUtil.getNodeViewProperty(view, group, "rotation")) || 0;
                }
                var bodyCenter = $MathRectUtil.getRectCenter(bodyBounds);
                return {
                    is_group: true,
                    expand_render_props: expandProps,
                    body_bounds: bodyBounds,
                    body_bounds_render: $MathRectUtil.calcRotatedRect(bodyBounds, rotation, bodyCenter),
                    outline_bounds: outlineBounds,
                    outline_bounds_render: $MathRectUtil.calcRotatedRect(outlineBounds, rotation, bodyCenter),
                    border_bounds: $MathRectUtil.calcRotatedRect(borderBounds, rotation, bodyCenter),
                    label_render_props: labelRenderProps,
                    info_render_props: infoRenderProps,
                    bounds: wholeBounds,
                    bounds_render: $MathRectUtil.calcRotatedRect(wholeBounds, rotation, bodyCenter)
                };
            },
            _calcGroupExpandRenderProps: function(view, group) {
                var childrenPoints = $GroupCalculator._calcGroupedChildrenPoints(view, group);
                if (childrenPoints.length === 0) {
                    return null;
                }
                var childrenBounds = $MathPointUtil.calcPointsBounds(childrenPoints);
                var center = {
                    x: childrenBounds.x + childrenBounds.width / 2,
                    y: childrenBounds.y + childrenBounds.height / 2
                };
                var shape = $GViewUtil.getGroupViewProperty(view, group, "expand_shape");
                var type = "shape", points;
                var bodyBounds;
                switch (shape) {
                    case "rect":
                        bodyBounds = childrenBounds;
                        break;

                    case "circle":
                        var radius = $mathCalcDistance({
                            x: childrenBounds.x,
                            y: childrenBounds.y
                        }, center);
                        bodyBounds = {
                            x: center.x - radius,
                            y: center.y - radius,
                            width: radius * 2,
                            height: radius * 2
                        };
                        break;

                    case "ellipse":
                        var a = $MathSqrt(2) / 2 * childrenBounds.width;
                        var b = $MathSqrt(2) / 2 * childrenBounds.height;
                        bodyBounds = {
                            x: center.x - a,
                            y: center.y - b,
                            width: a * 2,
                            height: b * 2
                        };
                        break;

                    case "roundrect":
                        var maxRadius = 0;
                        var radii = $C2DUtil.getRoundRectRadii(childrenBounds, $GViewUtil.getGroupViewProperty(view, group, "expand_roundrect_radius"));
                        if (radii && radii.length > 0) {
                            maxRadius = $MathMax.apply(null, radii);
                            maxRadius = maxRadius * (1 - $MathCos($mathToRadians(45)));
                        }
                        if (maxRadius > 0) {
                            bodyBounds = $MathRectUtil.createGrowRect(childrenBounds, maxRadius);
                        }
                        break;

                    case "parallelogram":
                        type = "path";
                        points = $MathPointUtil.calcParallelogramPoints(childrenPoints, $GViewUtil.getGroupViewProperty(view, group, "expand_parallelogram_angle") | 0);
                        break;

                    default:
                        type = "path";
                        points = $MathConvexHullUtil.convexHull(childrenPoints);
                }
                if (type === "path" && points != null) {
                    var last_point = points[points.length - 1];
                    if (last_point) {
                        last_point.seg = "close";
                    }
                    bodyBounds = $MathPointUtil.calcPointsBounds(points);
                }
                return {
                    type: type,
                    bounds: bodyBounds,
                    points: points
                };
            },
            _calcGroupedChildrenPoints: function(view, group) {
                var childrenNodes = $GroupUtil.getGroupVisibleNodes(view, group);
                var groupExpandGap = $GViewUtil.getGroupViewProperty(view, group, "expand_padding");
                groupExpandGap = groupExpandGap | 0;
                var points = [];
                childrenNodes.forEach(function(child) {
                    var bounds = child.getBounds(view, false);
                    if (bounds) {
                        points.push({
                            x: bounds.x - groupExpandGap,
                            y: bounds.y - groupExpandGap
                        });
                        points.push({
                            x: bounds.x - groupExpandGap,
                            y: bounds.y + bounds.height + groupExpandGap
                        });
                        points.push({
                            x: bounds.x + bounds.width + groupExpandGap,
                            y: bounds.y + bounds.height + groupExpandGap
                        });
                        points.push({
                            x: bounds.x + bounds.width + groupExpandGap,
                            y: bounds.y - groupExpandGap
                        });
                    }
                });
                return points;
            }
        };
        var $LabelCalculator = {
            calcNodeLabelRenderProperties: function(view, node, bodyBounds) {
                var labelSize = $LabelCalculator._calcLabelSize(view, node);
                if (labelSize == null) {
                    return null;
                }
                var labelWidth = labelSize.width;
                var labelHeight = labelSize.height;
                var bodyX = bodyBounds.x;
                var bodyY = bodyBounds.y;
                var bodyWidth = bodyBounds.width;
                var bodyHeight = bodyBounds.height;
                var labelGap = $GViewUtil.getDataViewLabelProperty(view, node, "label_gap") | 0;
                var labelOffset = $GViewUtil.getOffset(view, node, "label");
                var labelPosition = $GViewUtil.getDataViewLabelProperty(view, node, "label_position");
                var labelDirection = $GViewUtil.getDataViewLabelProperty(view, node, "label_direction");
                var labelX, labelY, labelXGapOffset = 0, labelYGapOffset = 0;
                switch (labelPosition) {
                    case "top":
                        labelX = bodyX + bodyWidth / 2;
                        labelY = bodyY;
                        labelDirection = labelDirection || "top";
                        if (labelDirection === "top") {
                            labelYGapOffset = -labelGap;
                        }
                        break;

                    case "left":
                        labelX = bodyX;
                        labelY = bodyY + bodyHeight / 2;
                        labelDirection = labelDirection || "left";
                        if (labelDirection === "left") {
                            labelXGapOffset = -labelGap;
                        }
                        break;

                    case "right":
                        labelX = bodyX + bodyWidth;
                        labelY = bodyY + bodyHeight / 2;
                        labelDirection = labelDirection || "right";
                        if (labelDirection === "right") {
                            labelXGapOffset = labelGap;
                        }
                        break;

                    case "center":
                        labelX = bodyX + bodyWidth / 2;
                        labelY = bodyY + bodyHeight / 2;
                        labelDirection = labelDirection || "center";
                        break;

                    default:
                        labelX = bodyX + bodyWidth / 2;
                        labelY = bodyY + bodyHeight;
                        labelDirection = labelDirection || "bottom";
                        if (labelDirection === "bottom") {
                            labelYGapOffset = labelGap;
                        }
                }
                labelX += labelXGapOffset + labelOffset.x;
                labelY += labelYGapOffset + labelOffset.y;
                var labelHDirection, labelVDirection;
                var labelBoundX, labelBoundY;
                switch (labelDirection) {
                    case "top":
                        labelHDirection = "center";
                        labelVDirection = "top";
                        labelBoundX = labelX - labelWidth / 2;
                        labelBoundY = labelY - labelHeight;
                        break;

                    case "bottom":
                        labelHDirection = "center";
                        labelVDirection = "bottom";
                        labelBoundX = labelX - labelWidth / 2;
                        labelBoundY = labelY;
                        break;

                    case "left":
                        labelHDirection = "left";
                        labelVDirection = "middle";
                        labelBoundX = labelX - labelWidth;
                        labelBoundY = labelY - labelHeight / 2;
                        break;

                    case "right":
                        labelHDirection = "right";
                        labelVDirection = "middle";
                        labelBoundX = labelX;
                        labelBoundY = labelY - labelHeight / 2;
                        break;

                    case "left_top":
                        labelHDirection = "left";
                        labelVDirection = "top";
                        labelBoundX = labelX - labelWidth;
                        labelBoundY = labelY - labelHeight;
                        break;

                    case "left_bottom":
                        labelHDirection = "left";
                        labelVDirection = "bottom";
                        labelBoundX = labelX - labelWidth;
                        labelBoundY = labelY;
                        break;

                    case "right_top":
                        labelHDirection = "right";
                        labelVDirection = "top";
                        labelBoundX = labelX;
                        labelBoundY = labelY - labelHeight;
                        break;

                    case "right_bottom":
                        labelHDirection = "right";
                        labelVDirection = "bottom";
                        labelBoundX = labelX;
                        labelBoundY = labelY;
                        break;

                    default:
                        labelHDirection = "center";
                        labelVDirection = "middle";
                        labelBoundX = labelX - labelWidth / 2;
                        labelBoundY = labelY - labelHeight / 2;
                }
                var labelBounds = {
                    x: labelBoundX,
                    y: labelBoundY,
                    width: labelWidth,
                    height: labelHeight
                };
                var label_rotation = parseFloat($GViewUtil.getNodeViewProperty(view, node, "label_rotation")) || 0;
                var renderProps = {
                    label: {
                        size: labelSize,
                        bounds: labelBounds,
                        bounds_render: $MathRectUtil.calcRotatedRect(labelBounds, label_rotation),
                        render_props: {
                            point: {
                                x: labelBoundX + labelWidth / 2,
                                y: labelBoundY + labelHeight / 2
                            },
                            direction: "center_middle",
                            bounds: labelBounds,
                            rotation: label_rotation
                        }
                    }
                };
                var label_box_bounds;
                if ($GViewUtil.getDataViewLabelProperty(view, node, "label_box_stroke") != null || $GViewUtil.getDataViewLabelProperty(view, node, "label_box_fill") != null) {
                    label_box_bounds = $MathRectUtil.createGrowRect(labelBounds, $GViewUtil.getDataViewLabelProperty(view, node, "label_box_padding") || 0);
                    renderProps.label_box = {
                        bounds: label_box_bounds,
                        bounds_render: $MathRectUtil.calcRotatedRect(label_box_bounds, label_rotation),
                        render_props: {
                            bounds: label_box_bounds,
                            rotation: label_rotation
                        }
                    };
                }
                if (label_box_bounds) {
                    renderProps.bounds = renderProps.label_box.bounds;
                    renderProps.bounds_render = renderProps.label_box.bounds_render;
                } else {
                    renderProps.bounds = renderProps.label.bounds;
                    renderProps.bounds_render = renderProps.label.bounds_render;
                }
                return renderProps;
            },
            calcLinkLabelRenderProperties: function(view, link, pathPoints) {
                var labelSize = $LabelCalculator._calcLabelSize(view, link);
                if (labelSize == null) {
                    return null;
                }
                var pathCenter;
                if (link.isLoop()) {
                    var bodyBounds = $MathPathUtil.calcPathBounds(pathPoints);
                    pathCenter = {
                        x: bodyBounds.x + bodyBounds.width / 2,
                        y: bodyBounds.y,
                        angle: 0
                    };
                } else {
                    pathCenter = $LabelCalculator._calcPathLabelCenter(pathPoints);
                }
                if (!pathCenter) {
                    return null;
                }
                var labelCenterX = pathCenter.x;
                var labelCenterY = pathCenter.y;
                var labelOffset = $GViewUtil.getOffset(view, link, "label");
                labelCenterX += labelOffset.x;
                labelCenterY += labelOffset.y;
                var labelAngle = 0;
                var label_rotation = $GViewUtil.getLinkViewProperty(view, link, "label_rotation");
                if (label_rotation === true) {
                    var pathCenterAngle = pathCenter.angle;
                    if (pathCenterAngle > 90 && pathCenterAngle <= 270) {
                        labelAngle = $mathTo360Degrees(pathCenterAngle - 180);
                    } else {
                        labelAngle = pathCenterAngle;
                    }
                }
                var labelCenterPoint = {
                    x: labelCenterX,
                    y: labelCenterY
                };
                var labelBounds = {
                    x: labelCenterX - labelSize.width / 2,
                    y: labelCenterY - labelSize.height / 2,
                    width: labelSize.width,
                    height: labelSize.height
                };
                var renderProps = {
                    label: {
                        size: labelSize,
                        bounds: labelBounds,
                        bounds_render: $MathRectUtil.calcRotatedRect(labelBounds, labelAngle)
                    }
                };
                renderProps.label.render_props = {
                    rotation: labelAngle,
                    point: labelCenterPoint,
                    direction: "center",
                    bounds: labelBounds
                };
                var label_box_bounds;
                if ($GViewUtil.getDataViewLabelProperty(view, link, "label_box_stroke") != null || $GViewUtil.getDataViewLabelProperty(view, link, "label_box_fill") != null) {
                    label_box_bounds = $MathRectUtil.createGrowRect(labelBounds, $GViewUtil.getDataViewLabelProperty(view, link, "label_box_padding") || 0);
                    renderProps.label_box = {
                        bounds: label_box_bounds,
                        bounds_render: $MathRectUtil.calcRotatedRect(label_box_bounds, labelAngle),
                        render_props: {
                            bounds: label_box_bounds,
                            rotation: labelAngle
                        }
                    };
                }
                if (label_box_bounds) {
                    renderProps.bounds = renderProps.label_box.bounds;
                    renderProps.bounds_render = renderProps.label_box.bounds_render;
                } else {
                    renderProps.bounds = renderProps.label.bounds;
                    renderProps.bounds_render = renderProps.label.bounds;
                }
                return renderProps;
            },
            _calcPathLabelCenter: function(pathPoints) {
                pathPoints = pathPoints || [];
                var pointSize = pathPoints.length;
                if (pointSize < 2) {
                    return null;
                }
                if (pointSize % 2 === 0) {
                    return $LabelCalculator._calcEvenPathLabelCenter(pathPoints);
                }
                return $LabelCalculator._calcOddPathLabelCenter(pathPoints);
            },
            _calcEvenPathLabelCenter: function(pathPoints) {
                var labelCenter, angle;
                var pointSize = pathPoints.length;
                var half = pointSize / 2 | 0;
                var previousCenterPoint = pathPoints[half - 1];
                var nextCenterPoint = pathPoints[half];
                var startPoint = pathPoints[half - 2];
                var endPoint = pathPoints[half + 1];
                if (startPoint && $PathUtil.isBezierCurveTo(startPoint.seg) && endPoint) {
                    labelCenter = $MathPathUtil.calcOffsetPointOnPath([ startPoint, previousCenterPoint, nextCenterPoint, endPoint ], .5, true);
                    angle = labelCenter.angle;
                } else {
                    labelCenter = $MathLineUtil.calcOffsetPointOnLine(previousCenterPoint, nextCenterPoint, .5, true);
                    angle = $mathCalcAngle(previousCenterPoint, nextCenterPoint);
                }
                labelCenter.angle = angle;
                return labelCenter;
            },
            _calcOddPathLabelCenter: function(pathPoints) {
                var labelCenter, angle;
                var pointSize = pathPoints.length;
                var half = pointSize / 2 | 0;
                var centerPoint = pathPoints[half];
                var startPoint = pathPoints[half - 1];
                var endPoint = pathPoints[half + 1];
                if ($PathUtil.isQuadraticCurveTo(startPoint.seg)) {
                    labelCenter = $MathPathUtil.calcOffsetPointOnPath([ startPoint, centerPoint, endPoint ], .5, true);
                    angle = labelCenter.angle;
                } else {
                    var refPoint;
                    if ($MathAbs(startPoint.y - centerPoint.y) < $MathAbs(endPoint.y - centerPoint.y)) {
                        refPoint = startPoint;
                    } else {
                        refPoint = endPoint;
                    }
                    labelCenter = $MathLineUtil.calcOffsetPointOnLine(centerPoint, refPoint, .5, true);
                    angle = $mathCalcAngle(refPoint, centerPoint);
                }
                labelCenter.angle = angle;
                return labelCenter;
            },
            _calcLabelSize: function(view, data) {
                var label = $GViewUtil.getDataViewVisibleLabel(view, data);
                if (label != null) {
                    return $C2DTextUtil.calcTextSize($GViewUtil.getFont($GViewUtil.getDataViewLabelProperty(view, data, "label_font")), label);
                }
            }
        };
        var $InfoCalculator = {
            calcNodeInfoRenderProperties: function(view, node, bodyBounds) {
                var infoSize = $InfoCalculator._calcInfoSize(view, node);
                if (infoSize == null) {
                    return null;
                }
                return $InfoCalculator._calcDataInfoRenderProperties(view, node, infoSize, bodyBounds.x + bodyBounds.width, bodyBounds.y);
            },
            calcLinkInfoRenderProperties: function(view, link, pathPoints) {
                var infoSize = $InfoCalculator._calcInfoSize(view, link);
                if (infoSize == null) {
                    return null;
                }
                var pathCenter;
                if (link.isLoop()) {
                    var bodyBounds = $MathPathUtil.calcPathBounds(pathPoints);
                    pathCenter = {
                        x: bodyBounds.x + bodyBounds.width / 2,
                        y: bodyBounds.y,
                        angle: 0
                    };
                } else {
                    pathCenter = $LabelCalculator._calcPathLabelCenter(pathPoints);
                }
                return $InfoCalculator._calcDataInfoRenderProperties(view, link, infoSize, pathCenter.x, pathCenter.y);
            },
            _calcDataInfoRenderProperties: function(view, data, infoSize, basePointX, basePointY) {
                var infoWidth = infoSize.width;
                var infoHeight = infoSize.height;
                var infoOffset = $GViewUtil.getOffset(view, data, "info");
                var info_box_padding = $GViewUtil.getDataViewInfoProperty(view, data, "info_box_padding") | 0;
                var tailLen = $MathMin(10, (infoWidth + info_box_padding) / 3);
                var infoCenterX = basePointX + infoOffset.x;
                var infoCenterY = basePointY - tailLen - infoHeight / 2 - info_box_padding + infoOffset.y;
                var infoBoundX = infoCenterX - infoWidth / 2;
                var infoBoundY = infoCenterY - infoHeight / 2;
                var infoBounds = {
                    x: infoCenterX - infoWidth / 2,
                    y: infoCenterY - infoHeight / 2,
                    width: infoWidth,
                    height: infoHeight
                };
                var infoBoxBounds = {
                    x: infoBounds.x - info_box_padding,
                    y: infoBounds.y - info_box_padding,
                    width: infoWidth + info_box_padding * 2,
                    height: infoHeight + info_box_padding * 2
                };
                var tailStartPoint = {
                    x: infoCenterX,
                    y: infoCenterY + infoHeight / 2 + info_box_padding + tailLen
                };
                var tailTopPoint = {
                    x: infoCenterX,
                    y: infoCenterY + infoHeight / 2 + info_box_padding
                };
                var tailRightPoint = {
                    x: infoCenterX + tailLen,
                    y: infoCenterY + infoHeight / 2 + info_box_padding,
                    seg: "close"
                };
                var renderProps = {
                    info: {
                        size: infoSize,
                        bounds: infoBounds,
                        render_props: {
                            point: {
                                x: infoBoundX + infoWidth / 2,
                                y: infoBoundY + infoHeight / 2
                            },
                            direction: "center_middle",
                            bounds: infoBounds
                        }
                    }
                };
                if ($GViewUtil.getDataViewInfoProperty(view, data, "info_box_stroke") != null || $GViewUtil.getDataViewInfoProperty(view, data, "info_box_fill") != null) {
                    var info_box_points = [ tailStartPoint, tailTopPoint, {
                        x: infoCenterX - infoBoxBounds.width / 2,
                        y: infoCenterY + infoBoxBounds.height / 2
                    }, {
                        x: infoCenterX - infoBoxBounds.width / 2,
                        y: infoCenterY - infoBoxBounds.height / 2
                    }, {
                        x: infoCenterX + infoBoxBounds.width / 2,
                        y: infoCenterY - infoBoxBounds.height / 2
                    }, {
                        x: infoCenterX + infoBoxBounds.width / 2,
                        y: infoCenterY + infoBoxBounds.height / 2
                    }, tailRightPoint ];
                    var infoBoxPointsBounds = $MathPointUtil.calcPointsBounds(info_box_points);
                    renderProps.info_box = {
                        bounds: infoBoxPointsBounds,
                        render_props: {
                            bounds: infoBoxPointsBounds,
                            points: info_box_points
                        }
                    };
                }
                if (infoBoxPointsBounds) {
                    renderProps.bounds = renderProps.info_box.bounds;
                } else {
                    renderProps.bounds = renderProps.info.bounds;
                }
                return renderProps;
            },
            _calcInfoSize: function(view, data) {
                var info = $GViewUtil.getDataViewVisibleInfo(view, data);
                if (info != null) {
                    return $C2DTextUtil.calcTextSize($GViewUtil.getFont($GViewUtil.getDataViewLabelProperty(view, data, "info_font")), info);
                }
            }
        };
        var $LinkCalculator = {
            calcLinkBounds: function(view, link, bodyOnly) {
                var renderProps = $LinkCalculator.calcLinkRenderProperties(view, link, bodyOnly);
                if (renderProps) {
                    return renderProps.bounds;
                }
            },
            calcLinkPathPoints: function(view, link) {
                var _pathPoints = $LinkCalculator._calcLinkPathPoints(view, link);
                if (_pathPoints) {
                    return _pathPoints.points;
                }
            },
            calcLinkRenderProperties: function(view, link, bodyOnly) {
                var _pathPoints = $LinkCalculator._calcLinkPathPoints(view, link);
                var drawPoints, pathPoints;
                if (_pathPoints) {
                    drawPoints = _pathPoints.draw_points;
                    pathPoints = _pathPoints.points;
                }
                if (pathPoints && pathPoints.length > 1) {
                    var bodyBounds = $MathPathUtil.calcPathBounds(pathPoints);
                    if (bodyBounds) {
                        if (bodyOnly !== true) {
                            var linkArrowRenderProps = $LinkCalculator._calcLinkArrowRenderProps(view, link, pathPoints);
                            if (linkArrowRenderProps) {
                                var linkArrowBounds = linkArrowRenderProps.bounds;
                            }
                            var labelRenderProps = $LabelCalculator.calcLinkLabelRenderProperties(view, link, pathPoints);
                            if (labelRenderProps) {
                                var labelBounds = labelRenderProps.bounds;
                            }
                            var infoRenderProps = $InfoCalculator.calcLinkInfoRenderProperties(view, link, pathPoints);
                            if (infoRenderProps) {
                                var infoBounds = infoRenderProps.bounds;
                            }
                        }
                    }
                    var boundsArr = $filterArray([ bodyBounds, linkArrowBounds, labelBounds, infoBounds ], function(item) {
                        return item != null;
                    });
                    var bounds = $MathRectUtil.calcRectsUnion(boundsArr);
                    return {
                        body_bounds: bodyBounds,
                        points: pathPoints,
                        draw_points: drawPoints,
                        label_render_props: labelRenderProps,
                        info_render_props: infoRenderProps,
                        arrow_render_props: linkArrowRenderProps,
                        bounds: bounds
                    };
                }
                return null;
            },
            _calcLinkPathPoints: function(view, link) {
                var from = link.getProperty("from");
                var to = link.getProperty("to");
                if (from == null || to == null) {
                    return null;
                }
                var link_gap = view ? view.getProperty("link_gap") : 16;
                var linkPathPoints, linkPathDrawPoints;
                if (link.getPath) {
                    linkPathPoints = link.getPath();
                } else {
                    var siblings;
                    if (link.isLoop()) {
                        siblings = $LinkUtil.getLoopSibling(view, link);
                        linkPathPoints = $LoopLinkPathCalculator.calcLinkLoopPath(link, siblings, link_gap, from.getBounds(view));
                    } else {
                        from = $LinkUtil.getFromNodeAgent(view, link);
                        to = $LinkUtil.getToNodeAgent(view, link);
                        if (from == null || to == null) {
                            return null;
                        }
                        var ftBounds = $LinkCalculator._calcLinkEdgeBounds(view, link, from, to);
                        var fromBounds = ftBounds.from;
                        var toBounds = ftBounds.to;
                        var linkType = $GViewUtil.getLinkViewProperty(view, link, "type");
                        var sameDirection = $LinkCalculator._isSameDirectionLinkType(linkType);
                        siblings = $LinkUtil.getSiblingByType(view, link, sameDirection);
                        if (linkType) {
                            linkPathPoints = $RALinkPathCalculator.calcLinkRAPath(linkType, link, siblings, link_gap, fromBounds, toBounds, {
                                from_corner_distance: $GViewUtil.getLinkViewProperty(view, link, "from_corner_distance"),
                                to_corner_distance: $GViewUtil.getLinkViewProperty(view, link, "to_corner_distance")
                            });
                            if (!linkPathPoints) {
                                if (linkType === "quadratic") {
                                    var refLink = siblings[0];
                                    var refFrom = $LinkUtil.getFromNodeAgent(view, refLink);
                                    var sameSiblings = [];
                                    var deffSiblings = [];
                                    siblings.forEach(function(link) {
                                        if ($LinkUtil.getFromNodeAgent(view, link) === refFrom) {
                                            sameSiblings.push(link);
                                        } else {
                                            deffSiblings.push(link);
                                        }
                                    });
                                    siblings = $mergeArray(sameSiblings, deffSiblings);
                                }
                                linkPathPoints = $CurveLinkPathCalculator.calcLinkCurvePath(linkType, $LinkCalculator._calcRefLinkPathConfig(view, link, siblings, from, to, fromBounds, toBounds), link, siblings, link_gap, fromBounds, toBounds, $GViewUtil.getLinkViewProperty(view, link, "curvature"));
                            }
                        }
                        if (linkPathPoints == null) {
                            linkPathPoints = $DefaultLinkPathCalculator.calcLinkDefaultPath($LinkCalculator._calcRefLinkPathConfig(view, link, siblings, from, to, fromBounds, toBounds), link, siblings, link_gap, fromBounds, toBounds, $GViewUtil.getLinkViewProperty(view, link, "corner_offset") | 0);
                        }
                        if (linkPathPoints) {
                            linkPathDrawPoints = $MathPathUtil.roundPath(linkPathPoints, $GViewUtil.getLinkViewProperty(view, link, "corner_radius") | 0);
                        }
                    }
                }
                return {
                    points: linkPathPoints,
                    draw_points: linkPathDrawPoints || linkPathPoints
                };
            },
            _isSameDirectionLinkType: function(linkType) {
                return [ "ra_hv", "ra_vh" ].indexOf(linkType) > -1;
            },
            _calcLinkEdgeBounds: function(view, link, from, to) {
                var fromBounds = from.getBounds(view);
                var toBounds = to.getBounds(view);
                var from_offset = $GViewUtil.getLinkViewProperty(view, link, "from_offset") | 0;
                var to_offset = $GViewUtil.getLinkViewProperty(view, link, "to_offset") | 0;
                var from_offset_x = $GViewUtil.getLinkViewProperty(view, link, "from_offset_x") | 0;
                var from_offset_y = $GViewUtil.getLinkViewProperty(view, link, "from_offset_y") | 0;
                var to_offset_x = $GViewUtil.getLinkViewProperty(view, link, "to_offset_x") | 0;
                var to_offset_y = $GViewUtil.getLinkViewProperty(view, link, "to_offset_y") | 0;
                var fromCenter = {
                    x: fromBounds.x + fromBounds.width / 2,
                    y: fromBounds.y + fromBounds.height / 2
                }, toCenter = {
                    x: toBounds.x + toBounds.width / 2,
                    y: toBounds.y + toBounds.height / 2
                };
                if (from_offset !== 0) {
                    fromCenter = $MathPointUtil.calcPointOnCircle(fromCenter, from_offset, $mathCalcAngle(fromCenter, toCenter));
                }
                if (to_offset !== 0) {
                    toCenter = $MathPointUtil.calcPointOnCircle(toCenter, to_offset, $mathCalcAngle(toCenter, fromCenter));
                }
                fromCenter.x += from_offset_x;
                fromCenter.y += from_offset_y;
                toCenter.x += to_offset_x;
                toCenter.y += to_offset_y;
                return {
                    from: {
                        x: fromCenter.x - fromBounds.width / 2,
                        y: fromCenter.y - fromBounds.height / 2,
                        width: fromBounds.width,
                        height: fromBounds.height
                    },
                    to: {
                        x: toCenter.x - toBounds.width / 2,
                        y: toCenter.y - toBounds.height / 2,
                        width: toBounds.width,
                        height: toBounds.height
                    }
                };
            },
            _calcRefLinkPathConfig: function(view, link, siblings, from, to, fromBounds, toBounds) {
                var refLink = siblings[0];
                var refLinkFrom, refLinkTo;
                if (refLink !== link) {
                    refLinkFrom = $LinkUtil.getFromNodeAgent(view, refLink);
                } else {
                    refLinkFrom = from;
                }
                var same_direction = from === refLinkFrom;
                var refFromBounds, refToBounds;
                if (same_direction) {
                    refLinkTo = to;
                    refFromBounds = fromBounds;
                    refToBounds = toBounds;
                } else {
                    refLinkTo = from;
                    refFromBounds = toBounds;
                    refToBounds = fromBounds;
                }
                var fromIsPath = refLinkFrom.getType() === "path";
                var toIsPath = refLinkTo.getType() === "path";
                if (fromIsPath && toIsPath) {
                    fromIsPath = false;
                    toIsPath = false;
                }
                var fromPoint, toPoint;
                var refFromPointBounds, refToPointBounds;
                if (fromIsPath) {
                    fromPoint = $MathPathUtil.calcPointToPathClosestPoint($MathRectUtil.getRectCenter(refToBounds), refLinkFrom.get("points"));
                    refFromPointBounds = {
                        x: fromPoint.x,
                        y: fromPoint.y,
                        width: 0,
                        height: 0
                    };
                }
                if (toIsPath) {
                    toPoint = $MathPathUtil.calcPointToPathClosestPoint($MathRectUtil.getRectCenter(refFromBounds), refLinkTo.get("points"));
                    refToPointBounds = {
                        x: toPoint.x,
                        y: toPoint.y,
                        width: 0,
                        height: 0
                    };
                }
                if (!fromIsPath) {
                    fromPoint = $DefaultLinkPathCalculator._getPositionPoint(refFromBounds, refToPointBounds || refToBounds, $GViewUtil.getLinkViewProperty(view, refLink, "from_position"));
                }
                if (!toIsPath) {
                    toPoint = $DefaultLinkPathCalculator._getPositionPoint(refToBounds, refFromPointBounds || refFromBounds, $GViewUtil.getLinkViewProperty(view, refLink, "to_position"));
                }
                return {
                    from: fromPoint,
                    to: toPoint,
                    same_direction: same_direction
                };
            },
            _calcLinkArrowRenderProps: function(view, link, linkPathPoints) {
                linkPathPoints = linkPathPoints || [];
                var size = linkPathPoints.length;
                if (size < 2) {
                    return {};
                }
                var link_width = $GViewUtil.getLinkViewProperty(view, link, "stroke_line_width");
                var link_from_arrow_shape = $GViewUtil.getLinkViewProperty(view, link, "from_arrow_shape");
                var link_to_arrow_shape = $GViewUtil.getLinkViewProperty(view, link, "to_arrow_shape");
                var fromArrowProps, toArrowProps;
                if (link_from_arrow_shape) {
                    var from_arrow_offset = $GViewUtil.getLinkViewProperty(view, link, "from_arrow_offset");
                    var fromArrowPoint = $MathPathUtil.calcOffsetPointOnPath(linkPathPoints, from_arrow_offset, true);
                    if (fromArrowPoint) {
                        var fromArrowStartPoint = $MathPointUtil.calcPointOnCircle(fromArrowPoint, 2, fromArrowPoint.angle);
                        fromArrowProps = $ArrowCalculator.calcArrowRenderProperties(link_from_arrow_shape, fromArrowStartPoint, fromArrowPoint, $GViewUtil.getLinkViewProperty(view, link, "from_arrow_angle"), 0, link_width, $ArrowCalculator.calcArrowSizeLength(link_width, $GViewUtil.getLinkViewProperty(view, link, "from_arrow_size")));
                    }
                }
                if (link_to_arrow_shape) {
                    var to_arrow_offset = $GViewUtil.getLinkViewProperty(view, link, "to_arrow_offset");
                    if (to_arrow_offset <= 1 && to_arrow_offset >= 0) {
                        to_arrow_offset = 1 - to_arrow_offset;
                    } else {
                        var length = $MathPathUtil.calcPathLength(linkPathPoints);
                        to_arrow_offset = $MathMax(length - to_arrow_offset, 0);
                    }
                    var toArrowPoint = $MathPathUtil.calcOffsetPointOnPath(linkPathPoints, to_arrow_offset, true);
                    if (toArrowPoint) {
                        var toArrowStartPoint = $MathPointUtil.calcPointOnCircle(toArrowPoint, 2, toArrowPoint.angle + 180);
                        toArrowProps = $ArrowCalculator.calcArrowRenderProperties(link_to_arrow_shape, toArrowStartPoint, toArrowPoint, $GViewUtil.getLinkViewProperty(view, link, "to_arrow_angle"), 0, link_width, $ArrowCalculator.calcArrowSizeLength(link_width, $GViewUtil.getLinkViewProperty(view, link, "to_arrow_size")));
                    }
                }
                var boundsArr = [];
                if (fromArrowProps) {
                    boundsArr.push(fromArrowProps.bounds);
                }
                if (toArrowProps) {
                    boundsArr.push(toArrowProps.bounds);
                }
                return {
                    from: fromArrowProps,
                    to: toArrowProps,
                    bounds: $MathRectUtil.calcRectsUnion(boundsArr)
                };
            }
        };
        var $NodeCalculator = {
            calcNodeBounds: function(view, node, bodyOnly) {
                var renderProps = $NodeCalculator.calcNodeRenderProperties(view, node, bodyOnly);
                if (renderProps) {
                    return renderProps.bounds_render;
                }
            },
            calcNodeRenderProperties: function(view, node, bodyOnly) {
                var bodyBounds = $NodeCalculator.calcNodeBodyBounds(view, node);
                if (bodyBounds == null) {
                    return null;
                }
                if (bodyOnly !== true) {
                    var type = node.getType();
                    if (type === "path") {
                        var pathArrowRenderProps = $NodeCalculator._calcPathArrowRenderProps(view, node, $NodeCalculator._getNodePoints(node));
                        if (pathArrowRenderProps) {
                            var pathArrowBounds = pathArrowRenderProps.bounds;
                        }
                    }
                    var outlineBounds = $NodeCalculator._calcNodeOutlineBounds(view, node, bodyBounds);
                    var labelRenderProps = $LabelCalculator.calcNodeLabelRenderProperties(view, node, bodyBounds);
                    if (labelRenderProps) {
                        var labelBounds = labelRenderProps.bounds;
                    }
                    var infoRenderProps = $InfoCalculator.calcNodeInfoRenderProperties(view, node, bodyBounds);
                    if (infoRenderProps) {
                        var infoBounds = infoRenderProps.bounds;
                    }
                    var borderBounds = $NodeCalculator._calcNodeBorderBounds(view, node, bodyBounds, outlineBounds);
                    if (borderBounds && (type === "path" || type === "shape")) {
                        var stroke_line_width = $GViewUtil.getNodeViewProperty(view, node, "stroke_line_width") || 0;
                        borderBounds = $MathRectUtil.createGrowRect(borderBounds, stroke_line_width / 2);
                    }
                }
                var boundsArr = $filterArray([ bodyBounds, pathArrowBounds, outlineBounds, labelBounds, infoBounds ], function(item) {
                    return item != null;
                });
                var wholeBounds = $MathRectUtil.calcRectsUnion(boundsArr);
                var rotation = parseFloat($GViewUtil.getNodeViewProperty(view, node, "rotation")) || 0;
                var bodyCenter = $MathRectUtil.getRectCenter(bodyBounds);
                return {
                    body_bounds: bodyBounds,
                    body_bounds_render: $MathRectUtil.calcRotatedRect(bodyBounds, rotation, bodyCenter),
                    outline_bounds: outlineBounds,
                    outline_bounds_render: $MathRectUtil.calcRotatedRect(outlineBounds, rotation, bodyCenter),
                    border_bounds: $MathRectUtil.calcRotatedRect(borderBounds, rotation, bodyCenter),
                    label_render_props: labelRenderProps,
                    info_render_props: infoRenderProps,
                    path_arrow_render_props: pathArrowRenderProps,
                    bounds: wholeBounds,
                    bounds_render: $MathRectUtil.calcRotatedRect(wholeBounds, rotation, bodyCenter)
                };
            },
            _calcNodeBorderBounds: function(view, node, bodyBounds, outlineBounds) {
                var bounds = outlineBounds || bodyBounds;
                if (bounds && (bounds.width > 0 || bounds.height > 0)) {
                    bounds = $MathRectUtil.createGrowRect(bounds, ($GViewUtil.getNodeViewProperty(view, node, "select_border_padding", "select_border_padding") | 0) + ($GViewUtil.getNodeViewProperty(view, node, "select_border_stroke_line_width", "select_border_stroke_line_width") | 0));
                    return bounds;
                }
            },
            _calcNodeOutlineBounds: function(view, node, bodyBounds) {
                if (bodyBounds && bodyBounds.width > 0 && bodyBounds.height > 0) {
                    if ($GViewUtil.getNodeViewProperty(view, node, "outline_stroke")) {
                        return $MathRectUtil.createGrowRect(bodyBounds, ($GViewUtil.getNodeViewProperty(view, node, "outline_padding") | 0) + ($GViewUtil.getNodeViewProperty(view, node, "outline_stroke_line_width") | 0));
                    }
                }
            },
            calcNodeBodyBounds: function(view, node) {
                var type = node.getType();
                var bodyBounds;
                if (type === "path") {
                    bodyBounds = $MathPathUtil.calcPathBounds($NodeCalculator._getNodePoints(node));
                } else if (type === "heatmap") {
                    var heatmap_radius = $GViewUtil.getNodeViewProperty(view, node, "heatmap_radius");
                    bodyBounds = $HeatMapUtil.calcHMPointsBounds($NodeCalculator._getNodePoints(node), heatmap_radius);
                } else {
                    bodyBounds = $NodeCalculator._getShapeAndImageNodeBounds(view, node);
                }
                return bodyBounds;
            },
            _getShapeAndImageNodeBounds: function(view, node) {
                var size = $NodeCalculator._getShapeAndImageNodeSize(view, node);
                size.width = parseFloat(size.width) || 0;
                size.height = parseFloat(size.height) || 0;
                return {
                    x: parseFloat(node.getProperty("x")) || 0,
                    y: parseFloat(node.getProperty("y")) || 0,
                    width: parseFloat(size.width) || 0,
                    height: parseFloat(size.height) || 0
                };
            },
            _getShapeAndImageNodeSize: function(view, node) {
                return {
                    width: $NodeUtil.getSizeProperty(view, node, "width"),
                    height: $NodeUtil.getSizeProperty(view, node, "height")
                };
            },
            _calcPathArrowRenderProps: function(view, node, pathPoints) {
                pathPoints = pathPoints || [];
                var size = pathPoints.length;
                if (size < 2) {
                    return null;
                }
                var path_width = $GViewUtil.getNodeViewProperty(view, node, "stroke_line_width");
                var path_begin_arrow_shape = $GViewUtil.getNodeViewProperty(view, node, "begin_arrow_shape");
                var beginArrowProps, endArrowProps;
                if (path_begin_arrow_shape) {
                    var begin_arrow_offset = $GViewUtil.getNodeViewProperty(view, node, "begin_arrow_offset");
                    var beginArrowPoint = $MathPathUtil.calcOffsetPointOnPath(pathPoints, begin_arrow_offset, true);
                    if (beginArrowPoint) {
                        var beginArrowStartPoint = $MathPointUtil.calcPointOnCircle(beginArrowPoint, 2, beginArrowPoint.angle);
                        beginArrowProps = $ArrowCalculator.calcArrowRenderProperties(path_begin_arrow_shape, beginArrowStartPoint, beginArrowPoint, $GViewUtil.getNodeViewProperty(view, node, "begin_arrow_angle"), 0, path_width, $ArrowCalculator.calcArrowSizeLength(path_width, $GViewUtil.getNodeViewProperty(view, node, "begin_arrow_size")));
                    }
                }
                var path_end_arrow_shape = $GViewUtil.getNodeViewProperty(view, node, "end_arrow_shape");
                if (path_end_arrow_shape) {
                    var end_arrow_offset = $GViewUtil.getNodeViewProperty(view, node, "end_arrow_offset");
                    if (end_arrow_offset <= 1 && end_arrow_offset >= 0) {
                        end_arrow_offset = 1 - end_arrow_offset;
                    } else {
                        var length = $MathPathUtil.calcPathLength(pathPoints);
                        end_arrow_offset = $MathMax(length - end_arrow_offset, 0);
                    }
                    var endArrowPoint = $MathPathUtil.calcOffsetPointOnPath(pathPoints, end_arrow_offset, true);
                    if (endArrowPoint) {
                        var endArrowStartPoint = $MathPointUtil.calcPointOnCircle(endArrowPoint, 2, endArrowPoint.angle + 180);
                        endArrowProps = $ArrowCalculator.calcArrowRenderProperties(path_end_arrow_shape, endArrowStartPoint, endArrowPoint, $GViewUtil.getNodeViewProperty(view, node, "end_arrow_angle"), 0, path_width, $ArrowCalculator.calcArrowSizeLength(path_width, $GViewUtil.getNodeViewProperty(view, node, "end_arrow_size")));
                    }
                }
                var boundsArr = [];
                if (beginArrowProps) {
                    boundsArr.push(beginArrowProps.bounds);
                }
                if (endArrowProps) {
                    boundsArr.push(endArrowProps.bounds);
                }
                return {
                    begin: beginArrowProps,
                    end: endArrowProps,
                    bounds: $MathRectUtil.calcRectsUnion(boundsArr)
                };
            },
            _getNodePoints: function(node) {
                return node.getProperty("points") || [];
            }
        };
        var $GVLevelInterface = function(clazz) {
            return $mergeObject({
                _isSuperVisible: function(data) {
                    return clazz.superClass._isVisible.apply(this, arguments);
                },
                _isVisible: function(data) {
                    if (this._isVisible_(data) === false) {
                        return false;
                    }
                    var isLink = $isLink(data);
                    if (isLink) {
                        var linkFrom = $LinkUtil.getFromNodeAgent(this, data);
                        if (linkFrom == null || this._isVisible(linkFrom) === false) {
                            return false;
                        }
                        var linkTo = $LinkUtil.getToNodeAgent(this, data);
                        if (linkTo == null || this._isVisible(linkTo) === false) {
                            return false;
                        }
                        if (linkFrom === linkTo) {
                            if (data.get("from") !== linkFrom || data.get("from") !== linkTo) {
                                return false;
                            }
                        }
                        if (this._hasLinkBundled() && this.isLinkBundled(data)) {
                            if (!this._isLinkBundleAgent(data)) {
                                return false;
                            }
                        }
                    }
                    if ($isNode(data) && this.getCurrentSubview() != $SubviewUtil.getDataSubview(data)) {
                        return false;
                    }
                    var groupArr = $GroupUtil.getGroupAncestorArray(data);
                    var isAllGroupExpand = true;
                    groupArr.forEach(function(group) {
                        isAllGroupExpand = isAllGroupExpand && this.isExpanded(group);
                    }, this);
                    if (isAllGroupExpand !== true) {
                        return false;
                    }
                    var aArr = $SubviewUtil.getSameSubviewAncestorArray(data);
                    var isAncestorVisible = true;
                    aArr.forEach(function(ancestor) {
                        isAncestorVisible = isAncestorVisible && this._isVisible(ancestor);
                    }, this);
                    if (isAncestorVisible !== true) {
                        return false;
                    }
                    return true;
                }
            }, {
                afterSetProperty: function(key, value, old) {
                    clazz.superClass.afterSetProperty.apply(this, arguments);
                    if (key === "current_subview") {
                        this._updateSubviewTransform(value, old);
                    }
                },
                setCurrentSubview: function(subview) {
                    if ((subview == null || $isSubview(subview)) && this.getCurrentSubview() != subview) {
                        this.setProperty("current_subview", subview);
                    }
                },
                getCurrentSubview: function() {
                    return this.getProperty("current_subview");
                },
                _updateSubviewTransform: function(newSubview, oldSubview) {
                    var oldID = null;
                    if (oldSubview) {
                        oldID = oldSubview.id();
                    } else {
                        oldID = "default";
                    }
                    this._subViewTransform[oldID] = {
                        zoom: this.get("zoom"),
                        translate_x: this.get("translate_x"),
                        translate_y: this.get("translate_y")
                    };
                    var vID = null;
                    if (newSubview) {
                        vID = newSubview.id();
                    } else {
                        vID = "default";
                    }
                    var transform = this._subViewTransform[vID];
                    if (transform == null) {
                        transform = {
                            zoom: 1,
                            translate_x: 0,
                            translate_y: 0
                        };
                    }
                    this.set(transform);
                }
            }, $ExpandInterface(clazz), {
                expandAll: function(onlyVisible) {
                    var expandArray = this.getDataArray(false);
                    if (onlyVisible !== false) {
                        expandArray = $filterArray(expandArray, this._isVisible_, this);
                    }
                    return this._expandProvider.set(this._filterExpandableData(expandArray));
                },
                _isExpandable: function(data) {
                    if (!$isGroup(data)) {
                        return false;
                    }
                    return this.isExpandable.apply(this, arguments);
                },
                _addExpandNeedUpdateData: function(data) {
                    this._addNeedUpdateData(data, true, true);
                }
            }, {
                _getDataRelatedDataArray: function(data, ancestorRelated, descendantRelated) {
                    var arr = [];
                    if ($isNode(data)) {
                        arr = $mergeArray(arr, $DataLevelUtil.getAddedDescendantArray(this.getProvider(), data), $DataLevelUtil.getAncestorArray(data));
                        arr = $mergeArray(arr, $LinkUtil.getNodeAgentLinks(this, data));
                    } else if ($isLink(data)) {
                        arr = $LinkUtil.getSibling(this, data);
                    }
                    arr.forEach(function(data) {
                        if ($isNode(data)) {
                            arr.push.apply(arr, $LinkUtil.getNodeAgentLinks(this, data));
                        }
                    }, this);
                    return arr;
                }
            });
        };
        var $LinkBundleInterface = function(clazz) {
            return {
                _isLinkBundle_: true,
                _isLinkBundleable: function(link) {
                    return this.isLinkBundleable(link);
                },
                isLinkBundleable: function(link) {
                    return this.getDataViewProperty(link, "bundleable", "link_bundleable") !== false;
                },
                _updateLinkBundleProvider: function() {
                    this._removeLinkBundleProviderListener();
                    if (this._provider) {
                        if (!this._linkBundleProvider) {
                            this._linkBundleProvider = new $IAttachProvider(this._provider);
                            var _this = this;
                            this._linkBundleProvider.onProviderChange = function(e) {
                                if (e.type === "remove") {
                                    var data = e.data;
                                    var bundleArr = _this.getLinkBundles(data);
                                    if (bundleArr.length < 3) {
                                        $arrayRemoveItem(bundleArr, data);
                                        _this._removeLinkBundle(bundleArr);
                                    }
                                }
                            };
                            this._linkBundleProvider.onDataChange = function(e) {
                                if (_this._hasLinkBundled()) {
                                    var data = e.source;
                                    if ($isLink(data) && _this.isLinkBundled(data)) {
                                        _this.getLinkBundles(data).forEach(function(link) {
                                            _this._addLinkBundleNeedUpdateData(link);
                                        });
                                    }
                                }
                            };
                        }
                        this._linkBundleProvider.setProvider(this._provider);
                        this._addLinkBundleProviderListener();
                    }
                },
                _removeLinkBundleProviderListener: function() {
                    if (this._linkBundleProvider) {
                        this._linkBundleProvider.removeProviderChangeListener(this._handleLinkBundleProviderChange, this);
                    }
                },
                _addLinkBundleProviderListener: function() {
                    this._linkBundleProvider.addProviderChangeListener(this._handleLinkBundleProviderChange, this);
                },
                _handleLinkBundleProviderChange: function(evt) {
                    var type = evt.type;
                    if (type === "add") {
                        this._onLinkBundleAdd(evt.data);
                    } else if (type === "remove") {
                        this._onLinkBundleRemove(evt.data);
                    } else if (type === "clear") {
                        this._onLinkBundleClear(evt.data);
                    } else if (type === "set") {
                        this._onLinkBundleSet(evt.data);
                    }
                    this._onLinkBundleChange(evt);
                },
                _addLinkBundleNeedUpdateData: function(data) {
                    this._addNeedUpdateData(data, false, false);
                },
                _onLinkBundleAdd: function(data) {
                    this._addLinkBundleNeedUpdateData(data);
                    this._callOn("onLinkBundle", "on.link.bundle.add", data, [ data ]);
                },
                onLinkBundle: function(listener, context) {
                    this.addListener("on.link.bundle.add", listener, context);
                },
                _onLinkBundleRemove: function(data) {
                    this._addLinkBundleNeedUpdateData(data, false);
                    this._callOn("onLinkUnbundle", "on.link.bundle.remove", data, [ data ]);
                },
                onLinkUnbundle: function(listener, context) {
                    this.addListener("on.link.bundle.remove", listener, context);
                },
                _onLinkBundleClear: function(dataArray) {
                    dataArray.forEach(this._addLinkBundleNeedUpdateData, this);
                    this._callOn("onLinkBundleClear", "on.link.bundle.clear", dataArray, [ dataArray ]);
                },
                onLinkBundleClear: function(listener, context) {
                    this.addListener("on.link.bundle.clear", listener, context);
                },
                _onLinkBundleSet: function(dataArray) {
                    dataArray.forEach(this._addLinkBundleNeedUpdateData, this);
                    this._callOn("onLinkBundleSet", "on.link.bundle.set", dataArray, [ dataArray ]);
                },
                onLinkBundleSet: function(listener, context) {
                    this.addListener("on.link.bundle.set", listener, context);
                },
                _onLinkBundleChange: function(evt) {
                    this._update();
                    this._callOn("onLinkBundleChange", "on.link.bundle.change", evt, [ evt ]);
                },
                onLinkBundleChange: function(listener, context) {
                    this.addListener("on.link.bundle.change", listener, context);
                },
                _hasLinkBundled: function() {
                    return this._linkBundleProvider.size() > 0;
                },
                isLinkBundled: function(data) {
                    data = this._getModelData(data);
                    if (data) {
                        return this._linkBundleProvider.contains(data);
                    }
                    return false;
                },
                _isLinkBundleAgent: function(link) {
                    if ($isLink(link)) {
                        return this.isLinkBundleAgent(link, this.getLinkBundles(link));
                    }
                    return false;
                },
                isLinkBundleAgent: function(link, currentLinkBounds) {
                    return link === currentLinkBounds[0];
                },
                getLinkBundleSize: function(link) {
                    return this.getLinkBundles(link).length;
                },
                getLinkBundles: function(link) {
                    var from = link.get("from");
                    var to = link.get("to");
                    if (from && to) {
                        var link_type = link.get("type");
                        var has_bundle_group = link.has("bundle_group");
                        var bundle_group = link.get("bundle_group");
                        var link_loop = link.isLoop();
                        return $filterArray(from.getLinksBetween(to), function(l) {
                            if (!this.containsData(l)) {
                                return false;
                            }
                            if (has_bundle_group || l.has("bundle_group")) {
                                return l.get("bundle_group") === bundle_group;
                            }
                            if (link_loop && l.isLoop()) {
                                return true;
                            }
                            var type = l.get("type");
                            if (type !== link_type) {
                                return false;
                            }
                            if (type === "ra_hv" || type === "ra_vh") {
                                return l.get("from") === from;
                            }
                            return true;
                        }, this);
                    }
                    return [];
                },
                _getLinkArrayBundles: function(links) {
                    var bundles = [];
                    links.forEach(function(link) {
                        var arr = this.getLinkBundles(link);
                        if (arr.length > 1) {
                            $mergeArray(bundles, arr);
                        }
                    }, this);
                    return bundles;
                },
                getLinkBundled: function(copy) {
                    return this._linkBundleProvider.toArray.apply(this._linkBundleProvider, arguments);
                },
                bundleLink: function(link) {
                    var arr = this._getModelDataArr(link, $isLink);
                    if (arr.length === 0) {
                        return;
                    }
                    return this._addLinkBundle(this._getLinkArrayBundles(arr));
                },
                unbundleLink: function(link, only) {
                    var arr = this._getModelDataArr(link, $isLink);
                    if (arr.length === 0) {
                        return;
                    }
                    var links;
                    if (only === true) {
                        links = [];
                        arr.forEach(function(link) {
                            var bundleArr = this.getLinkBundles(link);
                            if (bundleArr.length < 3) {
                                $mergeArray(links, bundleArr);
                            } else {
                                links.push(link);
                            }
                        }, this);
                    } else {
                        links = this._getLinkArrayBundles(arr);
                    }
                    return this._removeLinkBundle(links);
                },
                bundleAllLinks: function() {
                    var dataArray = this._getLinkArrayBundles($filterArray(this.getDataArray(false), $isLink));
                    return this._linkBundleProvider.set(this._filterLinkBundleableData(dataArray));
                },
                unbundleAllLinks: function() {
                    return this._linkBundleProvider.clear.apply(this._linkBundleProvider, arguments);
                },
                toggleLinkBundle: function(link) {
                    link = this._getModelData(link);
                    if (!link) {
                        return;
                    }
                    if (this.isLinkBundled(link)) {
                        this.unbundleLink(link);
                    } else {
                        this.bundleLink(link);
                    }
                },
                _addLinkBundle: function(dataArr) {
                    return this._linkBundleProvider.add(this._filterLinkBundleableData(dataArr));
                },
                _removeLinkBundle: function(dataArr) {
                    dataArr.forEach(function(d) {
                        this._linkBundleProvider.remove(d);
                    }, this);
                },
                _filterLinkBundleableData: function(data) {
                    return data.filter(function(data) {
                        return this._isLinkBundleable(data) && !this.isDisabled(data);
                    }, this);
                }
            };
        };
        var $GVDataProperties = {
            _getLabelProperties: function(prefix, defaultProperties) {
                defaultProperties = defaultProperties || {};
                var props = {};
                $eachObject($mergeObject({
                    label_rotation: null,
                    label_font: null,
                    label_gap: null,
                    label_align: null,
                    label_position: null,
                    label_direction: null,
                    label_offset_x: 0,
                    label_offset_y: 0,
                    label_box_padding: null
                }, $GVDataProperties._getStyleProperties("label", {}, true), $GVDataProperties._getStyleProperties("label_box", {}, true)), function(key, value) {
                    key = $GVDataProperties._getPropertyKey(prefix, key);
                    props[key] = defaultProperties.hasOwnProperty(key) ? defaultProperties[key] : value;
                });
                return props;
            },
            _getArrowProperties: function(prefix, defaultProperties) {
                var props = {};
                defaultProperties = defaultProperties || {};
                $eachObject($mergeObject({
                    arrow_shape: null,
                    arrow_size: null,
                    arrow_offset: null,
                    arrow_angle: null
                }, $GVDataProperties._getStyleProperties("arrow", {}, true)), function(key, value) {
                    key = $GVDataProperties._getPropertyKey(prefix, key);
                    props[key] = defaultProperties.hasOwnProperty(key) ? defaultProperties[key] : value;
                });
                return props;
            },
            _getStyleProperties: function(prefix, defaultProperties, withLine) {
                return $mergeObject($GVDataProperties._getFillProperties(prefix, defaultProperties), $GVDataProperties._getStokeProperties(prefix, defaultProperties, withLine));
            },
            _getFillProperties: function(prefix, defaultProperties) {
                defaultProperties = defaultProperties || {};
                var props = {};
                $eachObject({
                    fill: null,
                    fill_gradient_colors: null,
                    fill_gradient_direction: null,
                    fill_pattern_image: null
                }, function(key, value) {
                    key = $GVDataProperties._getPropertyKey(prefix, key);
                    props[key] = defaultProperties.hasOwnProperty(key) ? defaultProperties[key] : value;
                });
                return props;
            },
            _getStokeProperties: function(prefix, defaultProperties, withLine) {
                defaultProperties = defaultProperties || {};
                var props = {};
                $eachObject({
                    stroke: null,
                    stroke_gradient_colors: null,
                    stroke_gradient_direction: null,
                    stroke_pattern_image: null
                }, function(key, value) {
                    key = $GVDataProperties._getPropertyKey(prefix, key);
                    props[key] = defaultProperties.hasOwnProperty(key) ? defaultProperties[key] : value;
                });
                if (withLine === true) {
                    $eachObject({
                        stroke_line_width: 1,
                        stroke_line_dash: null,
                        stroke_line_dash_offset: 0
                    }, function(key, value) {
                        key = $GVDataProperties._getPropertyKey(prefix, key);
                        props[key] = defaultProperties.hasOwnProperty(key) ? defaultProperties[key] : value;
                    });
                }
                return props;
            },
            _getPropertyKey: function(prefix, key) {
                var keys = [];
                if (key) {
                    keys.unshift(key);
                }
                if (prefix) {
                    keys.unshift(prefix);
                }
                return keys.join("_");
            },
            _getProperties: function(properties, defaultProps, prefix) {
                if (prefix) {
                    var props = {};
                    defaultProps = defaultProps || {};
                    $eachObject(properties, function(key, value) {
                        key = prefix + "_" + key;
                        if (defaultProps.hasOwnProperty(key)) {
                            value = defaultProps[key];
                        }
                        props[key] = value;
                    });
                    return props;
                } else {
                    return $mergeObject({}, properties, defaultProps);
                }
            }
        };
        $mergeObject($GVDataProperties, {
            LabelProperties: $GVDataProperties._getLabelProperties(),
            InfoProperties: $mergeObject({
                info_font: null,
                info_box_padding: null,
                info_align: null,
                info_offset_x: 0,
                info_offset_y: 0
            }, $GVDataProperties._getStyleProperties("info", {}, true), $GVDataProperties._getStyleProperties("info_box", {}, true)),
            LinkFromToLabelProperties: $mergeObject($GVDataProperties._getLabelProperties("from"), $GVDataProperties._getLabelProperties("to")),
            SelectStyleProperties: $mergeObject({
                select_style: null,
                select_border_padding: null,
                select_shadow_blur: null,
                select_shadow_color: null,
                select_shadow_offset: null,
                select_shadow_offset_x: 0,
                select_shadow_offset_y: 0
            }, $GVDataProperties._getStokeProperties("select_border", {}, true)),
            NodeProperties: $mergeObject({
                shape: null,
                roundrect_radius: null
            }, $GVDataProperties._getStyleProperties(null, {}, true), $GVDataProperties._getArrowProperties("begin"), $GVDataProperties._getArrowProperties("end")),
            OutlineProperties: $mergeObject({
                outline_padding: null
            }, $GVDataProperties._getStokeProperties("outline", {}, true)),
            GroupProperties: $mergeObject({
                expand_shape: null,
                expand_padding: null,
                expand_parallelogram_angle: null,
                expand_roundrect_radius: null
            }, $GVDataProperties._getStyleProperties("expand", {}, true)),
            LinkProperties: $mergeObject({
                from_position: null,
                to_position: null,
                from_offset: null,
                to_offset: null,
                from_offset_x: null,
                from_offset_y: null,
                to_offset_x: null,
                to_offset_y: null,
                corner_offset: null,
                curvature: null,
                corner_radius: null,
                from_corner_distance: null,
                to_corner_distance: null
            }, $GVDataProperties._getStokeProperties(null, {
                stroke: "#000"
            }, true), $GVDataProperties._getArrowProperties("from"), $GVDataProperties._getArrowProperties("to")),
            getLabelProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.LabelProperties, defaultProps, prefix);
            },
            getInfoProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.InfoProperties, defaultProps, prefix);
            },
            getSelectStyleProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.SelectStyleProperties, defaultProps, prefix);
            },
            getNodeStyleProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.NodeProperties, defaultProps, prefix);
            },
            getOutlineProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.OutlineProperties, defaultProps, prefix);
            },
            getGroupProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.GroupProperties, defaultProps, prefix);
            },
            getLinkProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.LinkProperties, defaultProps, prefix);
            },
            getLinkFromToLabelProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.LinkFromToLabelProperties, defaultProps, prefix);
            },
            HeatMapProperties: {
                heatmap_blur: null,
                heatmap_colors: null,
                heatmap_opacity: null,
                heatmap_max_opacity: null,
                heatmap_min_opacity: null,
                heatmap_radius: null,
                heatmap_min_value: null,
                heatmap_max_value: null
            },
            getHeatMapProperties: function(defaultProps, prefix) {
                return $GVDataProperties._getProperties($GVDataProperties.HeatMapProperties, defaultProps, prefix);
            }
        });
        var $GVData = function() {
            $GVData.superClass.constructor.apply(this, arguments);
        };
        $extendClass($GVData, $Data, {
            ___zdefaults_: $mergeObject({
                alpha: 1,
                style: null,
                hover_style: $getDefault("GVIEW_HOVER_STYLE")
            }, $GVDataProperties.getLabelProperties({
                label_rotation: 0,
                label_gap: 0,
                label_align: "center",
                label_box_padding: $getDefault("GVIEW_LABEL_BOX_PADDING"),
                label_fill: $getDefault("GVIEW_LABEL_FILL")
            }), $GVDataProperties.getInfoProperties({
                info_fill: $getDefault("GVIEW_INFO_FILL"),
                info_box_padding: 2,
                info_box_fill: $getDefault("GVIEW_INFO_BOX_FILL")
            }), $GVDataProperties.getSelectStyleProperties({
                select_style: "border",
                select_border_stroke: $getDefault("GVIEW_SELECT_BORDER_STROKE"),
                select_border_stroke_line_width: $getDefault("GVIEW_SELECT_BORDER_STROKE_LINE_WIDTH"),
                select_shadow_color: $getDefault("GVIEW_SELECT_SHADOW_COLOR"),
                select_shadow_blur: $getDefault("GVIEW_SELECT_SHADOW_BLUR")
            })),
            draw: function(g2d) {},
            getBounds: function(view, bodyOnly, isExpanded) {
                var arg0 = arguments[0];
                if (arg0 === true || arg0 === false) {
                    view = null;
                    bodyOnly = arg0;
                    isExpanded = arguments[1];
                }
                if (bodyOnly !== false) {
                    bodyOnly = true;
                }
                return this._getBounds(view, bodyOnly, isExpanded);
            },
            _getBounds: function(view, bodyOnly, isExpanded) {}
        });
        var $Node = function(props) {
            if (!(this instanceof $Node)) {
                return $ClassUtil.createInstance($Node, arguments);
            }
            this._linkArray = [];
            this._fromLinkArray = [];
            this._toLinkArray = [];
            $Node.superClass.constructor.apply(this, arguments);
        };
        $extendClass($Node, $GVData, $mergeObject({
            __toTypeString_Node_$: function() {
                return $TypeConst.NODE;
            },
            __className_: "Node",
            ___zdefaults_: $mergeObject({
                x: 0,
                y: 0,
                image: null,
                rotation: 0,
                width: $getDefault("GVIEW_NODE_WIDTH"),
                height: $getDefault("GVIEW_NODE_HEIGHT"),
                label_gap: $getDefault("GVIEW_NODE_LABEL_GAP"),
                label_position: $getDefault("GVIEW_NODE_LABEL_POSITION"),
                select_border_padding: $getDefault("GVIEW_NODE_SELECT_BORDER_PADDING")
            }, $GVDataProperties.getNodeStyleProperties({
                shape: $getDefault("GVIEW_NODE_SHAPE"),
                roundrect_radius: .12,
                fill: $getDefault("GVIEW_NODE_FILL"),
                stroke: $getDefault("GVIEW_NODE_STROKE"),
                stroke_line_width: $getDefault("GVIEW_NODE_STROKE_LINE_WIDTH"),
                begin_arrow_size: 2,
                begin_arrow_offset: 0,
                begin_arrow_stroke_line_width: null,
                begin_arrow_angle: 46,
                end_arrow_size: 2,
                end_arrow_offset: 0,
                end_arrow_stroke_line_width: null,
                end_arrow_angle: 46
            }), $GVDataProperties.getOutlineProperties({
                outline_padding: $getDefault("GVIEW_NODE_OUTLINE_PADDING"),
                outline_stroke_line_width: $getDefault("GVIEW_NODE_OUTLINE_STROKE_LINE_WIDTH")
            }), $GVDataProperties.getHeatMapProperties({
                heatmap_blur: .85,
                heatmap_colors: $getDefault("GVIEW_NODE_HEATMAP_COLORS"),
                heatmap_opacity: 0,
                heatmap_max_opacity: 1,
                heatmap_min_opacity: 0,
                heatmap_radius: 30
            })),
            getType: function() {
                var type = this.get("type");
                if (type) {
                    return type;
                }
                if (this.get("image")) {
                    return "image";
                }
                if (this.get("points")) {
                    return "path";
                }
                return "shape";
            },
            getRendererClass: function(data) {
                return $NodeRenderer;
            }
        }, {
            getLinks: function(copy) {
                if (copy === false) {
                    return this._linkArray;
                }
                return $mergeArray([], this._linkArray);
            },
            getFromLinks: function(copy) {
                if (copy === false) {
                    return this._fromLinkArray;
                }
                return $mergeArray([], this._fromLinkArray);
            },
            getToLinks: function(copy) {
                if (copy === false) {
                    return this._toLinkArray;
                }
                return $mergeArray([], this._toLinkArray);
            },
            getLinksTo: function(toNode) {
                var toLinks = toNode.getToLinks(false);
                return $filterArray(this.getFromLinks(false), function(link) {
                    return toLinks.indexOf(link) > -1;
                });
            },
            getLinksFrom: function(fromNode) {
                var fromLinks = fromNode.getFromLinks(false);
                return $filterArray(this.getToLinks(false), function(link) {
                    return fromLinks.indexOf(link) > -1;
                });
            },
            getLinksBetween: function(peerNode) {
                var peerLinks = peerNode.getLinks(false);
                if (this === peerNode) {
                    return $filterArray(peerLinks, function(link) {
                        return link.isLoop();
                    });
                }
                return $filterArray(this.getLinks(false), function(link) {
                    return peerLinks.indexOf(link) > -1;
                });
            },
            _addFromLink: function(link) {
                this._fromLinkArray.push(link);
                if (this._linkArray.indexOf(link) < 0) {
                    this._linkArray.push(link);
                }
                this.dispatchChangeEvent("links", this._linkArray, this._linkArray);
            },
            _removeFromLink: function(link) {
                $arrayRemoveItem(this._fromLinkArray, link);
                $arrayRemoveItem(this._linkArray, link);
                this.dispatchChangeEvent("links", this._linkArray, this._linkArray);
            },
            _addToLink: function(link) {
                this._toLinkArray.push(link);
                if (this._linkArray.indexOf(link) < 0) {
                    this._linkArray.push(link);
                }
                this.dispatchChangeEvent("links", this._linkArray, this._linkArray);
            },
            _removeToLink: function(link) {
                $arrayRemoveItem(this._toLinkArray, link);
                $arrayRemoveItem(this._linkArray, link);
                this.dispatchChangeEvent("links", this._linkArray, this._linkArray);
            }
        }, {
            beforeSetProperty: function(key, newValue, oldValue) {
                if (key === "host" && oldValue) {
                    oldValue.removeChangeListener(this._onHostChange, this);
                }
                $Node.superClass.beforeSetProperty.apply(this, arguments);
            },
            afterSetProperty: function(key, newValue, oldValue) {
                if (key === "host" && newValue) {
                    newValue.addChangeListener(this._onHostChange, this);
                }
                if (key === "x" || key === "y" || key === "width" || key === "height") {
                    if ($NodeUtil.isPointsNode(this)) {
                        var size = {};
                        size[key] = newValue;
                        $NodeUtil.updateNodePointsByBounds(null, this, size);
                    }
                } else if (key === "center") {
                    this.setCenter(newValue);
                } else if (key === "size") {
                    this.setSize(newValue);
                }
                $Node.superClass.afterSetProperty.apply(this, arguments);
            },
            _onHostChange: function(evt) {
                var prop = evt.property;
                if (prop === "x" || prop === "y") {
                    if (this.__isUpdatingFromHost === true || this.__isUpdatingFollower === true) {
                        return;
                    }
                    this.__isUpdatingFromHost = true;
                    var host = evt.source;
                    if ($isGroup(host)) {
                        return;
                    }
                    var newValue = evt.new_value || 0;
                    var oldValue = evt.old_value || 0;
                    var offset = newValue - oldValue;
                    host.__isUpdatingFollower = true;
                    var cv = this.get(prop);
                    this.set(prop, cv + offset);
                    delete host.__isUpdatingFollower;
                    delete this.__isUpdatingFromHost;
                }
            }
        }, {
            setPosition: function(point) {
                $NodeUtil.setPosition(null, this, $MathUtil.getArgsPoint.apply(null, arguments));
            },
            getPosition: function() {
                if ($NodeUtil.isPointsNode(this)) {
                    var bounds = this.getBounds();
                    if (bounds) {
                        return {
                            x: bounds.x,
                            y: bounds.y
                        };
                    }
                } else {
                    return {
                        x: this.getProperty("x"),
                        y: this.getProperty("y")
                    };
                }
            },
            setCenter: function(point) {
                point = $MathUtil.getArgsPoint.apply(null, arguments);
                if (point == null) {
                    return;
                }
                var width, height;
                if ($NodeUtil.isPointsNode(this)) {
                    var bounds = this.getBounds();
                    if (!bounds) {
                        return;
                    }
                    width = bounds.width;
                    height = bounds.height;
                } else {
                    width = this.getProperty("width");
                    height = this.getProperty("height");
                }
                this.setPosition({
                    x: point.x - width / 2,
                    y: point.y - height / 2
                });
            },
            getCenter: function() {
                if ($NodeUtil.isPointsNode(this)) {
                    var bounds = this.getBounds();
                    if (bounds) {
                        return {
                            x: bounds.x + bounds.width / 2,
                            y: bounds.y + bounds.height / 2
                        };
                    }
                } else {
                    return {
                        x: this.getProperty("x") + this.getProperty("width") / 2,
                        y: this.getProperty("y") + this.getProperty("height") / 2
                    };
                }
            },
            getSize: function() {
                if ($NodeUtil.isPointsNode(this)) {
                    var bounds = this.getBounds();
                    if (bounds) {
                        return {
                            width: bounds.width,
                            height: bounds.height
                        };
                    }
                } else {
                    return {
                        width: this.getProperty("width"),
                        height: this.getProperty("height")
                    };
                }
            },
            setSize: function(size) {
                $NodeUtil.setSize(null, this, $MathUtil.getArgsSize.apply(null, arguments));
            },
            _getBounds: function(view, bodyOnly) {
                return $NodeCalculator.calcNodeBounds(view, this, bodyOnly);
            }
        }));
        var $Link = function(from, to, props) {
            if (!(this instanceof $Link)) {
                return $ClassUtil.createInstance($Link, arguments);
            }
            var aLen = arguments.length;
            var _props, _from, _to;
            if (aLen === 1) {
                _props = arguments[0];
            } else if (aLen === 2) {
                _from = arguments[0];
                _to = arguments[1];
            } else if (aLen === 3) {
                _from = arguments[0];
                _to = arguments[1];
                _props = arguments[2];
            }
            var args = $isObject(_props) ? [ _props ] : [];
            $Link.superClass.constructor.apply(this, args);
            if (_from) {
                this.set("from", _from);
            }
            if (_to) {
                this.set("to", _to);
            }
        };
        $extendClass($Link, $GVData, {
            __toTypeString_Link_$: function() {
                return $TypeConst.LINK;
            },
            __className_: "Link",
            ___zdefaults_: $mergeObject({
                type: null,
                from: null,
                to: null,
                label_rotation: true
            }, $GVDataProperties.getLinkProperties({
                stroke: $getDefault("GVIEW_LINK_STROKE"),
                stroke_line_width: $getDefault("GVIEW_LINK_STROKE_LINE_WIDTH"),
                from_offset: 0,
                to_offset: 0,
                corner_radius: 0,
                curvature: .15,
                from_arrow_size: 2,
                from_arrow_offset: 0,
                from_arrow_stroke_line_width: null,
                from_arrow_angle: 46,
                to_arrow_size: 2,
                to_arrow_offset: 0,
                to_arrow_stroke_line_width: null,
                to_arrow_angle: 46
            }), $GVDataProperties.getLinkFromToLabelProperties({})),
            isLoop: function() {
                var from = this.getProperty("from");
                var to = this.getProperty("to");
                return from != null && from === to;
            },
            beforeSetProperty: function(key, value, old) {
                if ((key === "from" || key === "to") && old) {
                    if (key === "from") {
                        old._removeFromLink(this);
                    } else if (key === "to") {
                        old._removeToLink(this);
                    }
                }
                $Link.superClass.beforeSetProperty.apply(this, arguments);
            },
            afterSetProperty: function(key, value, old) {
                if ((key === "from" || key === "to") && value) {
                    if (key === "from") {
                        value._addFromLink(this);
                    } else if (key === "to") {
                        value._addToLink(this);
                    }
                }
                $Link.superClass.afterSetProperty.apply(this, arguments);
            },
            _getBounds: function(view, bodyOnly) {
                return $LinkCalculator.calcLinkBounds(view, this, bodyOnly);
            },
            getPathPoints: function(view) {
                return $LinkCalculator.calcLinkPathPoints(view, this);
            },
            getRendererClass: function(data) {
                return $LinkRenderer;
            }
        });
        var $Group = function() {
            if (!(this instanceof $Group)) {
                return $ClassUtil.createInstance($Group, arguments);
            }
            $Group.superClass.constructor.apply(this, arguments);
        };
        $extendClass($Group, $Node, {
            __toTypeString_Group_$: function() {
                return $TypeConst.GROUP;
            },
            __className_: "Group",
            ___zdefaults_: $mergeObject({
                shape: $getDefault("GVIEW_GROUP_SHAPE")
            }, $GVDataProperties.getGroupProperties({
                width: $getDefault("GVIEW_GROUP_WIDTH"),
                height: $getDefault("GVIEW_GROUP_HEIGHT"),
                expand_padding: $getDefault("GVIEW_GROUP_EXPAND_PADDING"),
                expand_shape: $getDefault("GVIEW_GROUP_EXPAND_SHAPE"),
                expand_roundrect_radius: .12,
                expand_parallelogram_angle: 78,
                expand_fill: $getDefault("GVIEW_GROUP_EXPAND_FILL"),
                expand_stroke: $getDefault("GVIEW_GROUP_EXPAND_STROKE"),
                expand_stroke_line_width: 1
            })),
            setPosition: function(point) {
                $GroupUtil.setPosition(null, this, $MathUtil.getArgsPoint.apply(null, arguments));
            },
            _getBounds: function(view, bodyOnly, isExpanded) {
                if (view && isExpanded == null) {
                    isExpanded = view.isExpanded(this);
                }
                return $GroupCalculator.calcGroupBounds(view, this, isExpanded, bodyOnly);
            },
            getGroupChildren: function() {
                return this.getChildren(false);
            },
            getRendererClass: function() {
                return $GroupRenderer;
            }
        });
        var $Subview = function() {
            if (!(this instanceof $Subview)) {
                return $ClassUtil.createInstance($Subview, arguments);
            }
            $Subview.superClass.constructor.apply(this, arguments);
        };
        $extendClass($Subview, $Node, {
            __toTypeString_Subview_$: function() {
                return $TypeConst.SUBVIEW;
            },
            __className_: "subview",
            ___zdefaults_: {
                shape: $getDefault("GVIEW_SUBVIEW_SHAPE"),
                width: $getDefault("GVIEW_SUBVIEW_WIDTH"),
                height: $getDefault("GVIEW_SUBVIEW_HEIGHT")
            }
        });
        var $LinkSubview = function(from, to, props) {
            if (!(this instanceof $LinkSubview)) {
                return $ClassUtil.createInstance($LinkSubview, arguments);
            }
            $LinkSubview.superClass.constructor.apply(this, arguments);
        };
        $extendClass($LinkSubview, $Link, {
            __toTypeString_Link_$: function() {
                return $TypeConst.LINK;
            },
            __toTypeString_Subview_$: function() {
                return $TypeConst.SUBVIEW;
            },
            __toTypeString_LinkSubview_$: function() {
                return $TypeConst.LINKSUBVIEW;
            },
            __className_: "LinkSubview"
        });
        var $HeatMapUtil = {
            _point_templates: {},
            calcHMPointsValues: function(points) {
                var min = 0, max = 0;
                points.forEach(function(point) {
                    var pv = point.value;
                    if (pv != null) {
                        min = $MathMin(min, pv);
                        max = $MathMax(max, pv);
                    }
                });
                return {
                    min: min || 0,
                    max: max || 0
                };
            },
            calcHMPointsBounds: function(points, radius) {
                if (points == null || points.length === 0) {
                    return null;
                }
                radius = radius | 0;
                var minX = null, minY = null, maxX = null, maxY = null;
                points.forEach(function(point, index) {
                    var r;
                    if (point.hasOwnProperty("radius")) {
                        r = point.radius | 0;
                    } else {
                        r = radius;
                    }
                    if (index === 0) {
                        minX = point.x - r;
                        minY = point.y - r;
                        maxX = point.x + r;
                        maxY = point.y + r;
                    } else {
                        minX = $MathMin(point.x - r, minX);
                        minY = $MathMin(point.y - r, minY);
                        maxX = $MathMax(point.x + r, maxX);
                        maxY = $MathMax(point.y + r, maxY);
                    }
                });
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            },
            drawHM: function(renderer, g2d, bodyBounds) {
                var shadowCtx = $HeatMapUtil._getShadowCtx(bodyBounds.width, bodyBounds.height);
                $HeatMapUtil._updateAlphaCtx(shadowCtx, renderer.getRenderConfig("points"), bodyBounds, renderer.getRenderConfig("heatmap_min_value"), renderer.getRenderConfig("heatmap_max_value"), renderer.getRenderConfig("heatmap_radius"), renderer.getRenderConfig("heatmap_blur"));
                $HeatMapUtil._colorize(shadowCtx, bodyBounds, renderer.getRenderConfig("heatmap_opacity"), renderer.getRenderConfig("heatmap_min_opacity"), renderer.getRenderConfig("heatmap_max_opacity"), renderer.getRenderConfig("heatmap_colors"));
                g2d.drawImage($HeatMapUtil._shadowCVS, bodyBounds.x, bodyBounds.y);
            },
            _updateAlphaCtx: function(shadowCtx, points, rect, minValue, maxValue, radius, blur) {
                var _blur = 1 - blur;
                var rx = rect.x;
                var ry = rect.y;
                points.forEach(function(point) {
                    var x = point.x - rx;
                    var y = point.y - ry;
                    var r;
                    if (point.hasOwnProperty("radius")) {
                        r = point.radius | 0;
                    } else {
                        r = radius;
                    }
                    if (r > 0) {
                        var pv = point.value;
                        if (pv != null) {
                            var value = $MathMax(minValue, $MathMin(pv, maxValue));
                            shadowCtx.globalAlpha = maxValue !== minValue ? (value - minValue) / (maxValue - minValue) : 1;
                        }
                        var rectX = x - r;
                        var rectY = y - r;
                        shadowCtx.drawImage($HeatMapUtil._getPointTemplate(r, _blur), rectX, rectY);
                    }
                });
            },
            _colorize: function(shadowCtx, rect, opacity, minOpacity, maxOpacity, colors) {
                opacity = opacity * 255 | 0;
                maxOpacity = maxOpacity * 255 | 0;
                minOpacity = minOpacity * 255 | 0;
                var img = shadowCtx.getImageData(0, 0, rect.width, rect.height);
                var imgData = img.data;
                var len = imgData.length;
                var palette = $HeatMapUtil._getColorPalette(colors);
                for (var i = 3; i < len; i += 4) {
                    var alpha = imgData[i];
                    var offset = alpha * 4;
                    if (!offset) {
                        continue;
                    }
                    var finalAlpha;
                    if (opacity > 0) {
                        finalAlpha = opacity;
                    } else {
                        if (alpha < maxOpacity) {
                            if (alpha < minOpacity) {
                                finalAlpha = minOpacity;
                            } else {
                                finalAlpha = alpha;
                            }
                        } else {
                            finalAlpha = maxOpacity;
                        }
                    }
                    imgData[i - 3] = palette[offset];
                    imgData[i - 2] = palette[offset + 1];
                    imgData[i - 1] = palette[offset + 2];
                    imgData[i] = finalAlpha;
                }
                shadowCtx.putImageData(img, 0, 0);
            },
            _getColorPalette: function(colorStops) {
                var paletteCanvas = $domCreate("canvas");
                var paletteCtx = paletteCanvas.getContext("2d");
                paletteCanvas.setAttribute("width", 256);
                paletteCanvas.setAttribute("height", 1);
                var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
                $eachObject(colorStops || {}, function(key, value) {
                    gradient.addColorStop(key, value);
                });
                paletteCtx.fillStyle = gradient;
                paletteCtx.fillRect(0, 0, 256, 1);
                return paletteCtx.getImageData(0, 0, 256, 1).data;
            },
            _getShadowCtx: function(width, height) {
                if (!$HeatMapUtil._shadowCVS) {
                    $HeatMapUtil._shadowCVS = $domCreate("canvas");
                    $HeatMapUtil._shadowCTX = $HeatMapUtil._shadowCVS.getContext("2d");
                }
                $HeatMapUtil._shadowCVS.setAttribute("width", width);
                $HeatMapUtil._shadowCVS.setAttribute("height", height);
                return $HeatMapUtil._shadowCTX;
            },
            _getPointTemplate: function(radius, blurFactor) {
                var key = radius + "$" + blurFactor;
                if ($HeatMapUtil._point_templates[key]) {
                    return $HeatMapUtil._point_templates[key];
                }
                var cvs = $domCreate("canvas");
                var ctx = cvs.getContext("2d");
                var x = radius;
                var y = radius;
                var r2 = radius * 2;
                cvs.setAttribute("width", r2);
                cvs.setAttribute("height", r2);
                var rect = {
                    x: 0,
                    y: 0,
                    width: r2,
                    height: r2
                };
                if (blurFactor === 1) {
                    $C2DRectShapeUtil.render(ctx, rect, "circle", {
                        fill: "rgba(0,0,0,1)"
                    });
                } else {
                    var gradient = ctx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);
                    gradient.addColorStop(0, "rgba(0,0,0,1)");
                    gradient.addColorStop(1, "rgba(0,0,0,0)");
                    $C2DRectShapeUtil.render(ctx, rect, "rect", {
                        fill: gradient
                    });
                }
                $HeatMapUtil._point_templates[key] = cvs;
                return cvs;
            }
        };
        var $GVRendererConfig = {
            getCalcRenderProperty: function(renderer, prop) {
                var renderProps = renderer.getRenderConfig($RendererProperties.CALC_RENDER_PROPS);
                if (renderProps) {
                    return renderProps[prop];
                }
            },
            getCalcRenderBodyBounds: function(renderer) {
                return $GVRendererConfig.getCalcRenderProperty(renderer, "body_bounds");
            },
            getCalcRenderLabelProperty: function(renderer) {
                var prop = $GVRendererConfig.getCalcRenderProperty(renderer, "label_render_props");
                if (prop) {
                    return prop.label;
                }
            },
            getCalcRenderLabelBoxProperty: function(renderer) {
                var prop = $GVRendererConfig.getCalcRenderProperty(renderer, "label_render_props");
                if (prop) {
                    return prop.label_box;
                }
            },
            getCalcRenderInfoProperty: function(renderer) {
                var prop = $GVRendererConfig.getCalcRenderProperty(renderer, "info_render_props");
                if (prop) {
                    return prop.info;
                }
            },
            getCalcRenderInfoBoxProperty: function(renderer) {
                var prop = $GVRendererConfig.getCalcRenderProperty(renderer, "info_render_props");
                if (prop) {
                    return prop.info_box;
                }
            },
            isRenderBodyVisible: function(renderer) {
                var bounds = $GVRendererConfig.getCalcRenderBodyBounds(renderer);
                return bounds && bounds.width > 0 && bounds.height > 0;
            },
            updateLabelConfig: function(renderer, view, data, renderConfig) {
                var label = renderer.getRenderConfig("label");
                if (label != null) {
                    $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, data, renderConfig, $GVDataProperties.LabelProperties);
                    renderConfig["label_font"] = $GViewUtil.getFont(renderConfig["label_font"]);
                    renderConfig["label_in_front"] = renderer.getViewRenderConfig("label_in_front");
                    renderConfig["label_style"] = view.getDataViewProperty(data, "label_style");
                }
            },
            updateInfoConfig: function(renderer, view, data, renderConfig) {
                var info = renderer.getRenderConfig("info");
                if (info != null) {
                    $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, data, renderConfig, $GVDataProperties.InfoProperties);
                    renderConfig["info_font"] = $GViewUtil.getFont(renderConfig["info_font"]);
                    renderConfig["info_in_front"] = renderer.getViewRenderConfig("info_in_front");
                    renderConfig["info_style"] = view.getDataViewProperty(data, "info_style");
                }
            },
            updateSelectedConfig: function(renderer, view, data, renderConfig) {
                if (renderer.getRenderConfig("selected") !== true) {
                    return;
                }
                $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, data, renderConfig, $GVDataProperties.SelectStyleProperties);
            },
            updatePropertiesRenderConfig: function(renderer, view, data, renderConfig, props, viewPrefix) {
                $eachObject(props, function(key, value) {
                    var viewKey;
                    if (viewPrefix) {
                        viewKey = viewPrefix + "_" + key;
                    }
                    renderConfig[key] = view.getDataViewProperty(data, key, viewKey);
                });
            }
        };
        var $NodeRendererConfig = {
            updateNodeConfig: function(renderer, view, node, renderConfig) {
                var renderProps = $NodeCalculator.calcNodeRenderProperties(view, node);
                if (renderProps == null) {
                    return;
                }
                renderConfig[$RendererProperties.CALC_RENDER_PROPS] = renderProps;
                var type = node.getType();
                renderConfig["type"] = type;
                renderConfig["rotation"] = parseFloat($GViewUtil.getNodeViewProperty(view, node, "rotation")) || 0;
                $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, node, renderConfig, $GVDataProperties.NodeProperties, "node");
                renderConfig["$_begin_arrow_fill"] = view.hasDataViewProperty(node, "begin_arrow_fill", "node_begin_arrow_fill");
                renderConfig["$_end_arrow_fill"] = view.hasDataViewProperty(node, "end_arrow_fill", "node_end_arrow_fill");
                renderConfig["$_begin_arrow_stroke"] = view.hasDataViewProperty(node, "begin_arrow_stroke", "node_begin_arrow_stroke");
                renderConfig["$_end_arrow_stroke"] = view.hasDataViewProperty(node, "end_arrow_stroke", "node_end_arrow_stroke");
                renderConfig["$_begin_arrow_stroke_line_width"] = view.hasDataViewProperty(node, "begin_arrow_stroke_line_width", "node_begin_arrow_stroke_line_width");
                renderConfig["$_end_arrow_stroke_line_width"] = view.hasDataViewProperty(node, "end_arrow_stroke_line_width", "node_end_arrow_stroke_line_width");
                if (type === "image") {
                    $NodeRendererConfig._updateNodeImageConfig(renderer, view, node, renderConfig);
                } else if (type === "path") {
                    $NodeRendererConfig._updateNodePathConfig(renderer, view, node, renderConfig);
                } else if (type === "heatmap") {
                    $NodeRendererConfig._updateNodeHeatMapConfig(renderer, view, node, renderConfig);
                } else {
                    $NodeRendererConfig._updateNodeShapeConfig(renderer, view, node, renderConfig);
                }
                $NodeRendererConfig.updateNodeOutlineConfig(renderer, view, node, renderConfig);
            },
            _updateNodeImageConfig: function(renderer, view, node, renderConfig) {
                if (!$GVRendererConfig.isRenderBodyVisible(renderer)) {
                    return;
                }
                var image = $GViewUtil.getNodeViewProperty(view, node, "image");
                renderConfig["image"] = image;
                if (image) {
                    var img;
                    if ($isString(image)) {
                        img = $ImageUtil.get(image, renderer.updateData, renderer);
                    } else {
                        img = image;
                    }
                    if (img) {
                        var image_color = $GViewUtil.getNodeViewProperty(view, node, "image_color");
                        if (image_color) {
                            var colorMap = img.$_color_map = img.$_color_map || {};
                            colorMap[image_color] = colorMap[image_color] || $ImageUtil.getColorImage(img, image_color, "canvas");
                            img = colorMap[image_color];
                        }
                    }
                    renderConfig[$RendererProperties.NODE_IMAGE] = img;
                }
            },
            _updateNodePathConfig: function(renderer, view, node, renderConfig) {
                renderConfig["points"] = node.getProperty("points") || [];
            },
            _updateNodeHeatMapConfig: function(renderer, view, node, renderConfig) {
                var points = node.getProperty("points") || [];
                renderConfig["points"] = points;
                if (points.length === 0) {
                    return;
                }
                $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, node, renderConfig, $GVDataProperties.HeatMapProperties, "node");
                var minValue = renderConfig["heatmap_min_value"];
                var maxValue = renderConfig["heatmap_max_value"];
                if (minValue == null || maxValue == null) {
                    var pvs = $HeatMapUtil.calcHMPointsValues(points);
                    if (minValue == null) {
                        renderConfig["heatmap_min_value"] = pvs.min;
                    }
                    if (maxValue == null) {
                        renderConfig["heatmap_max_value"] = pvs.max;
                    }
                }
            },
            _updateNodeShapeConfig: function(renderer, view, node, renderConfig) {},
            updateNodeOutlineConfig: function(renderer, view, node, renderConfig) {
                if ($GVRendererConfig.getCalcRenderProperty(renderer, "outline_bounds")) {
                    $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, node, renderConfig, $GVDataProperties.OutlineProperties, "node");
                }
            }
        };
        var $LinkRendererConfig = {
            updateLinkConfig: function(renderer, view, link, renderConfig) {
                var renderProps = $LinkCalculator.calcLinkRenderProperties(view, link);
                if (renderProps == null) {
                    return;
                }
                renderConfig[$RendererProperties.CALC_RENDER_PROPS] = renderProps;
                $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, link, renderConfig, $GVDataProperties.LinkProperties, "link");
                renderConfig["$_from_arrow_fill"] = view.hasDataViewProperty(link, "from_arrow_fill", "link_from_arrow_fill");
                renderConfig["$_to_arrow_fill"] = view.hasDataViewProperty(link, "to_arrow_fill", "link_to_arrow_fill");
                renderConfig["$_from_arrow_stroke"] = view.hasDataViewProperty(link, "from_arrow_stroke", "link_from_arrow_stroke");
                renderConfig["$_to_arrow_stroke"] = view.hasDataViewProperty(link, "to_arrow_stroke", "link_to_arrow_stroke");
                renderConfig["$_from_arrow_stroke_line_width"] = view.hasDataViewProperty(link, "from_arrow_stroke_line_width", "link_from_arrow_stroke_line_width");
                renderConfig["$_to_arrow_stroke_line_width"] = view.hasDataViewProperty(link, "to_arrow_stroke_line_width", "link_to_arrow_stroke_line_width");
                renderConfig["type"] = link.get("type");
                renderConfig["loop"] = link.isLoop();
                renderConfig["from"] = link.get("from");
                renderConfig["to"] = link.get("to");
                renderConfig["link_gap"] = renderer.getViewRenderConfig("link_gap");
                renderConfig["from_agent"] = $LinkUtil.getFromNodeAgent(view, link);
                renderConfig["to_agent"] = $LinkUtil.getToNodeAgent(view, link);
                renderConfig["label_rotation"] = view.getDataViewProperty(link, "label_rotation", "link_label_rotation");
            }
        };
        var $GroupRendererConfig = {
            updateGroupConfig: function(renderer, view, group, renderConfig) {
                var isExpand = view.isExpanded(group);
                renderConfig["expand"] = isExpand;
                var renderProps = $GroupCalculator.calcGroupRenderProperties(view, group, isExpand);
                if (renderProps == null) {
                    return;
                }
                renderConfig[$RendererProperties.CALC_RENDER_PROPS] = renderProps;
                if (renderProps.is_group) {
                    if (isExpand) {
                        var replaceConfig = {};
                        $GVRendererConfig.updatePropertiesRenderConfig(renderer, view, group, replaceConfig, $GVDataProperties.GroupProperties, "group");
                        $eachObject(replaceConfig, function(key, value) {
                            renderConfig[key.substring(7)] = replaceConfig[key];
                        });
                        renderConfig["rotation"] = 0;
                        var expandRenderProps = renderProps.expand_render_props;
                        var type = expandRenderProps.type;
                        renderConfig["type"] = type;
                        if (type === "path") {
                            renderConfig["points"] = expandRenderProps.points;
                        }
                    }
                }
                $NodeRendererConfig.updateNodeOutlineConfig(renderer, view, group, renderConfig);
            }
        };
        var $ArrowDraw = {
            drawNodePathArrow: function(renderer, g2d) {
                var path_arrow_render_props = $GVRendererConfig.getCalcRenderProperty(renderer, "path_arrow_render_props");
                if (!path_arrow_render_props) {
                    return;
                }
                var beginArrowRenderProps = path_arrow_render_props.begin;
                if (beginArrowRenderProps) {
                    var begin_arrow_type = beginArrowRenderProps.type;
                    if (begin_arrow_type === "shape") {
                        $ArrowDraw._drawShapeArrow(renderer, g2d, beginArrowRenderProps, "begin_arrow", "stroke");
                    } else if (begin_arrow_type === "path") {
                        $ArrowDraw._drawPathArrow(renderer, g2d, beginArrowRenderProps, "begin_arrow", "stroke");
                    }
                }
                var endArrowRenderProps = path_arrow_render_props.end;
                if (endArrowRenderProps) {
                    var end_arrow_type = endArrowRenderProps.type;
                    if (end_arrow_type === "shape") {
                        $ArrowDraw._drawShapeArrow(renderer, g2d, endArrowRenderProps, "end_arrow", "stroke");
                    } else if (end_arrow_type === "path") {
                        $ArrowDraw._drawPathArrow(renderer, g2d, endArrowRenderProps, "end_arrow", "stroke");
                    }
                }
            },
            drawLinkArrow: function(renderer, g2d) {
                var link_arrow_render_props = $GVRendererConfig.getCalcRenderProperty(renderer, "arrow_render_props");
                if (!link_arrow_render_props) {
                    return;
                }
                var fromArrowRenderProps = link_arrow_render_props.from;
                if (fromArrowRenderProps) {
                    var from_arrow_type = fromArrowRenderProps.type;
                    if (from_arrow_type === "shape") {
                        $ArrowDraw._drawShapeArrow(renderer, g2d, fromArrowRenderProps, "from_arrow", "stroke");
                    } else if (from_arrow_type === "path") {
                        $ArrowDraw._drawPathArrow(renderer, g2d, fromArrowRenderProps, "from_arrow", "stroke");
                    }
                }
                var toArrowRenderProps = link_arrow_render_props.to;
                if (toArrowRenderProps) {
                    var to_arrow_type = toArrowRenderProps.type;
                    if (to_arrow_type === "shape") {
                        $ArrowDraw._drawShapeArrow(renderer, g2d, toArrowRenderProps, "to_arrow", "stroke");
                    } else if (to_arrow_type === "path") {
                        $ArrowDraw._drawPathArrow(renderer, g2d, toArrowRenderProps, "to_arrow", "stroke");
                    }
                }
            },
            _drawShapeArrow: function(renderer, g2d, arrowRenderProps, arrowPrefix, defaultStyle) {
                var arrow_shape_bounds = arrowRenderProps.shape_bounds;
                var cx = arrow_shape_bounds.x + arrow_shape_bounds.width / 2;
                var cy = arrow_shape_bounds.y + arrow_shape_bounds.height / 2;
                var rotation = arrowRenderProps.rotation;
                $canvasRotateAround(g2d, rotation, {
                    x: cx,
                    y: cy
                }, function(g2d) {
                    var shape = arrowRenderProps.shape;
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, arrow_shape_bounds, arrowPrefix + "_stroke");
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DRectShapeUtil.render(g2d, arrow_shape_bounds, shape, {
                            fill: $ArrowDraw._getArrowFillStyle(renderer, g2d, arrowRenderProps, arrowPrefix, defaultStyle, arrow_shape_bounds),
                            stroke: strokeOpt.stroke
                        }, {
                            radius: .2
                        });
                    });
                });
            },
            _drawPathArrow: function(renderer, g2d, arrowRenderProps, arrowPrefix, defaultStyle) {
                var arrow_shape = arrowRenderProps.shape;
                var arrow_bounds = arrowRenderProps.bounds;
                var fill, stroke, strokeAttr;
                if (arrow_shape !== "open_arrow") {
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, arrow_bounds, arrowPrefix + "_stroke");
                    stroke = strokeOpt.stroke;
                    strokeAttr = strokeOpt.attr;
                    fill = $ArrowDraw._getArrowFillStyle(renderer, g2d, arrowRenderProps, arrowPrefix, defaultStyle, arrow_bounds);
                } else {
                    if (renderer.getRenderConfig("$_" + arrowPrefix + "_stroke") === false) {
                        stroke = $GVRendererDraw.getStyle(renderer, arrow_bounds, defaultStyle);
                    } else {
                        stroke = $GVRendererDraw.getStyle(renderer, arrow_bounds, arrowPrefix + "_stroke");
                    }
                    strokeAttr = $GVRendererDraw.getStrokeAttr(renderer, arrowPrefix + "_stroke");
                    if (strokeAttr && renderer.getRenderConfig("$_" + arrowPrefix + "_stroke_line_width") === false) {
                        strokeAttr.lineWidth = $GVRendererDraw.getStrokeAttr(renderer, defaultStyle).lineWidth;
                    }
                }
                $saveAndSet2DAttributes(g2d, strokeAttr, function() {
                    $C2DPathUtil.render(g2d, arrowRenderProps.points, {
                        fill: fill,
                        stroke: stroke
                    });
                });
            },
            _getArrowFillStyle: function(renderer, g2d, renderProps, arrowPrefix, defaultStyle, arrow_bounds) {
                var fill;
                if (renderer.getRenderConfig("$_" + arrowPrefix + "_fill") === false) {
                    fill = $GVRendererDraw.getStyle(renderer, arrow_bounds, defaultStyle);
                } else {
                    fill = $GVRendererDraw.getStyle(renderer, arrow_bounds, arrowPrefix + "_fill");
                }
                return fill;
            }
        };
        var $GVRendererDraw = {
            getStrokeAttr: function(renderer, stylePrefix) {
                return {
                    lineWidth: renderer.getRenderConfig(stylePrefix + "_line_width"),
                    lineDash: renderer.getRenderConfig(stylePrefix + "_line_dash"),
                    lineDashOffset: renderer.getRenderConfig(stylePrefix + "_line_dash_offset")
                };
            },
            getStrokeOpt: function(renderer, bounds, stylePrefix) {
                var strokeStyle = $GVRendererDraw.getStyle(renderer, bounds, stylePrefix);
                if (strokeStyle) {
                    var strokeAttr = $GVRendererDraw.getStrokeAttr(renderer, stylePrefix);
                    if (!strokeAttr.lineWidth > 0) {
                        strokeStyle = null;
                    }
                }
                return {
                    stroke: strokeStyle,
                    attr: strokeAttr
                };
            },
            getStyle: function(renderer, rect, stylePrefix) {
                var _styleType = renderer.getRenderConfig(stylePrefix);
                rect = {
                    x: rect.x,
                    y: rect.y,
                    width: $MathMax(1, rect.width),
                    height: $MathMax(1, rect.height)
                };
                var style;
                if (_styleType === "linear_gradient") {
                    style = $C2DGradientUtil.createRectDirectionLinearGradient(rect, renderer.getRenderConfig(stylePrefix + "_gradient_direction"), renderer.getRenderConfig(stylePrefix + "_gradient_colors"));
                } else if (_styleType === "radial_gradient") {
                    style = $C2DGradientUtil.createRectDirectionRadialGradient(rect, renderer.getRenderConfig(stylePrefix + "_gradient_direction"), renderer.getRenderConfig(stylePrefix + "_gradient_colors"));
                } else if (_styleType === "conic_gradient") {
                    style = $C2DGradientUtil.createRectConicGradient(rect, renderer.getRenderConfig(stylePrefix + "_gradient_colors"), 0);
                } else if (_styleType === "pattern") {
                    style = $C2DPatternUtil.createPattern(renderer.getRenderConfig(stylePrefix + "_pattern_image"));
                } else {
                    style = _styleType;
                }
                return style;
            },
            drawLabel: function(renderer, g2d) {
                var labelProps = $GVRendererConfig.getCalcRenderLabelProperty(renderer);
                if (!labelProps) {
                    return;
                }
                var renderProps = labelProps.render_props;
                if (renderProps) {
                    var label_bounds = renderProps.bounds;
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, label_bounds, "label_stroke");
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DTextUtil.render(g2d, renderer.getRenderConfig("label"), renderProps.point, {
                            fill: $GVRendererDraw.getStyle(renderer, label_bounds, "label_fill"),
                            stroke: strokeOpt.stroke
                        }, renderProps.direction, {
                            align: renderer.getRenderConfig("label_align"),
                            font: renderer.getRenderConfig("label_font"),
                            text_size: renderProps.size,
                            rotation: renderProps.rotation
                        });
                    });
                }
            },
            drawLabelBox: function(renderer, g2d) {
                var labelBoxProps = $GVRendererConfig.getCalcRenderLabelBoxProperty(renderer);
                if (!labelBoxProps) {
                    return;
                }
                var renderProps = labelBoxProps.render_props;
                if (renderProps) {
                    var label_box_bounds = renderProps.bounds;
                    var rotation = renderProps.rotation | 0;
                    var center = {
                        x: label_box_bounds.x + label_box_bounds.width / 2,
                        y: label_box_bounds.y + label_box_bounds.height / 2
                    };
                    $canvasRotateAround(g2d, rotation, center, function() {
                        var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, label_box_bounds, "label_box_stroke");
                        var fill = $GVRendererDraw.getStyle(renderer, label_box_bounds, "label_box_fill");
                        $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                            $C2DRectShapeUtil.render(g2d, label_box_bounds, "rect", {
                                fill: fill,
                                stroke: strokeOpt.stroke
                            });
                        });
                    });
                }
            },
            drawInfo: function(renderer, g2d) {
                var infoProps = $GVRendererConfig.getCalcRenderInfoProperty(renderer);
                if (!infoProps) {
                    return;
                }
                var renderProps = infoProps.render_props;
                if (renderProps) {
                    var info_bounds = renderProps.bounds;
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, info_bounds, "info_stroke");
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DTextUtil.render(g2d, renderer.getRenderConfig("info"), renderProps.point, {
                            fill: $GVRendererDraw.getStyle(renderer, info_bounds, "info_fill"),
                            stroke: strokeOpt.stroke
                        }, renderProps.direction, {
                            align: renderer.getRenderConfig("info_align"),
                            font: renderer.getRenderConfig("info_font"),
                            text_size: renderProps.size,
                            rotation: renderProps.rotation
                        });
                    });
                }
            },
            drawInfoBox: function(renderer, g2d) {
                var infoBoxProps = $GVRendererConfig.getCalcRenderInfoBoxProperty(renderer);
                if (!infoBoxProps) {
                    return;
                }
                var renderProps = infoBoxProps.render_props;
                if (renderProps) {
                    var info_box_bounds = renderProps.bounds;
                    var info_box_points = renderProps.points;
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, info_box_bounds, "info_box_stroke");
                    var fill = $GVRendererDraw.getStyle(renderer, info_box_bounds, "info_box_fill");
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DPathUtil.render(g2d, info_box_points, {
                            fill: fill,
                            stroke: strokeOpt.stroke
                        });
                    });
                }
            }
        };
        var $NodeRendererDraw = {
            draw: function(renderer, g2d) {
                var bodyBounds = $GVRendererConfig.getCalcRenderBodyBounds(renderer);
                if (!bodyBounds) {
                    return;
                }
                var type = renderer.getRenderConfig("type");
                if (type === "image") {
                    $NodeRendererDraw._drawImage(renderer, g2d, bodyBounds);
                } else if (type === "path") {
                    $NodeRendererDraw._drawPath(renderer, g2d, bodyBounds);
                } else if (type === "heatmap") {
                    $NodeRendererDraw._drawHeatMap(renderer, g2d, bodyBounds);
                } else {
                    $NodeRendererDraw._drawShape(renderer, g2d, bodyBounds);
                }
                $NodeRendererDraw._drawOutline(renderer, g2d, bodyBounds);
            },
            _drawImage: function(renderer, g2d, bodyBounds) {
                var img = renderer.getRenderConfig($RendererProperties.NODE_IMAGE);
                if (img) {
                    g2d.drawImage(img, bodyBounds.x, bodyBounds.y, bodyBounds.width, bodyBounds.height);
                } else {
                    $C2DRectShapeUtil.render(g2d, bodyBounds, "rect", {
                        strokeStyle: "#ccc",
                        fillStyle: "#eee"
                    }, true);
                }
            },
            _drawPath: function(renderer, g2d, bodyBounds) {
                var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, bodyBounds, "stroke");
                $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                    $C2DPathUtil.render(g2d, renderer.getRenderConfig("points"), {
                        fill: $GVRendererDraw.getStyle(renderer, bodyBounds, "fill"),
                        stroke: strokeOpt.stroke
                    }, true);
                });
                $ArrowDraw.drawNodePathArrow(renderer, g2d);
            },
            _drawHeatMap: function(renderer, g2d, bodyBounds) {
                $HeatMapUtil.drawHM(renderer, g2d, bodyBounds);
            },
            _drawShape: function(renderer, g2d, bodyBounds) {
                var shape = renderer.getRenderConfig("shape");
                if (shape) {
                    var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, bodyBounds, "stroke");
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DRectShapeUtil.render(g2d, bodyBounds, shape, {
                            fill: $GVRendererDraw.getStyle(renderer, bodyBounds, "fill"),
                            stroke: strokeOpt.stroke
                        }, {
                            radius: renderer.getRenderConfig("roundrect_radius")
                        }, true);
                    });
                }
            },
            _drawOutline: function(renderer, g2d, bodyBounds) {
                var outline_bounds = $GVRendererConfig.getCalcRenderProperty(renderer, "outline_bounds");
                if (!outline_bounds) {
                    return;
                }
                var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, bodyBounds, "outline_stroke");
                if (strokeOpt.stroke) {
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DRectShapeUtil.render(g2d, outline_bounds, "rect", {
                            stroke: strokeOpt.stroke
                        });
                    });
                }
            },
            drawSelectBorder: function(renderer, g2d) {
                if (renderer.getRenderConfig("select_style") !== "border") {
                    return;
                }
                var select_border_bounds = $GVRendererConfig.getCalcRenderProperty(renderer, "border_bounds");
                if (!select_border_bounds) {
                    return;
                }
                var strokeOpt = $GVRendererDraw.getStrokeOpt(renderer, select_border_bounds, "select_border_stroke");
                if (strokeOpt.stroke) {
                    $saveAndSet2DAttributes(g2d, strokeOpt.attr, function() {
                        $C2DRectShapeUtil.render(g2d, select_border_bounds, "rect", {
                            stroke: strokeOpt.stroke
                        });
                    });
                }
            }
        };
        var $LinkRendererDraw = {
            draw: function(renderer, g2d) {
                var pathPoints = $GVRendererConfig.getCalcRenderProperty(renderer, "draw_points");
                if (pathPoints == null || pathPoints.length < 2) {
                    return;
                }
                $LinkRendererDraw._drawSelectBorder(renderer, g2d, pathPoints);
                var bounds = $GVRendererConfig.getCalcRenderBodyBounds(renderer);
                var opt = $GVRendererDraw.getStrokeOpt(renderer, bounds, "stroke");
                var linearGradientStroke = $LinkRendererDraw._getLinkLinearGradientStroke(renderer, pathPoints);
                if (linearGradientStroke) {
                    opt.stroke = linearGradientStroke;
                }
                $saveAndSet2DAttributes(g2d, opt.attr, function() {
                    $C2DPathUtil.render(g2d, pathPoints, {
                        stroke: opt.stroke
                    }, true);
                });
                $ArrowDraw.drawLinkArrow(renderer, g2d);
            },
            _getLinkLinearGradientStroke: function(renderer, points) {
                if (points.length > 1) {
                    var styleType = renderer.getRenderConfig("stroke");
                    if (styleType === "linear_gradient") {
                        return $C2DGradientUtil.createLinearGradient(points[0], points[points.length - 1], renderer.getRenderConfig("stroke_gradient_colors"));
                    }
                }
            },
            _drawSelectBorder: function(renderer, g2d, pathPoints) {
                if (renderer.getRenderConfig("select_style") !== "border") {
                    return;
                }
                var bounds = $GVRendererConfig.getCalcRenderBodyBounds(renderer);
                var line_width = renderer.getRenderConfig("stroke_line_width") | 0;
                var borderOpt = $GVRendererDraw.getStrokeOpt(renderer, bounds, "select_border_stroke");
                borderOpt.attr = borderOpt.attr || {};
                borderOpt.attr.lineWidth = line_width + $MathMax((borderOpt.attr.lineWidth | 0) * 2, 2);
                $saveAndSet2DAttributes(g2d, borderOpt.attr, function() {
                    $C2DPathUtil.render(g2d, pathPoints, {
                        stroke: borderOpt.stroke
                    }, true);
                });
            }
        };
        var $RendererProperties = {
            CALC_RENDER_PROPS: "calc_render_props_$",
            NODE_IMAGE: "node_image_$",
            NODE_SELECT_BORDER_BOUNDS: "node_select_border_bounds_$"
        };
        var $GVRenderer = function() {
            $GVRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($GVRenderer, $IDataCanvasRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $GVRenderer.superClass.updateRenderConfig.apply(this, arguments);
                renderConfig["alpha"] = view.getDataViewProperty(data, "alpha", "data_alpha");
                renderConfig["style"] = view.getDataViewProperty(data, "style", "data_style");
                $GVRendererConfig.updateLabelConfig(this, view, data, renderConfig);
                $GVRendererConfig.updateInfoConfig(this, view, data, renderConfig);
                $GVRendererConfig.updateSelectedConfig(this, view, data, renderConfig);
            },
            doDraw: function(g2d, drawBodyOnly) {
                $GVRenderer.superClass.doDraw.apply(this, arguments);
                if (this.getRenderConfig($RendererProperties.CALC_RENDER_PROPS) == null) {
                    return;
                }
                this._updateRenderAttributes(g2d, drawBodyOnly, function(g2d) {
                    this._drawBody(g2d);
                    if (drawBodyOnly !== true) {
                        if (this.getRenderConfig("label_in_front") !== true) {
                            this.drawLabel(g2d);
                        }
                        if (this.getRenderConfig("info_in_front") !== true) {
                            this.drawInfo(g2d);
                        }
                    }
                });
            },
            _updateRenderAttributes: function(g2d, drawBodyOnly, renderFunc) {
                var attr = {
                    globalAlpha: this.getRenderConfig("alpha")
                };
                var style = this.getRenderConfig("style");
                if (style) {
                    attr = $mergeObject(attr, style);
                    if (drawBodyOnly === true) {
                        delete attr.shadowColor;
                    }
                }
                if (drawBodyOnly !== true) {
                    var hover_style = this.getRenderConfig("hover_style");
                    if (hover_style) {
                        attr = $mergeObject(attr, hover_style);
                    }
                    var select_style = this.getRenderConfig("select_style");
                    if (select_style != null) {
                        if (select_style === "shadow") {
                            attr.shadowBlur = this.getRenderConfig("select_shadow_blur");
                            attr.shadowColor = this.getRenderConfig("select_shadow_color");
                            var select_shadow_offset = $GViewUtil.getOffset(this._view, this._data, "select_shadow");
                            attr.shadowOffsetX = select_shadow_offset.x;
                            attr.shadowOffsetY = select_shadow_offset.y;
                        } else if ($isObject(select_style)) {
                            attr = $mergeObject(attr, select_style);
                        }
                    }
                }
                $saveAndSet2DAttributes(g2d, attr, renderFunc, this);
                return attr;
            },
            _drawBody: function(g2d) {
                var drawBody = this._data.drawBody;
                if (drawBody && drawBody.apply(this._data, [ g2d, this._data, this._view, this ]) === false) {
                    return;
                }
                this.drawBody(g2d);
            },
            drawBody: function(g2d) {},
            drawLabel: function(g2d, notRenderer) {
                if (notRenderer === true) {
                    this._updateRenderAttributes(g2d, false, this._drawLabel);
                } else {
                    this._drawLabel(g2d);
                }
            },
            _drawLabel: function(g2d) {
                $saveAndSet2DAttributes(g2d, this.getRenderConfig("label_style"), function() {
                    $GVRendererDraw.drawLabelBox(this, g2d);
                    $GVRendererDraw.drawLabel(this, g2d);
                }, this);
            },
            drawInfo: function(g2d, notRenderer) {
                if (notRenderer === true) {
                    this._updateRenderAttributes(g2d, false, this._drawInfo);
                } else {
                    this._drawInfo(g2d);
                }
            },
            _drawInfo: function(g2d) {
                $saveAndSet2DAttributes(g2d, this.getRenderConfig("info_style"), function() {
                    $GVRendererDraw.drawInfoBox(this, g2d);
                    $GVRendererDraw.drawInfo(this, g2d);
                }, this);
            },
            hits: function(point, bodyOnly) {
                var bounds = $GVRendererConfig.getCalcRenderProperty(this, "bounds");
                if (bounds == null) {
                    return false;
                }
                bounds = $MathRectUtil.createGrowRect(bounds, 30, 30);
                if ($MathPointUtil.rectContainsPoint(bounds, point) === false) {
                    return false;
                }
                return $GVRenderer.superClass.hits.apply(this, arguments);
            }
        });
        var $NodeRenderer = function() {
            $NodeRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($NodeRenderer, $GVRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $NodeRenderer.superClass.updateRenderConfig.apply(this, arguments);
                $NodeRendererConfig.updateNodeConfig(this, view, data, renderConfig);
            },
            doDraw: function(g2d, drawBodyOnly) {
                $NodeRenderer.superClass.doDraw.apply(this, arguments);
                if (this.getRenderConfig($RendererProperties.CALC_RENDER_PROPS) == null) {
                    return;
                }
                $NodeRendererDraw.drawSelectBorder(this, g2d);
            },
            _updateRenderAttributes: function(g2d, drawBodyOnly, renderFunc) {
                var args = arguments;
                var rotation = this.getRenderConfig("rotation");
                if (rotation == null || rotation === 0) {
                    return $NodeRenderer.superClass._updateRenderAttributes.apply(this, args);
                }
                $canvasRotateAround(g2d, rotation, $MathRectUtil.getRectCenter($GVRendererConfig.getCalcRenderBodyBounds(this)), function(g2d) {
                    $NodeRenderer.superClass._updateRenderAttributes.apply(this, args);
                }, this);
            },
            drawBody: function(g2d) {
                $NodeRenderer.superClass.drawBody.apply(this, arguments);
                $NodeRendererDraw.draw(this, g2d);
            },
            getBounds: function(bodyOnly) {
                if (bodyOnly === true) {
                    return $GVRendererConfig.getCalcRenderProperty(this, "body_bounds_render");
                }
                return $GVRendererConfig.getCalcRenderProperty(this, "bounds_render");
            }
        });
        var $LinkRenderer = function() {
            $LinkRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($LinkRenderer, $GVRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $LinkRenderer.superClass.updateRenderConfig.apply(this, arguments);
                $LinkRendererConfig.updateLinkConfig(this, view, data, renderConfig);
            },
            drawBody: function(g2d) {
                $LinkRenderer.superClass.drawBody.apply(this, arguments);
                $LinkRendererDraw.draw(this, g2d);
            },
            getBounds: function(bodyOnly) {
                if (bodyOnly === true) {
                    return $GVRendererConfig.getCalcRenderProperty(this, "body_bounds");
                }
                return $GVRendererConfig.getCalcRenderProperty(this, "bounds");
            }
        });
        var $GroupRenderer = function() {
            $GroupRenderer.superClass.constructor.apply(this, arguments);
        };
        $extendClass($GroupRenderer, $NodeRenderer, {
            updateRenderConfig: function(view, data, renderConfig) {
                $GroupRenderer.superClass.updateRenderConfig.apply(this, arguments);
                $GroupRendererConfig.updateGroupConfig(this, view, data, renderConfig);
            }
        });
        var $DragController = function() {
            $DragController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($DragController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "mousedown" ];
            },
            isDraggable: function(evt, view) {
                return false;
            },
            onDragStart: function(evt, view) {},
            onDragEnd: function(evt, view) {},
            onDrag: function(evt, view) {},
            getDragCursor: function(evt) {},
            reset: function(evt, view) {},
            handle_mousedown: function(evt, view) {
                if (this.isDraggable(evt, view)) {
                    this._mousedown_point = this.getView().getEventRelativePoint(evt);
                    this._addDragListener();
                    this.onDragStart(evt, view);
                }
            },
            handle_drag_mousemove: function(evt) {
                if (this._mousedown_point == null) {
                    return;
                }
                evt.preventDefault();
                if (this._drag_cursor_set !== true) {
                    this._drag_cursor_set = true;
                }
                $CVSControllerUtil.setCursor(this, this.getDragCursor());
                this.onDrag(evt, this.getView());
            },
            handle_drag_mouseup: function(evt) {
                var view = this.getView();
                this.onDragEnd(evt, view);
                this._removeDragListener();
                this._reset(evt, view);
            },
            _reset: function(evt, view) {
                $CVSControllerUtil.setCursor(this, "default");
                delete this._mousedown_point;
                delete this._drag_cursor_set;
                this.reset(evt, view);
            },
            _addDragListener: function() {
                if (this._drag_listener_added === true) {
                    return;
                }
                this._drag_listener_added = true;
                $domTypeOn(window, "mousemove", this.handle_drag_mousemove, this);
                $domTypeOn(window, "mouseup", this.handle_drag_mouseup, this);
            },
            _removeDragListener: function() {
                if (this._drag_listener_added !== true) {
                    return;
                }
                this._drag_listener_added = false;
                $domTypeOff(window, "mousemove", this.handle_drag_mousemove, this);
                $domTypeOff(window, "mouseup", this.handle_drag_mouseup, this);
            }
        });
        var $TransformController = function() {
            $TransformController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($TransformController, $DragController, {
            getViewDefaultTypes: function() {
                return [ "wheel", "mousedown" ];
            },
            handle_wheel: function(evt, view) {
                if (evt.buttons > 0) {
                    return;
                }
                evt.preventDefault();
                var zoomFactor = view.getProperty("zoom_factor");
                var zoom = view.getProperty("zoom");
                if ($DomWheelEventUtil.isWheelDown(evt)) {
                    zoom /= zoomFactor;
                } else {
                    zoom *= zoomFactor;
                }
                view.zoomByPoint(zoom, view.getEventRelativePoint(evt));
            },
            isDraggable: function(evt, view) {
                if ($DomEventUtil.isMouseAuxiliaryButton(evt)) {
                    return true;
                }
                return !evt.ctrlKey && !view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
            },
            onDragStart: function(evt, view) {
                this._mousedown_translate_x = view.getProperty("translate_x");
                this._mousedown_translate_y = view.getProperty("translate_y");
            },
            onDrag: function(evt, view) {
                if (this._mousedown_translate_x == null) {
                    return;
                }
                var vp = view.getEventRelativePoint(evt);
                var x_off = vp.x - this._mousedown_point.x;
                var y_off = vp.y - this._mousedown_point.y;
                var ntx = this._mousedown_translate_x + x_off;
                var nty = this._mousedown_translate_y + y_off;
                view.translate(ntx, nty);
            },
            getDragCursor: function() {
                return "grabbing";
            },
            reset: function(evt, view) {
                this._mousedown_translate_x = null;
                this._mousedown_translate_y = null;
            }
        });
        var $DefaultController = function() {
            $DefaultController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($DefaultController, $IViewController, {
            getViewDefaultTypes: function() {
                return [ "click", "dblclick", "contextmenu" ];
            },
            handle_contextmenu: function(evt, view) {
                evt.preventDefault();
            },
            handle_click: function(evt, view) {
                var data = view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    view._onDataClick(data, evt);
                }
            },
            handle_dblclick: function(evt, view) {
                evt.stopPropagation();
                var data = view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
                if (data) {
                    if (view._isDisabled(data)) {
                        return;
                    }
                    if ($isSubview(data)) {
                        if (this._isSubviewDrillOnDblClick(view, data)) {
                            view.setCurrentSubview(data);
                        }
                    } else if ($isGroup(data)) {
                        if (view._isExpandable(data) && this._isGroupExpandOnDblClick(view, data)) {
                            view.toggleExpand(data);
                        }
                    } else if ($isLink(data)) {
                        if (view._isLinkBundleable(data) && this._isLinkBundleOnDblClick(view, data)) {
                            view.toggleLinkBundle(data);
                        }
                    }
                    view._onDataDblClick(data, evt);
                } else {
                    if (this._isSubviewDrillOnDblClick(view, data)) {
                        var currentSubview = view.getCurrentSubview();
                        if (currentSubview) {
                            view.setCurrentSubview($SubviewUtil.getDataSubview(currentSubview));
                        }
                    }
                }
            },
            _isGroupExpandOnDblClick: function(view, data) {
                return view.getDataViewProperty(data, "expand_on_dblclick", "group_expand_on_dblclick") !== false;
            },
            _isSubviewDrillOnDblClick: function(view, data) {
                if (data) {
                    return view.getDataViewProperty(data, "drill_on_dblclick", "subview_drill_on_dblclick") !== false;
                }
                return view.getProperty("subview_drill_on_dblclick") !== false;
            },
            _isLinkBundleOnDblClick: function(view, data) {
                if (data) {
                    return view.getDataViewProperty(data, "bundle_on_dblclick", "link_bundle_on_dblclick") !== false;
                }
                return view.getProperty("bundle_on_dblclick") !== false;
            }
        });
        var $SelectController = function() {
            $SelectController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($SelectController, $DragController, {
            getViewDefaultTypes: function() {
                return [ "mousedown" ];
            },
            _isMultipleSelect: function() {
                return this.getView().getSelectMode() === "multiple";
            },
            isDraggable: function(evt, view) {
                return evt.ctrlKey && !view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view)) && this._isMultipleSelect();
            },
            getDragCursor: function() {
                return "crosshair";
            },
            reset: function(evt, view) {
                this._mousemove_point = null;
                if (this._drag_draw_added === true) {
                    this._drag_draw_added = false;
                    view.removeControllerDraw(this.drawAreaSelect, this);
                }
            },
            handle_mousedown: function(evt, view) {
                if ($DomEventUtil.isMouseAuxiliaryButton(evt)) {
                    return;
                }
                var data = view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
                if (data) {
                    if (view._isDisabled(data) || !view.isSelectable(data)) {
                        return;
                    }
                    if (evt.ctrlKey) {
                        if (view.isSelected(data)) {
                            view.removeSelect(data);
                        } else {
                            if (this._isMultipleSelect()) {
                                view.addSelect(data);
                            } else {
                                view.setSelect(data);
                            }
                        }
                    } else {
                        if (!view.isSelected(data)) {
                            view.setSelect(data);
                        }
                    }
                    return;
                }
                if (this.isDraggable(evt, view)) {
                    return $SelectController.superClass.handle_mousedown.apply(this, arguments);
                }
                if (!data) {
                    view.clearSelect();
                }
            },
            onDrag: function(evt, view) {
                this._mousemove_point = view.getEventRelativePoint(evt);
                view.updateControllerCanvas();
            },
            onDragStart: function(evt, view) {
                if (this._drag_draw_added !== true) {
                    this._drag_draw_added = true;
                    view.addControllerDraw(this.drawAreaSelect, this);
                }
            },
            onDragEnd: function(evt, view) {
                var rect = this._getSelectRect();
                if (rect) {
                    var arr = view.getDataArrayAtRect(rect);
                    if (evt.ctrlKey) {
                        arr.forEach(function(data) {
                            if (view.isSelected(data)) {
                                view.removeSelect(data);
                            } else {
                                view.addSelect(data);
                            }
                        });
                    } else {
                        view.setSelect(arr);
                    }
                }
            },
            drawAreaSelect: function(g2d) {
                var rect = this._getSelectRect();
                if (rect) {
                    $C2DUtil.saveAndSet2DAttributes(g2d, {
                        lineWidth: .6
                    }, function() {
                        $C2DRectShapeUtil.render(g2d, rect, "rect", {
                            fill: "rgba(51,153,255,0.2)",
                            stroke: "#3399ff"
                        });
                    });
                }
            },
            _getSelectRect: function() {
                var mousedown_point = this._mousedown_point;
                var mousemove_point = this._mousemove_point;
                if (mousedown_point == null || mousemove_point == null) {
                    return null;
                }
                var x = $MathMin(mousedown_point.x, mousemove_point.x);
                var y = $MathMin(mousedown_point.y, mousemove_point.y);
                var width = $MathMax(mousedown_point.x, mousemove_point.x) - x;
                var height = $MathMax(mousedown_point.y, mousemove_point.y) - y;
                var intersect = x < mousemove_point.x && y < mousemove_point.y;
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    intersect: intersect
                };
            }
        });
        var $MoveController = function() {
            $MoveController.superClass.constructor.apply(this, arguments);
        };
        $extendClass($MoveController, $DragController, {
            isDraggable: function(evt, view) {
                if (!$DomEventUtil.isMouseMainButton(evt)) {
                    return false;
                }
                var data = view.getDataAt(evt, $CVSControllerUtil.isInteractBodyOnly(view));
                if (data == null || view._isDisabled(data)) {
                    return false;
                }
                return true;
            },
            onDragStart: function(evt, view) {
                this._mousemove_point = view.getTransformedPoint(evt);
            },
            reset: function() {
                delete this._move_node_arr;
            },
            onDrag: function(evt, view) {
                var move_point = view.getTransformedPoint(evt);
                if (this._move_node_arr == null) {
                    var move_arr = [];
                    var selected_arr = view.getSelected(false);
                    selected_arr.forEach(function(data) {
                        if (!$isNode(data) || view._isDisabled(data) || !view._isMovable(data)) {
                            return;
                        }
                        var groupArr = $SubviewUtil.getSameSubviewAncestorArray(data);
                        if ($findArray(groupArr, function(group) {
                            return selected_arr.indexOf(group) > -1;
                        })) {
                            return;
                        }
                        if ($isGroup(data)) {
                            $mergeArray(move_arr, this._getGroupChildren(data, view));
                            return;
                        }
                        move_arr.push(data);
                    }, this);
                    this._move_node_arr = move_arr;
                }
                this._move(move_point.x - this._mousemove_point.x, move_point.y - this._mousemove_point.y);
                this._mousemove_point = move_point;
            },
            _getGroupChildren: function(group, view) {
                return $filterArray($DataLevelUtil.getAddedDescendantArray(view.getProvider(), group), function(data) {
                    return $isNode(data) && !$isGroup(data);
                });
            },
            _move: function(xOffset, yOffset) {
                this._move_node_arr.forEach(function(data) {
                    var pos = data.getPosition();
                    data.setPosition(pos.x + xOffset, pos.y + yOffset);
                }, this);
            }
        });
        var $GVLayout = function(gView, props) {
            if (!$ModelTypeCheck.isGView(gView) && arguments.length === 1) {
                props = arguments[0];
                gView = null;
            }
            this._gView = gView;
            this._is_updating = false;
            $GVLayout.superClass.constructor.apply(this, [ props ]);
            this._updateStartOnChange();
        };
        $extendClass($GVLayout, $ZObject, {
            ___zdefaults_: {
                movable_on_selected: false,
                stop_on_complete: false,
                start_on_change: false
            },
            afterSetProperty: function(key, value, old) {
                $IView.superClass.afterSetProperty.apply(this, arguments);
                if (key === "start_on_change") {
                    this._updateStartOnChange();
                }
            },
            _updateStartOnChange: function() {
                if (!this._gView) {
                    return;
                }
                if (this.get("start_on_change") === true) {
                    this._addChangeListener();
                } else {
                    this._removeChangeListener();
                }
            },
            _addChangeListener: function() {
                if (this._on_model_change === true) {
                    return;
                }
                this._on_model_change = true;
                this._gView.onModelChange(this._handleModelChange, this);
            },
            _removeChangeListener: function() {
                if (this._on_model_change !== true) {
                    this._gView.offModelChange(this._handleModelChange, this);
                }
            },
            _handleModelChange: function(evt) {
                if (this._is_updating === true) {
                    return;
                }
                var type = evt.type;
                if (type === "data") {
                    var event = evt.event;
                    var data = event.data;
                    var property = event.property;
                    if (property !== "x" && property !== "y" || !this._isLayoutNode(data)) {
                        return;
                    }
                    this.start();
                }
            },
            start: function() {},
            stop: function() {},
            layout: function() {},
            rebuild: function() {},
            step: function() {},
            onComplete: function() {},
            getProvider: function() {
                return this._gView.getProvider();
            },
            getNodeBounds: function(node) {
                return node.getBounds(this._gView);
            },
            isSelected: function(data) {
                if (this._gView) {
                    return this._gView.isSelected(data);
                }
                return false;
            },
            isVisible: function(data) {
                if (this._gView) {
                    return this._gView._isVisible(data);
                }
                return true;
            },
            _isLayoutNode: function(node) {
                if (!$isNode(node)) {
                    return false;
                }
                if ($isGroup(node)) {
                    if (this._gView) {
                        return !this._gView.isExpanded(node);
                    }
                    return false;
                }
                return true;
            },
            _getLayoutNodes: function(dataArr) {
                var _this = this;
                var gv = this.getGView();
                if (dataArr == null) {
                    if (gv) {
                        dataArr = gv.getDataArray();
                    }
                }
                if (dataArr) {
                    return $filterArray(dataArr, function(data) {
                        return _this.isVisible(data) && _this._isLayoutNode(data);
                    });
                }
                return [];
            },
            isMovable: function(data) {
                if (!this._gView) {
                    return true;
                }
                if (this._gView.isMovable(data) === false) {
                    return false;
                }
                if (this.get("movable_on_selected") === false) {
                    if (this.isSelected(data)) {
                        return false;
                    }
                }
                if (!$isNode(data)) {
                    return false;
                }
                if ($isGroup(data)) {
                    return !this._gView.isExpanded(data);
                }
                return true;
            },
            getGView: function() {
                return this._gView;
            }
        });
        var $ForceLayout = function(gView, props) {
            this._damper = 1;
            this._maxMotion = 0;
            this._motionRatio = 0;
            this._sNodeMap = {};
            this._sNodeArr = [];
            this._sLinkArr = [];
            $ForceLayout.superClass.constructor.apply(this, arguments);
        };
        $extendClass($ForceLayout, $GVLayout, {
            ___zdefaults_: {
                start_on_change: true,
                stop_on_complete: true,
                node_repulsion: .8,
                link_repulsion: .2,
                link_limit: 30,
                limit_bounds: null,
                motion_limit: .01
            },
            start: function() {
                this._damper = 1;
                if (this._timer) {
                    return;
                }
                this._hasFix = false;
                this._timer = $callRAFInterval(this._step, this);
            },
            stop: function() {
                if (this._timer) {
                    $TimerUtil.cancelCallRAFInterval(this._timer);
                    this._timer = null;
                }
                this._hasFix = false;
            },
            layout: function() {
                this._damper = 1;
                while (this._step() !== "complete") {}
            },
            _step: function() {
                this._rebuild();
                this._doRelax();
                this._updatePosition();
                this.step();
                if (this._isComplete()) {
                    if (this.get("stop_on_complete") === true) {
                        this.stop();
                    }
                    this.onComplete();
                    return "complete";
                }
            },
            _isComplete: function() {
                return this._damper < .1 && this._maxMotion < this.get("motion_limit");
            },
            _doRelax: function() {
                for (var i = 0; i < 8; i++) {
                    var nodeCount = this._sNodeArr.length;
                    this._sLinkArr.forEach(this._relaxLink, this);
                    for (var m = 0; m < nodeCount; m++) {
                        for (var n = 0; n < nodeCount; n++) {
                            var n1 = this._sNodeArr[m];
                            var n2 = this._sNodeArr[n];
                            if (n1 !== n2) {
                                this._relaxNodePair(n1, n2);
                            }
                        }
                    }
                    this._adjustNodes();
                }
            },
            _updatePosition: function() {
                var nodeCount = this._sNodeArr.length;
                this._is_updating = true;
                for (var j = 0; j < nodeCount; j++) {
                    var node = this._sNodeArr[j];
                    if (!node.fix) {
                        node.data.setPosition(node.x, node.y);
                    }
                }
                this._is_updating = false;
            },
            _adjustNodes: function() {
                var _this = this;
                var lastMaxMotion = this._maxMotion;
                var maxMotionA = 0;
                var limitBounds = this.get("limit_bounds");
                if (limitBounds) {
                    var limitBoundsLeft = limitBounds.x;
                    var limitBoundsTop = limitBounds.y;
                    var limitBoundsRight = limitBounds.x + limitBounds.width;
                    var limitBoundsBottom = limitBounds.y + limitBounds.height;
                }
                this._sNodeArr.forEach(function(n) {
                    var dx = n.dx;
                    var dy = n.dy;
                    dx *= _this._damper;
                    dy *= _this._damper;
                    n.dx = dx / 2;
                    n.dy = dy / 2;
                    var distMoved = Math.sqrt(dx * dx + dy * dy);
                    if (!n.fix) {
                        n.x = n.x + Math.max(-30, Math.min(30, dx));
                        n.y = n.y + Math.max(-30, Math.min(30, dy));
                        if (!limitBounds) {
                            if (_this._hasFix !== true) {
                                if (n.x < 1) {
                                    _this._adjustLocation(1, 0);
                                }
                                if (n.y < 1) {
                                    _this._adjustLocation(0, 1);
                                }
                            }
                        } else {
                            if (n.x < limitBoundsLeft) {
                                n.x = limitBoundsLeft;
                                _this._adjustLocation(1, 0);
                            }
                            if (n.y < limitBoundsTop) {
                                n.y = limitBoundsTop;
                                _this._adjustLocation(0, 1);
                            }
                            var rect = _this.getNodeBounds(n.data);
                            if (rect) {
                                if (n.x + rect.width > limitBoundsRight) {
                                    n.x = limitBoundsRight - rect.width;
                                    _this._adjustLocation(-1, 0);
                                }
                                if (n.y + rect.height > limitBoundsBottom) {
                                    n.y = limitBoundsBottom - rect.height;
                                    _this._adjustLocation(0, -1);
                                }
                            }
                        }
                    }
                    maxMotionA = Math.max(distMoved, maxMotionA);
                });
                this._maxMotion = maxMotionA;
                if (this._maxMotion > 0) {
                    this._motionRatio = lastMaxMotion / this._maxMotion - 1;
                } else {
                    this._motionRatio = 0;
                }
                this._damp();
            },
            _damp: function() {
                if (this._motionRatio <= .001) {
                    if ((this._maxMotion < .2 || this._maxMotion > 1 && this._damper < .9) && this._damper > .01) {
                        this._damper -= .01;
                    } else if (this._maxMotion < .4 && this._damper > .003) {
                        this._damper -= .003;
                    } else if (this._damper > 1e-4) {
                        this._damper -= 1e-4;
                    }
                }
                if (this._maxMotion < this.get("motion_limit")) {
                    this._damper = 0;
                }
            },
            _relaxLink: function(link) {
                var vx = link.to.x - link.from.x;
                var vy = link.to.y - link.from.y;
                var nodeLength = Math.sqrt(vx * vx + vy * vy);
                var linkLength = link.length * 100;
                var dx = vx * .25 / linkLength;
                var dy = vy * .25 / linkLength;
                link.to.dx = link.to.dx - dx * nodeLength;
                link.to.dy = link.to.dy - dy * nodeLength;
                link.from.dx = link.from.dx + dx * nodeLength;
                link.from.dy = link.from.dy + dy * nodeLength;
            },
            _relaxNodePair: function(node1, node2) {
                var dx = 0;
                var dy = 0;
                var vx = node1.x - node2.x;
                var vy = node1.y - node2.y;
                var len = vx * vx + vy * vy;
                if (len === 0) {
                    dx = Math.random();
                    dy = Math.random();
                } else if (len < 36e4) {
                    dx = vx / len;
                    dy = vy / len;
                }
                var factor = node1.repulsion * node2.repulsion / 400;
                node1.dx += dx * factor;
                node1.dy += dy * factor;
                node2.dx -= dx * factor;
                node2.dy -= dy * factor;
            },
            _rebuild: function() {
                var sNodeMap = this._sNodeMap = {};
                var sNodeArr = this._sNodeArr = [];
                var sLinkArr = this._sLinkArr = [];
                var gView = this.getGView();
                var _this = this;
                var mNodeArr = [];
                var nLinkArr = [];
                var nLinkMap = {};
                gView.eachData(function(data) {
                    if (gView._isVisible(data)) {
                        if ($isNode(data)) {
                            if ($isGroup(data) && gView.isExpanded(data)) {
                                return;
                            }
                            mNodeArr.push(data);
                        } else if ($isLink(data)) {
                            var fromNode = $LinkUtil.getFromNodeAgent(gView, data);
                            var toNode = $LinkUtil.getToNodeAgent(gView, data);
                            if (fromNode && toNode) {
                                var ids = [ fromNode.id(), toNode.id() ];
                                ids.sort();
                                ids = ids.join(",");
                                if (!nLinkMap.hasOwnProperty(ids)) {
                                    nLinkMap[ids] = true;
                                    nLinkArr.push(data);
                                }
                            }
                        }
                    }
                });
                mNodeArr.forEach(function(mNode) {
                    var node = _this._createNode(mNode);
                    sNodeMap[mNode.id()] = node;
                    sNodeArr.push(node);
                });
                nLinkArr.forEach(function(mLink) {
                    var link = _this._createLink(mLink);
                    if (link) {
                        sLinkArr.push(link);
                    }
                });
            },
            _createLink: function(mLink) {
                if (mLink.isLoop()) {
                    return;
                }
                var fromNode = $LinkUtil.getFromNodeAgent(this._gView, mLink);
                var toNode = $LinkUtil.getToNodeAgent(this._gView, mLink);
                if (!fromNode || !toNode) {
                    return;
                }
                var from = this._sNodeMap[fromNode.id()];
                var to = this._sNodeMap[toNode.id()];
                if (!from || !to) {
                    return;
                }
                var link = {
                    data: mLink,
                    from: from,
                    to: to
                };
                var fromBounds = this.getNodeBounds(fromNode);
                var toBounds = this.getNodeBounds(toNode);
                var ftWidth = fromBounds.width + toBounds.width;
                var ftHeight = fromBounds.height + fromBounds.height;
                var length = Math.floor(Math.sqrt(ftWidth * ftWidth + ftHeight * ftHeight) * this.get("link_repulsion"));
                if (length <= this.get("link_limit")) {
                    length = this.get("link_limit");
                }
                link.length = length;
                return link;
            },
            _createNode: function(mNode) {
                var position = mNode.getPosition();
                var node = {
                    data: mNode,
                    x: position.x,
                    y: position.y,
                    dx: 0,
                    dy: 0,
                    fix: !this.isMovable(mNode),
                    repulsion: this._getRepulsion(mNode)
                };
                this._hasFix = node.fix || this._hasFix;
                return node;
            },
            _getRepulsion: function(mNode) {
                var rect = this.getNodeBounds(mNode);
                var result;
                if (rect) {
                    result = Math.floor(Math.sqrt(rect.width * rect.width + rect.height * rect.height) * this.get("node_repulsion"));
                    if (result <= 0) {
                        result = 100;
                    }
                } else {
                    result = 100;
                }
                return result;
            },
            _adjustLocation: function(xoffset, yoffset) {
                var limitBounds = this.get("limit_bounds");
                for (var i = 0, nodeSize = this._sNodeArr.length; i < nodeSize; i++) {
                    var n = this._sNodeArr[i];
                    var rect = this.getNodeBounds(n.data);
                    if (!rect) {
                        return;
                    }
                    if (xoffset !== 0) {
                        if (xoffset > 0) {
                            if (limitBounds == null || n.x + rect.width + xoffset < limitBounds.x + limitBounds.width) {
                                n.x += xoffset;
                            }
                        } else {
                            if (limitBounds == null || n.x + xoffset > limitBounds.x) {
                                n.x += xoffset;
                            }
                        }
                    }
                    if (yoffset !== 0) {
                        if (yoffset > 0) {
                            if (limitBounds == null || n.y + rect.height + yoffset < limitBounds.y + limitBounds.height) {
                                n.y += yoffset;
                            }
                        } else {
                            if (limitBounds == null || n.y + yoffset > limitBounds.y) {
                                n.y += yoffset;
                            }
                        }
                    }
                }
            }
        });
        var $GView = function() {
            if (!(this instanceof $GView)) {
                return $ClassUtil.createInstance($GView, arguments);
            }
            this._subViewTransform = {};
            $GView.superClass.constructor.apply(this, arguments);
            this._initControllerCanvas();
            this.addController(new $DefaultController());
            this.addController(new $TransformController());
            this.addController(new $SelectController());
            this.addController(new $MoveController());
        };
        $extendClass($GView, $IDataCanvasRendererView, $mergeObject({
            __toTypeString_GView_$: function() {
                return $TypeConst.GVIEW;
            },
            __className_: "GView",
            ___zdefaults_: {
                link_gap: $getDefault("GVIEW_LINK_GAP"),
                label_in_front: false,
                info_in_front: false,
                hit_padding: $getDefault("GVIEW_HIT_PADDING"),
                movable: true,
                select_mode: "multiple",
                group_expand_on_dblclick: $getDefault("GVIEW_GROUP_EXPAND_ON_DBLCLICK"),
                subview_drill_on_dblclick: $getDefault("GVIEW_SUBVIEW_DRILL_ON_DBLCLICK"),
                link_bundleable: false,
                link_bundle_on_dblclick: $getDefault("GVIEW_SUBVIEW_DRILL_ON_DBLCLICK")
            },
            _drawData: function(c2d) {
                $GView.superClass._drawData.apply(this, arguments);
                var dataArr;
                if (this.getProperty("label_in_front") === true) {
                    dataArr = this.getDrawDataArray();
                    dataArr.forEach(function(data) {
                        var renderer = this.getDataRenderer(data);
                        if (renderer) {
                            renderer.drawLabel(c2d, true);
                        }
                    }, this);
                }
                if (this.getProperty("info_in_front") === true) {
                    (dataArr || this.getDrawDataArray()).forEach(function(data) {
                        var renderer = this.getDataRenderer(data);
                        if (renderer) {
                            renderer.drawInfo(c2d, true);
                        }
                    }, this);
                }
            },
            getDrawDataArray: function() {
                return $mergeArray($GVDrawIndexUtil.getDrawGroupArray(this), $filterArray(this.getDataArray(false), function(data) {
                    return $isLink(data);
                }), $GVDrawIndexUtil.getDrawNodeArray(this));
            },
            getDataRendererClass: function(data) {
                if (data.getRendererClass) {
                    return data.getRendererClass();
                }
            },
            toImage: function(type) {
                var img = new Image();
                img.src = $GViewUtil.toDataURL(this, type);
                return img;
            },
            eachNode: function(callBack, context, notGroup) {
                var nodes = this.filterData(function(data) {
                    if (notGroup === true && $isGroup(data)) {
                        return false;
                    }
                    return $isNode(data);
                });
                if (nodes.length > 0) {
                    $eachArray(nodes, callBack, context);
                }
            },
            eachLink: function(callBack, context) {
                var links = this.filterData(function(data) {
                    return $isLink(data);
                });
                if (links.length > 0) {
                    $eachArray(links, callBack, context);
                }
            },
            makeVisible: function(data) {
                if (data) {
                    if ($isNode(data)) {
                        var subView = $SubviewUtil.getDataSubview(data);
                        this.setCurrentSubview(subView);
                        $SubviewUtil.expandSameSubviewGroup(this, data);
                    } else if ($isLink(data)) {
                        var from = $LinkUtil.getFromNodeAgent(this, data);
                        var to = $LinkUtil.getToNodeAgent(this, data);
                        this.setCurrentSubview($SubviewUtil.getSpanSubview(from, to));
                        if (from === to) {
                            $SubviewUtil.expandSameSubviewGroup(this, from, true);
                        } else {
                            $SubviewUtil.expandSameSubviewGroup(this, from);
                            $SubviewUtil.expandSameSubviewGroup(this, to);
                        }
                    }
                }
            }
        }, {
            translateCenter: function(later, data) {
                if (data != null) {
                    if (!$isArray(data)) {
                        data = [ data ];
                    }
                }
                if (later === true) {
                    $callRAFLater(function() {
                        this._transformFit(true, data);
                    }, this);
                } else {
                    this._transformFit(true, data);
                }
            },
            zoomFit: function(later, data) {
                if (data != null) {
                    if (!$isArray(data)) {
                        data = [ data ];
                    }
                }
                if (later === true) {
                    $callRAFLater(function() {
                        this._transformFit(false, data);
                    }, this);
                } else {
                    this._transformFit(false, data);
                }
            },
            _transformFit: function(keepZoom, data) {
                var visibleBounds = $GViewUtil.getVisibleDataBounds(this, data);
                if (!visibleBounds) {
                    return;
                }
                var ovw = visibleBounds.width;
                var ovh = visibleBounds.height;
                var size = this.getRootSize();
                var gap = $MathMin(30, $MathMin(size.width, size.height) / 10);
                var vpw = size.width - gap * 2;
                var vph = size.height - gap * 2;
                if (ovw > 0 && ovh > 0 && vpw > 0 && vph > 0) {
                    var zoom;
                    if (keepZoom === true) {
                        zoom = this.get("zoom");
                    } else {
                        var wzoom = vpw / ovw;
                        var hzoom = vph / ovh;
                        zoom = $MathMin(wzoom, hzoom);
                        var maxZoom = this.get("max_zoom");
                        var minZoom = this.get("min_zoom");
                        if (zoom > maxZoom) {
                            zoom = maxZoom;
                        }
                        if (zoom < minZoom) {
                            zoom = minZoom;
                        }
                    }
                    var nw = ovw * zoom;
                    var nh = ovh * zoom;
                    var xoff = gap + (vpw - nw) / 2 - visibleBounds.x * zoom;
                    var yoff = gap + (vph - nh) / 2 - visibleBounds.y * zoom;
                    this.set("zoom", zoom);
                    this.translate(xoff, yoff);
                }
            }
        }, $GVLevelInterface($GView), $LinkBundleInterface($GView), {
            _onProviderChange: function() {
                $GView.superClass._onProviderChange.apply(this, arguments);
                this._updateLinkBundleProvider();
            }
        }));
        $mergeObject(z.$, {
            gview: {
                ArrowCalculator: $ArrowCalculator,
                GroupCalculator: $GroupCalculator,
                InfoCalculator: $InfoCalculator,
                LabelCalculator: $LabelCalculator,
                LinkCalculator: $LinkCalculator,
                NodeCalculator: $NodeCalculator,
                CurveLinkPathCalculator: $CurveLinkPathCalculator,
                DefaultLinkPathCalculator: $DefaultLinkPathCalculator,
                LoopLinkPathCalculator: $LoopLinkPathCalculator,
                RALinkPathCalculator: $RALinkPathCalculator,
                GVLevelInterface: $GVLevelInterface,
                LinkBundleInterface: $LinkBundleInterface,
                DefaultController: $DefaultController,
                DragController: $DragController,
                MoveController: $MoveController,
                SelectController: $SelectController,
                TransformController: $TransformController,
                ForceLayout: $ForceLayout,
                GVLayout: $GVLayout,
                Group: $Group,
                GVData: $GVData,
                GVDataProperties: $GVDataProperties,
                Link: $Link,
                LinkSubview: $LinkSubview,
                Node: $Node,
                Subview: $Subview,
                GroupRendererConfig: $GroupRendererConfig,
                GVRendererConfig: $GVRendererConfig,
                LinkRendererConfig: $LinkRendererConfig,
                NodeRendererConfig: $NodeRendererConfig,
                ArrowDraw: $ArrowDraw,
                GVRendererDraw: $GVRendererDraw,
                LinkRendererDraw: $LinkRendererDraw,
                NodeRendererDraw: $NodeRendererDraw,
                HeatMapUtil: $HeatMapUtil,
                GroupRenderer: $GroupRenderer,
                GVRenderer: $GVRenderer,
                LinkRenderer: $LinkRenderer,
                NodeRenderer: $NodeRenderer,
                RendererProperties: $RendererProperties,
                GroupUtil: $GroupUtil,
                GVDrawIndexUtil: $GVDrawIndexUtil,
                GViewUtil: $GViewUtil,
                ModelTypeCheck: $ModelTypeCheck,
                LinkUtil: $LinkUtil,
                NodeUtil: $NodeUtil,
                SubviewUtil: $SubviewUtil,
                GView: $GView
            }
        });
        z.gv = {
            GView: $GView,
            Node: $Node,
            Link: $Link,
            Group: $Group,
            Subview: $Subview,
            LinkSubview: $LinkSubview,
            isNode: $isNode,
            isLink: $isLink,
            isGroup: $isGroup,
            isSubview: $isSubview,
            isLinkSubview: $isLinkSubview,
            layout: {
                Layout: $GVLayout,
                ForceLayout: $ForceLayout
            },
            renderer: {
                GVRenderer: $GVRenderer,
                NodeRenderer: $NodeRenderer,
                LinkRenderer: $LinkRenderer,
                GroupRenderer: $GroupRenderer
            }
        };
        $mergeObject(z.type, {
            isNode: $isNode,
            isLink: $isLink,
            isGroup: $isGroup,
            isSubview: $isSubview,
            isLinkSubview: $isLinkSubview
        });
    })(window);
})(window);

if (typeof module !== "undefined" && module.exports) {
    module.exports = z;
}